diff -urN CrashRpt-orig\complete.dsw CrashRpt\complete.dsw
--- CrashRpt-orig\complete.dsw	Wed Mar 05 18:39:32 2003
+++ CrashRpt\complete.dsw	Thu Apr 10 11:40:00 2003
@@ -3,7 +3,7 @@
 
 ###############################################################################
 
-Project: "CrashRpt"=..\crashrpt\src\CrashRpt.dsp - Package Owner=<4>
+Project: "CrashRpt"=.\crashrpt\src\CrashRpt.dsp - Package Owner=<4>
 
 Package=<5>
 {{{
@@ -15,7 +15,7 @@
 
 ###############################################################################
 
-Project: "CrashRptTest"=..\crashrpttest\src\CrashRptTest.dsp - Package Owner=<4>
+Project: "CrashRptTest"=.\crashrpttest\src\CrashRptTest.dsp - Package Owner=<4>
 
 Package=<5>
 {{{
@@ -30,7 +30,7 @@
 
 ###############################################################################
 
-Project: "crashcon"=..\crashcon\src\crashcon.dsp - Package Owner=<4>
+Project: "crashcon"=.\crashcon\src\crashcon.dsp - Package Owner=<4>
 
 Package=<5>
 {{{
diff -urN CrashRpt-orig\crashcon\src\crashcon.cpp CrashRpt\crashcon\src\crashcon.cpp
--- CrashRpt-orig\crashcon\src\crashcon.cpp	Sat Mar 08 09:27:58 2003
+++ CrashRpt\crashcon\src\crashcon.cpp	Thu Apr 10 11:40:46 2003
@@ -12,13 +12,13 @@
 
 int main(int argc, char* argv[])
 {
-   LPVOID lpvState = Install(NULL, NULL, NULL);
+   LPVOID lpvState = InstallEx(NULL, NULL, NULL);
 #ifdef _DEBUG
    printf("Press a ENTER to simulate a null pointer exception...\n");
    getchar();
    __try {
       RaiseException(EXCEPTION_BREAKPOINT, 0, 0, NULL);
-   } __except(GenerateErrorReport(lpvState, GetExceptionInformation())){}
+   } __except(GenerateErrorReportEx(lpvState, GetExceptionInformation(), NULL)){}
 #else
    printf("Press a ENTER to generate a null pointer exception...\n");
    getchar();
Binary files CrashRpt-orig\crashrpt\bin\release\CrashRpt.dll and CrashRpt\crashrpt\bin\release\CrashRpt.dll differ
diff -urN CrashRpt-orig\crashrpt\CrashRptStyleSheet.xsl CrashRpt\crashrpt\CrashRptStyleSheet.xsl
--- CrashRpt-orig\crashrpt\CrashRptStyleSheet.xsl	Wed Dec 31 19:00:00 1969
+++ CrashRpt\crashrpt\CrashRptStyleSheet.xsl	Thu Apr 10 12:12:54 2003
@@ -0,0 +1,154 @@
+<?xml version="1.0"?>
+<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+	<xsl:output method = "html" encoding="iso-8859-1" />
+	<xsl:template match="/Exception">	
+	<html>
+		<title></title>
+		<body>
+    
+    <xsl:if test = "ExceptionRecord/@ExceptionAddress[1]">
+      <H2>Exception</H2>
+	  <TABLE BORDER="1">
+	    <TR>
+	       <TH>Exceptino Description</TH> <TH>Code</TH> <TH>Address</TH> <TH>Module</TH>
+	       <xsl:if test="ExceptionRecord/@Filename[1]">
+	         <TH>Filename</TH> <TH>Function</TH> <TH>Line</TH>
+	       </xsl:if>
+	    </TR>
+	    <TR>
+	       <TD>
+	          <xsl:value-of select = "ExceptionRecord/@ExceptionDescription[1]" />
+	        </TD>
+	       <TD>
+	          <xsl:value-of select = "ExceptionRecord/@ExceptionCode[1]" />
+	        </TD>
+	       <TD>
+	          <xsl:value-of select = "ExceptionRecord/@ExceptionAddress[1]" />
+	        </TD>
+	       <TD>
+	          <xsl:value-of select = "ExceptionRecord/@ModuleName[1]" />
+	        </TD>
+            <xsl:if test="ExceptionRecord/@Filename[1]">
+            	<td>
+            	<xsl:value-of select = "ExceptionRecord/@Filename[1]" />
+            	</td>
+            </xsl:if>
+            
+            <xsl:if test="ExceptionRecord/@FunctionName[1]">
+	            <td>
+	            <xsl:value-of select = "ExceptionRecord/@FunctionName[1]" />
+	            <xsl:if test="ExceptionRecord/@FunctionDisplacement[1]">
+	              + <xsl:value-of select = "ExceptionRecord/@FunctionDisplacement[1]" />
+	            </xsl:if>
+	            </td>
+		            <xsl:if test="ExceptionRecord/@LineNumber[1]">
+			            <td>
+			            <xsl:value-of select = "ExceptionRecord/@LineNumber[1]" />
+			            <xsl:if test="ExceptionRecord/@LineDisplacement[1]">
+			              + <xsl:value-of select = "ExceptionRecord/@LineDisplacement[1]" />
+			            </xsl:if>
+			            </td>
+		            </xsl:if>
+            </xsl:if>
+	    </TR>
+	    </TABLE>
+    </xsl:if>
+
+	<xsl:if test="ApplicationDescription">
+		<H2>Application Description</H2>
+		<pre><xsl:value-of select = "ApplicationDescription" /> </pre>
+	 </xsl:if>
+
+	<xsl:if test="CallStack">
+		<h2>Call Stack</h2>
+		<table border="1">
+		<tr> <th>#</th> <th> Return Address </th> <th>Module</th> <th>File</th> <th> Function </th> <th> Line </th> </tr>
+		   <xsl:for-each select="CallStack/Frame">
+		     <xsl:sort data-type="number" select="@FrameNumber[1]"/>
+		         <tr>
+		            <td>
+		            <xsl:value-of select = "@FrameNumber[1]" />
+		            </td>
+		            <td>
+		            <xsl:value-of select = "@ReturnAddress[1]" />
+		            </td>
+		            <xsl:if test="@ModuleName[1]">
+		            	<td>
+		            	<xsl:value-of select = "@ModuleName[1]" />
+		            	</td>
+		            </xsl:if>
+		            <xsl:if test="not(@ModuleName[1])">
+		            	<td>
+		            	-
+		            	</td>
+		            </xsl:if>
+		            <xsl:if test="@Filename[1]">
+		            	<td>
+		            	<xsl:value-of select = "@Filename[1]" />
+		            	</td>
+		            </xsl:if>
+		            <xsl:if test="not(@Filename[1])">
+		            	<td>
+		            	-
+		            	</td>
+		            </xsl:if>
+		            
+		            <xsl:if test="@FunctionName[1]">
+			            <td>
+			            <xsl:value-of select = "@FunctionName[1]" />
+			            <xsl:if test="@FunctionDisplacement[1]">
+			              + <xsl:value-of select = "@FunctionDisplacement[1]" />
+			            </xsl:if>
+			            </td>
+				            <xsl:if test="@LineNumber[1]">
+					            <td>
+					            <xsl:value-of select = "@LineNumber[1]" />
+					            <xsl:if test="@LineDisplacement[1]">
+					              + <xsl:value-of select = "@LineDisplacement[1]" />
+					            </xsl:if>
+					            </td>
+				            </xsl:if>
+		            </xsl:if>
+				</tr>
+		   </xsl:for-each>
+		</table>
+	</xsl:if>
+
+
+	<xsl:if test="Modules/Module">
+	<h2>Loaded Modules</h2>
+	<table border="1">
+	<tr> <th>Full Path</th> <th> Product Version </th> <th> File Version </th> <th>Timestamp</th> <th>Base Addr</th> <th>Size</th>  </tr>
+	   <xsl:for-each select="Modules/Module">
+	     <xsl:sort data-type="text" select="@FullPath[1]"/>
+	         <tr>
+	            <td>
+	            <xsl:value-of select = "@FullPath[1]" />
+	            </td>
+	            <td>
+	            <xsl:value-of select = "@ProductVersion[1]" />
+	            </td>
+	            <td>
+	            <xsl:if test="@ProductVersion[1] != @FileVersion[1]">
+	            <xsl:value-of select = "@FileVersion[1]" />
+	            </xsl:if>
+	            </td>
+	            <td>
+	            <xsl:value-of select = "@TimeStamp[1]" />
+	            </td>
+	            <td>
+	            <xsl:value-of select = "@BaseAddress[1]" />
+	            </td>
+	            <td>
+	            <xsl:value-of select = "@Size[1]" />
+	            </td>
+			</tr>
+	   </xsl:for-each>
+	</table>
+	</xsl:if>
+
+			</body>
+		</html>
+	</xsl:template>
+</xsl:stylesheet>
+
diff -urN CrashRpt-orig\crashrpt\include\CrashRpt.h CrashRpt\crashrpt\include\CrashRpt.h
--- CrashRpt-orig\crashrpt\include\CrashRpt.h	Wed Dec 31 19:00:00 1969
+++ CrashRpt\crashrpt\include\CrashRpt.h	Tue May 06 13:35:22 2003
@@ -0,0 +1,437 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Module: CrashRpt.h
+//
+//    Desc: Defines the interface for the CrashRpt.DLL.
+//
+// Copyright (c) 2003 Michael Carruth
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _CRASHRPT_H_
+#define _CRASHRPT_H_
+
+#if _MSC_VER >= 1000
+#pragma once
+#endif // _MSC_VER >= 1000
+
+#include <windows.h>
+#include <wtypes.h>     // BSTR
+
+// CrashRpt.h
+#ifdef CRASHRPTAPI
+
+// CRASHRPTAPI should be defined in all of the DLL's source files as
+// #define CRASHRPTAPI extern "C" __declspec(dllexport)
+
+#else
+
+// This header file is included by an EXE - export
+#define CRASHRPTAPI extern "C" __declspec(dllimport)
+
+#endif
+
+// Client crash callback
+typedef BOOL (CALLBACK *LPGETLOGFILE) (LPVOID lpvState);
+// Stack trace callback
+typedef void (*TraceCallbackFunction)(DWORD address, const char *ImageName,
+									  const char *FunctionName, DWORD functionDisp,
+									  const char *Filename, DWORD LineNumber, DWORD lineDisp,
+									  void *data);
+
+
+//-----------------------------------------------------------------------------
+// GetInstance
+//    Returns the instance (state informatin) for the current process. Will create
+//    one if required; does not install.
+//
+// Parameters
+//    none
+//
+// Return Values
+//    If the function succeeds, the return value is a pointer to the underlying
+//    crash object created.  This state information is required as the first
+//    parameter to all other crash report functions.
+//
+// Remarks
+//    none
+//
+CRASHRPTAPI 
+LPVOID 
+GetInstance();
+
+//-----------------------------------------------------------------------------
+// Install, InstallEx
+//    Initializes the library and optionally set the client crash callback and
+//    sets up the email details.
+//
+// Parameters
+//    pfn         Client crash callback
+//    lpTo        Email address to send crash report
+//    lpSubject   Subject line to be used with email
+//
+// Return Values
+//   InstallEx:
+//    If the function succeeds, the return value is a pointer to the underlying
+//    crash object created.  This state information is required as the first
+//    parameter to all other crash report functions.
+//   Install:
+//    void
+//
+// Remarks
+//    Passing NULL for lpTo will disable the email feature and cause the crash 
+//    report to be saved to disk.
+//
+CRASHRPTAPI
+void
+Install(
+   IN LPGETLOGFILE pfn OPTIONAL,                // client crash callback
+   IN LPCTSTR lpTo OPTIONAL,                    // Email:to
+   IN LPCTSTR lpSubject OPTIONAL                // Email:subject
+   );
+CRASHRPTAPI 
+LPVOID 
+InstallEx(
+   IN LPGETLOGFILE pfn OPTIONAL,                // client crash callback
+   IN LPCTSTR lpTo OPTIONAL,                    // Email:to
+   IN LPCTSTR lpSubject OPTIONAL                // Email:subject
+   );
+
+//-----------------------------------------------------------------------------
+// Uninstall, UninstallEx
+//    Uninstalls the unhandled exception filter set up in Install().
+//
+// Parameters
+//    lpState     State information returned from Install()
+//
+// Return Values
+//    void
+//
+// Remarks
+//    This call is optional.  The crash report library will automatically 
+//    deinitialize when the library is unloaded.  Call this function to
+//    unhook the exception filter manually.
+//
+CRASHRPTAPI void Uninstall();
+CRASHRPTAPI 
+void 
+UninstallEx(
+   IN LPVOID lpState                            // State from Install()
+   );
+
+//-----------------------------------------------------------------------------
+// AddFile, AddFileEx
+//    Adds a file to the crash report.
+//
+// Parameters
+//    lpState     State information returned from Install()
+//    lpFile      Fully qualified file name
+//    lpDesc      Description of file, used by details dialog
+//
+// Return Values
+//    void
+//
+// Remarks
+//    This function can be called anytime after Install() to add one or more
+//    files to the generated crash report. If lpFile and lpDesc exactly match
+//    a previously added pair, it is not added again.
+//
+CRASHRPTAPI
+void
+AddFile(
+   IN LPCTSTR lpFile,                           // File name
+   IN LPCTSTR lpDesc                            // File desc
+   );
+CRASHRPTAPI 
+void 
+AddFileEx(
+   IN LPVOID lpState,                           // State from Install()
+   IN LPCTSTR lpFile,                           // File name
+   IN LPCTSTR lpDesc                            // File desc
+   );
+
+//-----------------------------------------------------------------------------
+// RemoveFile
+//    Removes a file from the crash report.
+//
+// Parameters
+//    lpState     State information returned from Install()
+//    lpFile      Fully qualified file name
+//
+// Return Values
+//    void
+//
+// Remarks
+//    The filename must exactly match that provided to AddFile.
+//
+CRASHRPTAPI
+void
+RemoveFile(
+   IN LPCTSTR lpFile                            // File name
+   );
+CRASHRPTAPI 
+void 
+RemoveFileEx(
+   IN LPVOID lpState,                           // State from Install()
+   IN LPCTSTR lpFile                            // File name
+   );
+
+//-----------------------------------------------------------------------------
+// AddRegistryHive
+//    Adds a RegistryHive to the crash report.
+//
+// Parameters
+//    lpState     State information returned from Install()
+//    lpRegistryHive      Fully qualified RegistryHive name
+//    lpDesc      Description of RegistryHive, used by details dialog
+//
+// Return Values
+//    void
+//
+// Remarks
+//    This function can be called anytime after Install() to add one or more
+//    RegistryHives to the generated crash report. If lpRegistryHive and lpDesc exactly match
+//    a previously added pair, it is not added again.
+//
+CRASHRPTAPI
+void
+AddRegistryHive(
+   IN LPCTSTR lpRegistryHive,                   // RegistryHive name
+   IN LPCTSTR lpDesc                            // RegistryHive desc
+   );
+CRASHRPTAPI 
+void 
+AddRegistryHiveEx(
+   IN LPVOID lpState,                           // State from Install()
+   IN LPCTSTR lpRegistryHive,                   // RegistryHive name
+   IN LPCTSTR lpDesc                            // RegistryHive desc
+   );
+
+//-----------------------------------------------------------------------------
+// RemoveRegistryHive
+//    Removes a RegistryHive from the crash report.
+//
+// Parameters
+//    lpState     State information returned from Install()
+//    lpRegistryHive      Fully qualified RegistryHive name
+//
+// Return Values
+//    void
+//
+// Remarks
+//    The RegistryHive name must exactly match that provided to AddRegistryHive.
+//
+CRASHRPTAPI
+void 
+RemoveRegistryHive(
+   IN LPCTSTR lpRegistryHive                    // RegistryHive name
+   );
+CRASHRPTAPI 
+void 
+RemoveRegistryHiveEx(
+   IN LPVOID lpState,                           // State from Install()
+   IN LPCTSTR lpRegistryHive                    // RegistryHive name
+   );
+
+//-----------------------------------------------------------------------------
+// AddEventLog
+//    Adds an event log to the crash report.
+//
+// Parameters
+//    lpState     State information returned from Install()
+//    lpEventLog  Event log name ("Application", "Security", "System" or any other known to your system)
+//    lpDesc      Description of event log, used by details dialog
+//
+// Return Values
+//    void
+//
+// Remarks
+//    This function can be called anytime after Install() to add one or more
+//    event logs to the generated crash report. If lpEventLog and lpDesc exactly match
+//    a previously added pair, it is not added again.
+//
+CRASHRPTAPI
+void
+AddEventLog(
+   IN LPCTSTR lpEventLog,                       // Event Log name
+   IN LPCTSTR lpDesc                            // Event Log desc
+   );
+CRASHRPTAPI 
+void 
+AddEventLogEx(
+   IN LPVOID lpState,                           // State from Install()
+   IN LPCTSTR lpEventLog,                       // Event Log name
+   IN LPCTSTR lpDesc                            // Event Log desc
+   );
+
+//-----------------------------------------------------------------------------
+// RemoveEventLog
+//    Removes a EventLog from the crash report.
+//
+// Parameters
+//    lpState     State information returned from Install()
+//    lpEventLog      Fully qualified EventLog name
+//
+// Return Values
+//    void
+//
+// Remarks
+//    The EventLog name must exactly match that provided to AddEventLog.
+//
+CRASHRPTAPI
+void 
+RemoveEventLog(
+   IN LPCTSTR lpEventLog                    // EventLog name
+   );
+CRASHRPTAPI 
+void 
+RemoveEventLogEx(
+   IN LPVOID lpState,                           // State from Install()
+   IN LPCTSTR lpEventLog                    // EventLog name
+   );
+
+//-----------------------------------------------------------------------------
+// GenerateErrorReport, GenerateErrorReportEx
+//    Generates the crash report.
+//
+// Parameters
+//    lpState     State information returned from Install()
+//    pExInfo     Optional; pointer to an EXCEPTION_POINTERS structure
+//	  message     Optional; message to include in report
+//
+// Return Values
+//    void
+//
+// Remarks
+//    Call this function to manually generate a crash report.
+//    Note that only GenerateErrorReportEx can be supplied exception information.
+//    If you are using the basic interfaces and wish to supply exception information,
+//    use the call GenerateErrorReportEx, supplying GetInstance() for the state
+//    information.
+//
+CRASHRPTAPI
+void
+GenerateErrorReport(
+   IN BSTR message OPTIONAL
+   );
+CRASHRPTAPI 
+void 
+GenerateErrorReportEx(
+   IN LPVOID lpState,
+   IN PEXCEPTION_POINTERS pExInfo OPTIONAL,
+   IN BSTR message OPTIONAL
+   );
+
+//-----------------------------------------------------------------------------
+// StackTrace
+//    Creates a stack trace.
+//
+// Parameters
+//    numSkip     Number of initial stack frames to skip
+//    depth       Number of stack frames to process
+//	  pFunction   Optional; function to call for each frame
+//    pContext    Optional; stack context to trace
+//
+// Return Values
+//    void
+//
+// Remarks
+//    Call this function to manually generate a stack trace. If
+//    pFunction is not supplied, stack trace frames are output using
+//    OutputDebugString. Note that this function does not require the
+//    'lpState'; it can be called even if the crash handler is not
+//     installed.
+//
+CRASHRPTAPI
+void
+StackTrace(
+   IN int numSkip,
+   IN int depth OPTIONAL,
+   IN TraceCallbackFunction pFunction OPTIONAL,
+   IN CONTEXT * pContext OPTIONAL,
+   IN LPVOID data OPTIONAL
+   );
+
+
+//-----------------------------------------------------------------------------
+// The following functions are identical to the above save that they are callable from Visual Basic
+extern "C"
+LPVOID
+__stdcall
+InstallExVB(
+   IN LPGETLOGFILE pfn OPTIONAL,                // client crash callback
+   IN LPCTSTR lpTo OPTIONAL,                    // Email:to
+   IN LPCTSTR lpSubject OPTIONAL                // Email:subject
+   );
+
+
+extern "C"
+void
+__stdcall
+UninstallExVB(
+   IN LPVOID lpState                            // State from InstallVB()
+   );
+
+extern "C"
+void
+__stdcall
+AddFileExVB(
+   IN LPVOID lpState,                           // State from InstallVB()
+   IN LPCTSTR lpFile,                           // File name
+   IN LPCTSTR lpDesc                            // File desc
+   );
+
+extern "C"
+void
+__stdcall
+RemoveFileExVB(
+   IN LPVOID lpState,                           // State from InstallVB()
+   IN LPCTSTR lpFile                            // File name
+   );
+
+extern "C"
+void
+__stdcall
+AddRegistryHiveExVB(
+   IN LPVOID lpState,                           // State from InstallVB()
+   IN LPCTSTR lpRegistryHive,                   // RegistryHive name
+   IN LPCTSTR lpDesc                            // RegistryHive desc
+   );
+
+extern "C"
+void
+__stdcall
+RemoveRegistryHiveExVB(
+   IN LPVOID lpState,                           // State from InstallVB()
+   IN LPCTSTR lpRegistryHive                    // RegistryHive name
+   );
+
+extern "C"
+void
+__stdcall
+GenerateErrorReportExVB(
+   IN LPVOID lpState,
+   IN PEXCEPTION_POINTERS pExInfo OPTIONAL,
+   IN BSTR message OPTIONAL
+   );
+
+extern "C"
+void
+__stdcall
+StackTraceVB(
+   IN int numSkip,
+   IN int depth OPTIONAL,
+   IN TraceCallbackFunction pFunction OPTIONAL,
+   IN CONTEXT * pContext OPTIONAL,
+   IN LPVOID data OPTIONAL
+   );
+
+extern "C" void __stdcall InstallVB(IN LPGETLOGFILE pfn OPTIONAL, IN LPCTSTR lpTo OPTIONAL, IN LPCTSTR lpSubject OPTIONAL);
+extern "C" void __stdcall UninstallVB();
+extern "C" void __stdcall AddFileVB(LPCTSTR file, LPCTSTR desc);
+extern "C" void __stdcall RemoveFileVB(LPCTSTR file);
+extern "C" void __stdcall AddRegistryHiveVB(LPCTSTR RegistryHive, LPCTSTR desc);
+extern "C" void __stdcall RemoveRegistryHiveVB(LPCTSTR RegistryHive);
+extern "C" void __stdcall GenerateErrorReportVB(BSTR message);
+
+#endif
diff -urN CrashRpt-orig\crashrpt\include\CrashRptDL.h CrashRpt\crashrpt\include\CrashRptDL.h
--- CrashRpt-orig\crashrpt\include\CrashRptDL.h	Wed Dec 31 19:00:00 1969
+++ CrashRpt\crashrpt\include\CrashRptDL.h	Fri May 09 14:25:23 2003
@@ -0,0 +1,339 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Module: CrashRptDL.h
+//
+//    Desc: Defines the interface for the CrashRpt.DLL, using a dynamically
+//          loaded instance of the library. Can be used when CrashRpt.dll may
+//          not be present on the system.
+//
+//          Note that all functions except GetInstanceDL() and
+//          ReleaseInstanceDL() return an integer, which is non-zero ('true')
+//          when the real DLL function was located and called. This does not
+//          mean the actual DLL function succeeded, however.
+//
+//          Please don't get confused by the macro usage; all functions do end
+//          in DL, even though the name supplied to CRASHRPT_DECLARE does not.
+//
+// Copyright (c) 2003 Michael Carruth
+// Copyright (c) 2003 Grant McDorman
+//  This software is provided 'as-is', without any express or implied
+//  warranty.  In no event will the authors be held liable for any damages
+//  arising from the use of this software.
+//
+//  Permission is granted to anyone to use this software for any purpose,
+//  including commercial applications, and to alter it and redistribute it
+//  freely, subject to the following restrictions:
+//
+//  1. The origin of this software must not be misrepresented; you must not
+//     claim that you wrote the original software. If you use this software
+//     in a product, an acknowledgment in the product documentation would be
+//     appreciated but is not required.
+//  2. Altered source versions must be plainly marked as such, and must not be
+//     misrepresented as being the original software.
+//  3. This notice may not be removed or altered from any source distribution.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _CRASHRPT_H_
+#define _CRASHRPT_H_
+
+#if _MSC_VER >= 1000
+#pragma once
+#endif // _MSC_VER >= 1000
+
+#include <windows.h>
+#include <wtypes.h>     // BSTR
+
+// Client crash callback
+typedef BOOL (CALLBACK *LPGETLOGFILE) (LPVOID lpvState);
+// Stack trace callback
+typedef void (*TraceCallbackFunction)(DWORD address, const char *ImageName,
+									  const char *FunctionName, DWORD functionDisp,
+									  const char *Filename, DWORD LineNumber, DWORD lineDisp,
+									  void *data);
+
+// macro to create the inline forwarding function
+#define CRASHRPT_DECLARE(function, declare1, declare2, arguments) \
+ __inline int function##DL declare1 \
+ { \
+	 typedef void (*function##_t) declare2; \
+	 function##_t p##function; \
+	 p##function = (function##_t) GetProcAddress(hModule, #function); \
+	 if (p##function != NULL) { \
+		 p##function arguments; \
+		 return 1; \
+	 } \
+	 return 0; \
+ }
+
+
+
+//-----------------------------------------------------------------------------
+// GetInstanceDL
+//    Returns the instance (module handle) for the CrashRpt DLL.
+//
+// Parameters
+//    none
+//
+// Return Values
+//    If the function succeeds, the return value is a module handle for the CrashRpt
+//    shared library (CrashRpt.dll). This handle is required for all the other functions.
+//
+// Remarks
+//    none
+//
+__inline 
+HMODULE
+GetInstanceDL()
+{
+	return LoadLibrary("CrashRpt");
+}
+
+//-----------------------------------------------------------------------------
+// InstallDL
+//    Initializes the library and optionally set the client crash callback and
+//    sets up the email details.
+//
+// Parameters
+//    hModule     State information returned from GetInstanceDL() (must not be NULL)
+//    pfn         Client crash callback
+//    lpTo        Email address to send crash report
+//    lpSubject   Subject line to be used with email
+//
+// Return Values
+//    non-zero if successful
+//
+// Remarks
+//    Passing NULL for lpTo will disable the email feature and cause the crash 
+//    report to be saved to disk.
+//
+CRASHRPT_DECLARE(Install, (IN HMODULE hModule, IN LPGETLOGFILE pfn, IN LPCTSTR lpTo OPTIONAL, IN LPCTSTR lpSubject OPTIONAL),  \
+                            (LPGETLOGFILE pfn, LPCTSTR lpTo, LPCTSTR lpSubject),  \
+                            (pfn, lpTo, lpSubject))
+
+//-----------------------------------------------------------------------------
+// UninstallDL
+//    Uninstalls the unhandled exception filter set up in InstallDL().
+//
+// Parameters
+//    hModule     Module handle returned from GetInstanceDL()
+//
+// Return Values
+//    non-zero if successful
+//
+// Remarks
+//    This call is optional.  The crash report library will automatically 
+//    deinitialize when the library is unloaded.  Call this function to
+//    unhook the exception filter manually.
+//
+CRASHRPT_DECLARE(Uninstall, (IN HMODULE hModule),  \
+                            (), \
+							())
+//-----------------------------------------------------------------------------
+// ReleaseInstanceDL
+//    Releases the library.
+//
+// Parameters
+//    hModule     Module handle returned from GetInstanceDL()
+//
+// Return Values
+//    void
+//
+// Remarks
+//    This will call UninstallDL before releasing the library.
+//
+__inline 
+void
+ReleaseInstanceDL(IN HMODULE hModule)
+{
+	UninstallDL(hModule);
+	FreeLibrary(hModule);
+}
+
+//-----------------------------------------------------------------------------
+// AddFileDL
+//    Adds a file to the crash report.
+//
+// Parameters
+//    hModule     Module handle returned from GetInstanceDL()
+//    lpFile      Fully qualified file name
+//    lpDesc      Description of file, used by details dialog
+//
+// Return Values
+//    non-zero if successful
+//
+// Remarks
+//    This function can be called anytime after Install() to add one or more
+//    files to the generated crash report. If lpFile exactly matches
+//    a previously added file, it is not added again.
+//
+CRASHRPT_DECLARE(AddFile, (IN HMODULE hModule, IN LPCTSTR lpFile, IN LPCTSTR lpDesc),  \
+                            (LPCTSTR lpFile, LPCTSTR lpDesc),  \
+                            (lpFile, lpDesc))
+
+//-----------------------------------------------------------------------------
+// RemoveFileDL
+//    Removes a file from the crash report.
+//
+// Parameters
+//    hModule     Module handle returned from GetInstanceDL()
+//    lpFile      Fully qualified file name
+//
+// Return Values
+//    non-zero if successful
+//
+// Remarks
+//    The filename must exactly match that provided to AddFile.
+//
+CRASHRPT_DECLARE(RemoveFile, (IN HMODULE hModule, IN LPCTSTR lpFile),  \
+                            (LPCTSTR lpFile),  \
+                            (lpFile))
+
+//-----------------------------------------------------------------------------
+// AddRegistryHiveDL
+//    Adds a RegistryHive to the crash report.
+//
+// Parameters
+//    hModule     Module handle returned from GetInstanceDL()
+//    lpRegistryHive      Fully qualified RegistryHive name
+//    lpDesc      Description of RegistryHive, used by details dialog
+//
+// Return Values
+//    non-zero if successful
+//
+// Remarks
+//    This function can be called anytime after Install() to add one or more
+//    RegistryHives to the generated crash report. If lpRegistryHive exactly matches
+//    a previously added file, it is not added again.
+//
+CRASHRPT_DECLARE(AddRegistryHive, (IN HMODULE hModule, IN LPCTSTR lpRegistryHive, IN LPCTSTR lpDesc),  \
+                            (LPCTSTR lpRegistryHive, LPCTSTR lpDesc),  \
+                            (lpRegistryHive, lpDesc))
+
+//-----------------------------------------------------------------------------
+// RemoveRegistryHiveDL
+//    Removes a RegistryHive from the crash report.
+//
+// Parameters
+//    hModule     Module handle returned from GetInstanceDL()
+//    lpRegistryHive      Fully qualified RegistryHive name
+//
+// Return Values
+//    non-zero if successful
+//
+// Remarks
+//    The RegistryHive name must exactly match that provided to AddRegistryHive.
+//
+CRASHRPT_DECLARE(RemoveRegistryHive, (IN HMODULE hModule, IN LPCTSTR lpRegistryHive),  \
+                            (LPCTSTR lpRegistryHive),  \
+                            (lpRegistryHive))
+
+//-----------------------------------------------------------------------------
+// AddEventLogDL
+//    Adds an event log to the crash report.
+//
+// Parameters
+//    hModule     Module handle returned from GetInstanceDL()
+//    lpEventLog  Event log name ("Application", "Security", "System" or any other known to your system)
+//    lpDesc      Description of event log, used by details dialog
+//
+// Return Values
+//    non-zero if successful
+//
+// Remarks
+//    This function can be called anytime after Install() to add one or more
+//    event logs to the generated crash report. If lpEventLog exactly matches
+//    a previously added file, it is not added again.
+//
+CRASHRPT_DECLARE(AddEventLog, (IN HMODULE hModule, IN LPCTSTR lpEventLog, IN LPCTSTR lpDesc),  \
+                            (LPCTSTR lpEventLog, LPCTSTR lpDesc),  \
+                            (lpEventLog, lpDesc))
+
+//-----------------------------------------------------------------------------
+// RemoveEventLogDL
+//    Removes a EventLog from the crash report.
+//
+// Parameters
+//    hModule     Module handle returned from GetInstanceDL()
+//    lpEventLog      Fully qualified EventLog name
+//
+// Return Values
+//    non-zero if successful
+//
+// Remarks
+//    The EventLog name must exactly match that provided to AddEventLog.
+//
+CRASHRPT_DECLARE(RemoveEventLog, (IN HMODULE hModule, IN LPCTSTR lpEventLog),  \
+                            (LPCTSTR lpEventLog),  \
+                            (lpEventLog))
+
+//-----------------------------------------------------------------------------
+// GenerateErrorReportDL
+//    Generates the crash report.
+//
+// Parameters
+//    hModule     Module handle returned from GetInstanceDL()
+//    pExInfo     Optional; exception information
+//	  message     Optional; message to include in report
+//
+// Return Values
+//    non-zero if successful
+//
+// Remarks
+//    Call this function to manually generate a crash report.
+//
+__inline
+int
+GenerateErrorReportDL(
+   IN HMODULE hModule,
+   IN PEXCEPTION_POINTERS pExInfo OPTIONAL,
+   IN BSTR message OPTIONAL
+   )
+{
+	// we can't use GenerateErrorReport(), because that is lacking the PEXCEPTION_POINTERS parameter
+	LPVOID instance;
+    typedef LPVOID (*GetInstance_t) ();
+    GetInstance_t pGetInstance;
+    pGetInstance = (GetInstance_t) GetProcAddress(hModule, "GetInstance");
+    if (pGetInstance != NULL) {
+		typedef void (*GenerateErrorReportEx_t)(LPVOID lpState, PEXCEPTION_POINTERS pExInfo, BSTR message);
+		GenerateErrorReportEx_t pGenerateErrorReportEx;
+
+		instance = pGetInstance();
+		pGenerateErrorReportEx = (GenerateErrorReportEx_t) GetProcAddress(hModule, "GenerateErrorReportEx");
+		if (pGenerateErrorReportEx != NULL) {
+			pGenerateErrorReportEx(instance, pExInfo, message);
+			return 1;
+		}
+    }
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// StackTraceDL
+//    Creates a stack trace.
+//
+// Parameters
+//    hModule     Module handle returned from GetInstanceDL()
+//    numSkip     Number of initial stack frames to skip
+//    depth       Number of stack frames to process
+//	  pFunction   Optional; function to call for each frame
+//    pContext    Optional; stack context to trace
+//
+// Return Values
+//    void
+//
+// Remarks
+//    Call this function to manually generate a stack trace. If
+//    pFunction is not supplied, stack trace frames are output using
+//    OutputDebugString. Can be called without installing (InstallDL)
+//    CrashRpt.
+//
+CRASHRPT_DECLARE(StackTrace, (IN HMODULE hModule, IN int numSkip, IN int depth, IN TraceCallbackFunction pFunction OPTIONAL, IN CONTEXT * pContext OPTIONAL, IN LPVOID data OPTIONAL),  \
+                            (int numSkip, int depth, TraceCallbackFunction pFunction, CONTEXT * pContext, LPVOID data),  \
+                            (numSkip, depth, pFunction, pContext, data))
+
+#undef CRASHRPT_DECLARE
+
+#endif
Binary files CrashRpt-orig\crashrpt\lib\CrashRpt.exp and CrashRpt\crashrpt\lib\CrashRpt.exp differ
Binary files CrashRpt-orig\crashrpt\lib\CrashRpt.lib and CrashRpt\crashrpt\lib\CrashRpt.lib differ
diff -urN CrashRpt-orig\crashrpt\src\aboutdlg.h CrashRpt\crashrpt\src\aboutdlg.h
--- CrashRpt-orig\crashrpt\src\aboutdlg.h	Thu Mar 13 11:46:40 2003
+++ CrashRpt\crashrpt\src\aboutdlg.h	Thu Apr 10 11:54:18 2003
@@ -65,7 +65,7 @@
       return TRUE;
 	}
 
-	LRESULT OnEmailClick(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	LRESULT OnEmailClick(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
 	{
       CMailMsg msg;
       msg
@@ -76,7 +76,7 @@
       return 0;
    }
 
-   LRESULT OnLicenseClick(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+   LRESULT OnLicenseClick(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
 	{
       HRSRC hrsrc = NULL;
       HGLOBAL hgres = NULL;
diff -urN CrashRpt-orig\crashrpt\src\chglog.txt CrashRpt\crashrpt\src\chglog.txt
--- CrashRpt-orig\crashrpt\src\chglog.txt	Wed Mar 12 14:39:28 2003
+++ CrashRpt\crashrpt\src\chglog.txt	Fri May 09 14:40:40 2003
@@ -1,3 +1,64 @@
+04/08/2003 Grant McDorman
+  Version ID: 3.0.2.3
+  Major Changes:
+    * A new header file, CrashRptDL.h, is available. It declares all the
+      functions with a 'DL' suffix, plus GetInstanceDL() and ReleaseInstanceDL().
+      All of these versions are inline functions for run-time binding to
+      CrashRpt; by using these, your application can run without CrashRpt
+      available. See the header file for more details.
+    * A 'Debug' button is available. It is normally invisible, but will
+      become visible by setting 
+        HKEY_CURRENT_USER\Software\Carruth\CrashRpt\EnableDebug
+      to a DWORD value of 1. Pressing this button will discard the
+      crash report and drop into the debugger. (On an explicit
+      GenerateErrorReport call, DebugBreak() is called).
+    * When running under a debugger, the handler will always drop into
+      the debugger after handling a crash (even if the crash is saved, mailed,
+      or the Exit button pressed). Note that this is NOT the case
+      for explicit calls to GenerateErrorReport.
+    * The dialog now includes a 'Save' button to allow the user to
+      explicitly save the crash report
+    * The 'Send' button is hidden if the handler is installed without
+      an e-mail address
+    * APIs introduced with previous release renamed with Ex suffix
+    * New API: GetInstance, returns CrashRpt instance for current
+      process
+    * APIs from January 12th release reintroduced; minor changes to
+      Install() call, however
+    * Initialize can be called multiple times; it will return
+      the same instance each time
+    * An API to get the instance for the current process was added
+    * APIs callable from Visual Basic added (suffix VB)
+    * API to add event logs to saved report (where the system supports event logs)
+    * API to add registry hives, in REGEDIT4 save format, to saved report
+    * API allowing removal of files added to report
+    * User-supplied e-mail and comments saved (as separate file) in
+      crash report if Initialize called without e-mail address
+    * Crash report XML includes stack walkback and, if possible,
+      file, function, and line number information for all addresses
+    * Dialog is in a separate thread, so crashing application freezes
+    * Application can include a message when calling GenerateErrorReport
+    * New API to generate stack trace (independant of crashes and crash
+      handling)
+    * User e-mail field now initialized with name of signed-on user
+      (no domain, unfortunately)
+  Minor Changes:
+    * Working files deleted after report mailed, saved, or cancelled
+    * XSL style sheet provided that will transform crash report XML to
+      HTML
+    * Minor internal design changes
+    * Package now includes Zlib 1.1.4 and dbghelp.dll 6.1.17.2.
+  Bugs Fixed:
+    * MAPI mailing fixed to work on Win2K with Outlook 98 and Exchange 2000 
+    * User cancelling MAPI e-mail will no longer cause CMC e-mailing to be
+      attempted
+    * Did not properly check for file existence when adding to report
+    * Did not display files properly in file list when a relative path
+      was used
+    * Did not uninstall if InstallExceptionHandler returned NULL
+    * Contents of file list grew each time GenerateErrorReport was called
+    * Under some circumstances, file types (and icons) were not properly
+    * displayed in the detail dialog
 03/13/2003
   Major Changes:
     * Replaced MFC with WTL
diff -urN CrashRpt-orig\crashrpt\src\CrashHandler.cpp CrashRpt\crashrpt\src\CrashHandler.cpp
--- CrashRpt-orig\crashrpt\src\CrashHandler.cpp	Wed Mar 12 10:13:10 2003
+++ CrashRpt\crashrpt\src\CrashHandler.cpp	Wed Apr 30 16:21:18 2003
@@ -13,133 +13,398 @@
 #include "zlibcpp.h"
 #include "excprpt.h"
 #include "maindlg.h"
-#include "process.h"
 #include "mailmsg.h"
+#include "WriteRegistry.h"
+
+#include <windows.h>
+
+#include <algorithm>
 
 // global app module
 CAppModule _Module;
 
 // maps crash objects to processes
-CSimpleMap<int, CCrashHandler*> _crashStateMap;
+CSimpleMap<DWORD, CCrashHandler*> _crashStateMap;
 
 // unhandled exception callback set with SetUnhandledExceptionFilter()
 LONG WINAPI CustomUnhandledExceptionFilter(PEXCEPTION_POINTERS pExInfo)
 {
-   _crashStateMap.Lookup(_getpid())->GenerateErrorReport(pExInfo);
+	OutputDebugString("Exception\n");
+   if (EXCEPTION_BREAKPOINT == pExInfo->ExceptionRecord->ExceptionCode)
+   {
+	   // Breakpoint. Don't treat this as a normal crash.
+	   return EXCEPTION_CONTINUE_SEARCH;
+   }
+
+   BOOL result = _crashStateMap.Lookup(GetCurrentProcessId())->GenerateErrorReport(pExInfo, NULL);
+
+   // If we're in a debugger, return EXCEPTION_CONTINUE_SEARCH to cause the debugger to stop;
+   // or if GenerateErrorReport returned FALSE (i.e. drop into debugger).
+   return (!result || IsDebuggerPresent()) ? EXCEPTION_CONTINUE_SEARCH : EXCEPTION_EXECUTE_HANDLER;
+}
 
-   return EXCEPTION_EXECUTE_HANDLER;
+CCrashHandler * CCrashHandler::GetInstance()
+{
+	CCrashHandler *instance;
+	instance = _crashStateMap.Lookup(GetCurrentProcessId());
+	if (instance == NULL) {
+		// will register
+		instance = new CCrashHandler();
+	}
+	return instance;
 }
 
-CCrashHandler::CCrashHandler(LPGETLOGFILE lpfn /*=NULL*/, 
-                             LPCTSTR lpcszTo /*=NULL*/, 
-                             LPCTSTR lpcszSubject /*=NULL*/)
+CCrashHandler::CCrashHandler():
+	m_oldFilter(NULL),
+	m_lpfnCallback(NULL),
+	m_pid(GetCurrentProcessId()),
+	m_sTo(_T("")),
+	m_sSubject(_T("")),
+	m_ipc_event(NULL),
+	m_rpt(NULL),
+	m_installed(false),
+	m_hModule(NULL)
 {
    // wtl initialization stuff...
 	HRESULT hRes = ::CoInitialize(NULL);
 	ATLASSERT(SUCCEEDED(hRes));
 
-   hRes = _Module.Init(NULL, GetModuleHandle("CrashRpt.dll"));
-   ATLASSERT(SUCCEEDED(hRes));
-
-	::DefWindowProc(NULL, 0, 0, 0L);
-
-   // initialize member data
-   m_lpfnCallback = NULL;
-   m_oldFilter    = NULL;
+   _crashStateMap.Add(m_pid, this);
+}
 
+void CCrashHandler::Install(LPGETLOGFILE lpfn, LPCTSTR lpcszTo, LPCTSTR lpcszSubject)
+{
+	OutputDebugString("::Install\n");
+	if (m_installed) {
+		Uninstall();
+	}
    // save user supplied callback
-   if (lpfn)
-      m_lpfnCallback = lpfn;
+   m_lpfnCallback = lpfn;
+   // save optional email info
+   m_sTo = lpcszTo;
+   m_sSubject = lpcszSubject;
+
 
    // add this filter in the exception callback chain
    m_oldFilter = SetUnhandledExceptionFilter(CustomUnhandledExceptionFilter);
+/*m_oldErrorMode=*/ SetErrorMode( SEM_FAILCRITICALERRORS );
 
-   // attach this handler with this process
-   m_pid = _getpid();
-   _crashStateMap.Add(m_pid, this);
+   m_installed = true;
+}
 
-   // save optional email info
-   m_sTo = lpcszTo;
-   m_sSubject = lpcszSubject;
+void CCrashHandler::Uninstall()
+{
+	OutputDebugString("Uninstall\n");
+   // reset exception callback (to previous filter, which can be NULL)
+   SetUnhandledExceptionFilter(m_oldFilter);
+   m_installed = false;
 }
 
 CCrashHandler::~CCrashHandler()
 {
-   // reset exception callback
-   if (m_oldFilter)
-      SetUnhandledExceptionFilter(m_oldFilter);
+
+	Uninstall();
 
    _crashStateMap.Remove(m_pid);
 
-   // uninitialize
-   _Module.Term();
 	::CoUninitialize();
 
 }
 
 void CCrashHandler::AddFile(LPCTSTR lpFile, LPCTSTR lpDesc)
 {
-   // make sure the file exist
+   // make sure we don't already have the file
+   RemoveFile(lpFile);
+   // make sure the file exists
    HANDLE hFile = ::CreateFile(
-                     lpFile,
-                     GENERIC_READ,
-                     FILE_SHARE_READ | FILE_SHARE_WRITE,
-                     NULL,
-                     OPEN_EXISTING,
-                     FILE_ATTRIBUTE_NORMAL,
-                     0);
-   if (hFile)
+					 lpFile,
+					 GENERIC_READ,
+					 FILE_SHARE_READ | FILE_SHARE_WRITE,
+					 NULL,
+					 OPEN_EXISTING,
+					 FILE_ATTRIBUTE_NORMAL,
+					 0);
+   if (hFile != INVALID_HANDLE_VALUE)
    {
-      // add file to report
-      m_files[lpFile] = lpDesc;
-      ::CloseHandle(hFile);
+	  // add file to report
+	  m_files.push_back(TStrStrPair(lpFile, lpDesc));
+	  ::CloseHandle(hFile);
    }
 }
 
-void CCrashHandler::GenerateErrorReport(PEXCEPTION_POINTERS pExInfo)
+void CCrashHandler::RemoveFile(LPCTSTR lpFile)
+{
+	TStrStrVector::iterator iter;
+	for (iter = m_files.begin(); iter != m_files.end(); ++iter) {
+		if ((*iter).first == lpFile) {
+			iter = m_files.erase(iter);
+		}
+	}
+}
+
+void CCrashHandler::AddRegistryHive(LPCTSTR lpRegistryHive, LPCTSTR lpDesc)
+{
+   // make sure we don't already have the RegistryHive
+   RemoveRegistryHive(lpRegistryHive);
+   // Unfortunately, we have no easy way of verifying the existence of
+   // the registry hive.
+   // add RegistryHive to report
+   m_registryHives.push_back(TStrStrPair(lpRegistryHive, lpDesc));
+}
+
+void CCrashHandler::RemoveRegistryHive(LPCTSTR lpRegistryHive)
 {
-   CExceptionReport  rpt(pExInfo);
+	TStrStrVector::iterator iter;
+	for (iter = m_registryHives.begin(); iter != m_registryHives.end(); ++iter) {
+		if ((*iter).first == lpRegistryHive) {
+			iter = m_registryHives.erase(iter);
+		}
+	}
+}
+
+void CCrashHandler::AddEventLog(LPCTSTR lpEventLog, LPCTSTR lpDesc)
+{
+   // make sure we don't already have the EventLog
+   RemoveEventLog(lpEventLog);
+   // Unfortunately, we have no easy way of verifying the existence of
+   // the event log..
+   // add EventLog to report
+   m_eventLogs.push_back(TStrStrPair(lpEventLog, lpDesc));
+}
+
+void CCrashHandler::RemoveEventLog(LPCTSTR lpEventLog)
+{
+	TStrStrVector::iterator iter;
+	for (iter = m_eventLogs.begin(); iter != m_eventLogs.end(); ++iter) {
+		if ((*iter).first == lpEventLog) {
+			iter = m_eventLogs.erase(iter);
+		}
+	}
+}
+
+DWORD WINAPI CCrashHandler::DialogThreadExecute(LPVOID pParam)
+{
+   // New thread. This will display the dialog and handle the result.
+   CCrashHandler * self = reinterpret_cast<CCrashHandler *>(pParam);
    CMainDlg          mainDlg;
+   CString sTempFileName = CUtility::getTempFileName();
    CZLib             zlib;
-   CString           sTempFileName = CUtility::getTempFileName();
-   unsigned int      i;
-
-   // let client add application specific files to report
-   if (m_lpfnCallback && !m_lpfnCallback(this))
-      return;
 
-   // add crash files to report
-   m_files[rpt.getCrashFile()] = CString((LPCTSTR)IDS_CRASH_DUMP);
-   m_files[rpt.getCrashLog()] = CString((LPCTSTR)IDS_CRASH_LOG);
+   // delete existing copy, if any
+   DeleteFile(sTempFileName);
 
-   // add symbol files to report
-   for (i = 0; i < (UINT)rpt.getNumSymbolFiles(); i++)
-      m_files[(LPCTSTR)rpt.getSymbolFile(i)] = 
-      CString((LPCTSTR)IDS_SYMBOL_FILE);
- 
    // zip the report
    if (!zlib.Open(sTempFileName))
-      return;
+      return TRUE;
    
    // add report files to zip
-   TStrStrMap::iterator cur = m_files.begin();
-   for (i = 0; i < m_files.size(); i++, cur++)
+   TStrStrVector::iterator cur = self->m_files.begin();
+   for (cur = self->m_files.begin(); cur != self->m_files.end(); cur++)
       zlib.AddFile((*cur).first);
 
    zlib.Close();
 
    // display main dialog
-   mainDlg.m_pUDFiles = &m_files;
-   if (IDOK == mainDlg.DoModal())
+   // initialize WTL
+   HRESULT hRes = _Module.Init(NULL, GetModuleHandle("CrashRpt.dll"));
+   ATLASSERT(SUCCEEDED(hRes));
+
+	::DefWindowProc(NULL, 0, 0, 0L);
+
+   mainDlg.m_pUDFiles = &self->m_files;
+   mainDlg.m_sendButton = !self->m_sTo.IsEmpty();
+   int status = mainDlg.DoModal();
+   if (IDOK == status || IDC_SAVE == status)
    {
-      if (m_sTo.IsEmpty() || 
-          !MailReport(rpt, sTempFileName, mainDlg.m_sEmail, mainDlg.m_sDescription))
+      if (IDC_SAVE == status || self->m_sTo.IsEmpty() || 
+          !self->MailReport(*self->m_rpt, sTempFileName, mainDlg.m_sEmail, mainDlg.m_sDescription))
       {
-         SaveReport(rpt, sTempFileName);
+		  // write user data to file if to be supplied
+		  if (!self->m_userDataFile.IsEmpty()) {
+			   HANDLE hFile = ::CreateFile(
+								 self->m_userDataFile,
+								 GENERIC_READ | GENERIC_WRITE,
+								 FILE_SHARE_READ | FILE_SHARE_WRITE,
+								 NULL,
+								 CREATE_ALWAYS,
+								 FILE_ATTRIBUTE_NORMAL,
+								 0);
+			   if (hFile != INVALID_HANDLE_VALUE)
+			   {
+				   static const char e_mail[] = "E-mail:";
+				   static const char newline[] = "\r\n";
+				   static const char description[] = "\r\n\r\nDescription:";
+				   DWORD writtenBytes;
+				   ::WriteFile(hFile, e_mail, sizeof(e_mail) - 1, &writtenBytes, NULL);
+				   ::WriteFile(hFile, mainDlg.m_sEmail, mainDlg.m_sEmail.GetLength(), &writtenBytes, NULL);
+				   ::WriteFile(hFile, description, sizeof(description) - 1, &writtenBytes, NULL);
+				   ::WriteFile(hFile, mainDlg.m_sDescription, mainDlg.m_sDescription.GetLength(), &writtenBytes, NULL);
+				   ::WriteFile(hFile, newline, sizeof(newline) - 1, &writtenBytes, NULL);
+				   ::CloseHandle(hFile);
+				  // redo zip file to add user data
+				   // delete existing copy, if any
+				   DeleteFile(sTempFileName);
+
+				   // zip the report
+				   if (!zlib.Open(sTempFileName))
+					  return TRUE;
+   
+				   // add report files to zip
+				   TStrStrVector::iterator cur = self->m_files.begin();
+				   for (cur = self->m_files.begin(); cur != self->m_files.end(); cur++)
+					  zlib.AddFile((*cur).first);
+
+				   zlib.Close();
+			   }
+		  }
+         self->SaveReport(*self->m_rpt, sTempFileName);
       }
    }
+   // uninitialize
+   _Module.Term();
 
    DeleteFile(sTempFileName);
+
+   self->m_wantDebug = IDC_DEBUG == status;
+   // signal main thread to resume
+   ::SetEvent(self->m_ipc_event);
+   // set flag for debugger break
+
+   // exit thread
+   ::ExitThread(0);
+   // keep compiler happy.
+   return TRUE;
+}
+
+BOOL CCrashHandler::GenerateErrorReport(PEXCEPTION_POINTERS pExInfo, BSTR message)
+{
+   CExceptionReport  rpt(pExInfo, message);
+   unsigned int      i;
+   // save state of file list prior to generating report
+   TStrStrVector     save_m_files = m_files;
+	char temp[_MAX_PATH];
+
+	GetTempPath(sizeof temp, temp);
+
+
+   // let client add application specific files to report
+   if (m_lpfnCallback && !m_lpfnCallback(this))
+      return TRUE;
+
+   m_rpt = &rpt;
+
+   // if no e-mail address, add file to contain user data
+   m_userDataFile = "";
+   if (m_sTo.IsEmpty()) {
+	   m_userDataFile = temp + CString("\\") + CUtility::getAppName() + "_UserInfo.txt";
+	   HANDLE hFile = ::CreateFile(
+						 m_userDataFile,
+						 GENERIC_READ | GENERIC_WRITE,
+						 FILE_SHARE_READ | FILE_SHARE_WRITE,
+						 NULL,
+						 CREATE_ALWAYS,
+						 FILE_ATTRIBUTE_NORMAL,
+						 0);
+	   if (hFile != INVALID_HANDLE_VALUE)
+	   {
+		   static const char description[] = "Your e-mail and description will go here.";
+		   DWORD writtenBytes;
+		   ::WriteFile(hFile, description, sizeof(description)-1, &writtenBytes, NULL);
+		   ::CloseHandle(hFile);
+		   m_files.push_back(TStrStrPair(m_userDataFile, LoadResourceString(IDS_USER_DATA)));
+	   } else {
+		   m_userDataFile = "";
+	   }
+   }
+
+
+
+   // add crash files to report
+   CString crashFile = rpt.getCrashFile();
+   CString crashLog = rpt.getCrashLog();
+   m_files.push_back(TStrStrPair(crashFile, LoadResourceString(IDS_CRASH_DUMP)));
+   m_files.push_back(TStrStrPair(crashLog, LoadResourceString(IDS_CRASH_LOG)));
+
+   // Export registry hives and add to report
+   std::vector<CString> extraFiles;
+   CString file;
+   CString number;
+   TStrStrVector::iterator iter;
+   int n = 0;
+
+   for (iter = m_registryHives.begin(); iter != m_registryHives.end(); iter++) {
+	   ++n;
+	   number.Format("%d", n);
+	   file = temp + CString("\\") + CUtility::getAppName() + "_registry" + number + ".reg";
+	   ::DeleteFile(file);
+
+	   // we want to export in a readable format. Unfortunately, RegSaveKey saves in a binary
+	   // form, so let's use our own function.
+	   if (WriteRegistryTreeToFile((*iter).first, file)) {
+		   extraFiles.push_back(file);
+		   m_files.push_back(TStrStrPair(file, (*iter).second));
+	   } else {
+		   OutputDebugString("Could not write registry hive\n");
+	   }
+   }
+   //
+   // Add the specified event log(s). Note that this will not work on Win9x/WinME.
+   //
+   for (iter = m_eventLogs.begin(); iter != m_eventLogs.end(); iter++) {
+		HANDLE h;
+		h = OpenEventLog( NULL,    // use local computer
+				 (*iter).first);   // source name
+		if (h != NULL) {
+
+			file = temp + CString("\\") + CUtility::getAppName() +  "_" + (*iter).first + ".evt";
+
+			DeleteFile(file);
+
+			if (BackupEventLog(h, file)) {
+				m_files.push_back(TStrStrPair(file, (*iter).second));
+			   extraFiles.push_back(file);
+			} else {
+				OutputDebugString("could not backup log\n");
+			}
+			CloseEventLog(h);
+		} else {
+			OutputDebugString("could not open log\n");
+		}
+   }
+ 
+
+   // add symbol files to report
+   for (i = 0; i < (UINT)rpt.getNumSymbolFiles(); i++)
+      m_files.push_back(TStrStrPair((LPCTSTR)rpt.getSymbolFile(i), 
+      CString((LPCTSTR)IDS_SYMBOL_FILE)));
+ 
+   // Start a new thread to display the dialog, and then wait
+   // until it completes
+   m_ipc_event = ::CreateEvent(NULL, FALSE, FALSE, "ACrashHandlerEvent");
+   DWORD threadId;
+   ::CreateThread(NULL, 0, DialogThreadExecute,
+	   reinterpret_cast<LPVOID>(this), 0, &threadId);
+   ::WaitForSingleObject(m_ipc_event, INFINITE);
+   CloseHandle(m_ipc_event);
+
+   // clean up - delete files we created
+   ::DeleteFile(crashFile);
+   ::DeleteFile(crashLog);
+   if (!m_userDataFile.IsEmpty()) {
+	   ::DeleteFile(m_userDataFile);
+   }
+
+   std::vector<CString>::iterator file_iter;
+   for (file_iter = extraFiles.begin(); file_iter != extraFiles.end(); file_iter++) {
+	   ::DeleteFile(*file_iter);
+   }
+
+   // restore state of file list
+   m_files = save_m_files;
+
+   m_rpt = NULL;
+
+   return !m_wantDebug;
 }
 
 BOOL CCrashHandler::SaveReport(CExceptionReport&, LPCTSTR lpcszFile)
@@ -160,4 +425,18 @@
       .AddAttachment(lpcszFile, CUtility::getAppName() + _T(".zip"));
 
    return (msg.Send());
+}
+
+CString CCrashHandler::LoadResourceString(UINT id)
+{
+	static int address;
+	char buffer[512];
+	if (m_hModule == NULL) {
+		m_hModule = GetModuleHandle("CrashRpt.dll");
+	}
+	buffer[0] = '\0';
+	if (m_hModule) {
+		LoadString(m_hModule, id, buffer, sizeof buffer);
+	}
+	return buffer;
 }
diff -urN CrashRpt-orig\crashrpt\src\CrashHandler.h CrashRpt\crashrpt\src\CrashHandler.h
--- CrashRpt-orig\crashrpt\src\CrashHandler.h	Thu Mar 13 14:22:32 2003
+++ CrashRpt\crashrpt\src\CrashHandler.h	Fri Apr 11 11:43:48 2003
@@ -20,12 +20,24 @@
 #include "crashrpt.h"      // defines LPGETLOGFILE callback
 #include "excprpt.h"       // bulk of crash report generation
 
-#ifndef TStrStrMap
-#include <map>
+#ifndef TStrStrVector
+// STL generates various warnings.
+// 4100: unreferenced formal parameter
+// 4663: C++ language change: to explicitly specialize class template...
+// 4018: signed/unsigned mismatch
+// 4245: conversion from <a> to <b>: signed/unsigned mismatch
+#pragma warning(push, 3)
+#pragma warning(disable: 4100)
+#pragma warning(disable: 4663)
+#pragma warning(disable: 4018)
+#pragma warning(disable: 4245)
+#include <vector>
+#pragma warning(pop)
 #include <atlmisc.h>
 
-typedef std::map<CString,CString> TStrStrMap;
-#endif // !defined TStrStrMap
+typedef std::pair<CString,CString> TStrStrPair;
+typedef std::vector<TStrStrPair> TStrStrVector;
+#endif // !defined TStrStrVector
 
 ////////////////////////////// Class Definitions /////////////////////////////
 
@@ -37,11 +49,26 @@
 class CCrashHandler  
 {
 public:
-	
+
    //-----------------------------------------------------------------------------
-   // CCrashHandler
-   //    Initializes the library and optionally set the client crash callback and
-   //    sets up the email details.
+   // GetInstance (static)
+   //    Returns the instance for the current process. Creates one if necessary.
+   //
+   // Parameters
+   //    none
+   //
+   // Return Values
+   //    none
+   //
+   // Remarks
+   //    none
+   //
+   static CCrashHandler * GetInstance();
+
+
+   //-----------------------------------------------------------------------------
+   // Install
+   //    Installs the crash handler..
    //
    // Parameters
    //    lpfn        Client crash callback
@@ -55,13 +82,28 @@
    //    Passing NULL for lpTo will disable the email feature and cause the crash 
    //    report to be saved to disk.
    //
-   CCrashHandler(
+   void Install(
       LPGETLOGFILE lpfn = NULL,           // Client crash callback
       LPCTSTR lpcszTo = NULL,             // EMail:To
       LPCTSTR lpcszSubject = NULL         // EMail:Subject
       );
 
    //-----------------------------------------------------------------------------
+   // Unnstall
+   //    Removes the crash handler..
+   //
+   // Parameters
+   //    none
+   //
+   // Return Values
+   //    none
+   //
+   // Remarks
+   //    none
+   //
+   void Uninstall();
+
+   //-----------------------------------------------------------------------------
    // ~CCrashHandler
    //    Uninitializes the crashrpt library.
    //
@@ -90,7 +132,7 @@
    //
    // Remarks
    //    Call this function to include application specific file(s) in the crash
-   //    report.  For example, applicatoin logs, initialization files, etc.
+   //    report.  For example, application logs, initialization files, etc.
    //
    void 
    AddFile(
@@ -99,6 +141,102 @@
       );
 
    //-----------------------------------------------------------------------------
+   // RemoveFile
+   //    Removes a file from the crash report.
+   //
+   // Parameters
+   //    lpFile      Fully qualified file name
+   //
+   // Return Values
+   //    none
+   //
+   // Remarks
+   //    lpFile must exactly match that passed to AddFile.
+   //
+   void 
+   RemoveFile(
+      LPCTSTR lpFile                      // File nae
+      );
+
+   //-----------------------------------------------------------------------------
+   // AddRegistryHive
+   //    Adds a registry hive to the crash report.
+   //
+   // Parameters
+   //    lpKey       Fully registry eky
+   //    lpDesc      Description
+   //
+   // Return Values
+   //    none
+   //
+   // Remarks
+   //    Call this function to include application specific registry hive(s) in the crash
+   //    report.
+   //
+   void 
+   AddRegistryHive(
+      LPCTSTR lpKey,                      // Registry key
+      LPCTSTR lpDesc                      // description
+      );
+
+   //-----------------------------------------------------------------------------
+   // RemoveRegistryHive
+   //    Removes a registry hive from the crash report.
+   //
+   // Parameters
+   //    lpKey       Full registry key
+   //
+   // Return Values
+   //    none
+   //
+   // Remarks
+   //    lpKey must exactly match that passed to AddRegistryHive.
+   //
+   void 
+   RemoveRegistryHive(
+      LPCTSTR lpKey                       // Registry key
+      );
+
+   //-----------------------------------------------------------------------------
+   // AddEventLog
+   //    Adds an event log to the crash report.
+   //
+   // Parameters
+   //    lpKey       Event log name ("Application", "System", "Security")
+   //    lpDesc      Description
+   //
+   // Return Values
+   //    none
+   //
+   // Remarks
+   //    Call this function to include application specific registry hive(s) in the crash
+   //    report.
+   //
+   void 
+   AddEventLog(
+      LPCTSTR lpKey,                      // Event log name
+      LPCTSTR lpDesc                      // description
+      );
+
+   //-----------------------------------------------------------------------------
+   // RemoveEventLog
+   //    Removes an event log from the crash report.
+   //
+   // Parameters
+   //    lpKey       Event log name
+   //
+   // Return Values
+   //    none
+   //
+   // Remarks
+   //    lpKey must exactly match that passed to AddEventLog.
+   //
+   void 
+   RemoveEventLog(
+      LPCTSTR lpKey                       // Registry key
+      );
+
+   //-----------------------------------------------------------------------------
    // GenerateErrorReport
    //    Produces a crash report.
    //
@@ -106,19 +244,42 @@
    //    pExInfo     Pointer to an EXCEPTION_POINTERS structure
    //
    // Return Values
-   //    none
+   //    BOOL        TRUE if exception to be executed; FALSE
+   //                if to search for another handler. This
+   //                should be used to allow breaking into
+   //                the debugger, where appropriate.
    //
    // Remarks
    //    Call this function to manually generate a crash report.
    //
-   void 
+   BOOL 
    GenerateErrorReport(
-      PEXCEPTION_POINTERS pExInfo         // Exception pointers (see MSDN)
+      PEXCEPTION_POINTERS pExInfo,         // Exception pointers (see MSDN)
+	  BSTR message = NULL
       );
 
+
 protected:
 
    //-----------------------------------------------------------------------------
+   // CCrashHandler
+   //    Initializes the library and optionally set the client crash callback and
+   //    sets up the email details.
+   //
+   // Parameters
+   //    none
+   //
+   // Return Values
+   //    none
+   //
+   // Remarks
+   //    Passing NULL for lpTo will disable the email feature and cause the crash 
+   //    report to be saved to disk.
+   //
+   CCrashHandler(
+      );
+
+   //-----------------------------------------------------------------------------
    // SaveReport
    //    Presents the user with a file save dialog and saves the crash report
    //    file to disk.  This function is called if an Email:To was not provided
@@ -164,12 +325,38 @@
       LPCTSTR lpcszSubject
       );
 
+   //-----------------------------------------------------------------------------
+   // DialogThreadExecute
+   //    Displays the dialog and handles the user's reply. Executed as a separate
+   //    thread.
+   //
+   // Parameters
+   //    pParam      Standard CreateThreadParameter; set to pointer to CCrashHandler
+   //
+   // Return Values
+   //    none
+   //
+   // Remarks
+   //    Started from GenerateErrorReport via CreateThread. This ensures the caller
+   //    is stopped (and will not confuse state by dispatching messages).
+   //
+   static DWORD WINAPI CCrashHandler::DialogThreadExecute(LPVOID pParam);
+
+   CString LoadResourceString(UINT id);
    LPTOP_LEVEL_EXCEPTION_FILTER  m_oldFilter;      // previous exception filter
    LPGETLOGFILE                  m_lpfnCallback;   // client crash callback
    int                           m_pid;            // process id
-   TStrStrMap                    m_files;          // custom files to add
+   TStrStrVector                 m_files;          // custom files to add
+   TStrStrVector				 m_registryHives;  // custom registry hives to save
+   TStrStrVector				 m_eventLogs;      // custom event logs to save
    CString                       m_sTo;            // Email:To
    CString                       m_sSubject;       // Email:Subject
+   HANDLE                        m_ipc_event;      // Event for dialog thread synchronization
+   CExceptionReport             *m_rpt;            // Exception report for dialog
+   bool                          m_installed;      // True if already installed
+   HMODULE                       m_hModule;        // Module handle for loading resource strings
+   CString						 m_userDataFile;   // file to save user input when m_sTo is empty
+   bool                          m_wantDebug;      // user pushed Debug button
 };
 
 #endif	// #ifndef _CRASHHANDLER_H_
diff -urN CrashRpt-orig\crashrpt\src\CrashRpt.cpp CrashRpt\crashrpt\src\CrashRpt.cpp
--- CrashRpt-orig\crashrpt\src\CrashRpt.cpp	Wed Mar 12 10:11:50 2003
+++ CrashRpt\crashrpt\src\CrashRpt.cpp	Wed Apr 30 16:13:08 2003
@@ -12,6 +12,8 @@
 #include "CrashRpt.h"
 #include "CrashHandler.h"
 
+#include "StackTrace.h"
+
 #ifdef _DEBUG
 #define CRASH_ASSERT(pObj)          \
    if (!pObj || sizeof(*pObj) != sizeof(CCrashHandler))  \
@@ -20,15 +22,25 @@
 #define CRASH_ASSERT(pObj)
 #endif // _DEBUG
 
-CRASHRPTAPI LPVOID Install(LPGETLOGFILE pfn, LPCTSTR lpcszTo, LPCTSTR lpcszSubject)
+// New interfaces
+CRASHRPTAPI LPVOID GetInstance()
+{
+   CCrashHandler *pImpl = CCrashHandler::GetInstance();
+   CRASH_ASSERT(pImpl);
+   return pImpl;
+}
+
+CRASHRPTAPI LPVOID InstallEx(LPGETLOGFILE pfn, LPCTSTR lpcszTo, LPCTSTR lpcszSubject)
 {
-   CCrashHandler *pImpl = new CCrashHandler(pfn, lpcszTo, lpcszSubject);
+	OutputDebugString("InstallEx\n");
+   CCrashHandler *pImpl = CCrashHandler::GetInstance();
    CRASH_ASSERT(pImpl);
+   pImpl->Install(pfn, lpcszTo, lpcszSubject);
 
    return pImpl;
 }
 
-CRASHRPTAPI void Uninstall(LPVOID lpState)
+CRASHRPTAPI void UninstallEx(LPVOID lpState)
 {
    CCrashHandler *pImpl = (CCrashHandler*)lpState;
    CRASH_ASSERT(pImpl);
@@ -36,7 +48,7 @@
    delete pImpl;
 }
 
-CRASHRPTAPI void AddFile(LPVOID lpState, LPCTSTR lpFile, LPCTSTR lpDesc)
+CRASHRPTAPI void AddFileEx(LPVOID lpState, LPCTSTR lpFile, LPCTSTR lpDesc)
 {
    CCrashHandler *pImpl = (CCrashHandler*)lpState;
    CRASH_ASSERT(pImpl);
@@ -44,10 +56,208 @@
    pImpl->AddFile(lpFile, lpDesc);
 }
 
-CRASHRPTAPI void GenerateErrorReport(LPVOID lpState, PEXCEPTION_POINTERS pExInfo)
+CRASHRPTAPI void RemoveFileEx(LPVOID lpState, LPCTSTR lpFile)
+{
+   CCrashHandler *pImpl = (CCrashHandler*)lpState;
+   CRASH_ASSERT(pImpl);
+
+   pImpl->RemoveFile(lpFile);
+}
+
+CRASHRPTAPI void AddRegistryHiveEx(LPVOID lpState, LPCTSTR lpHive, LPCTSTR lpDesc)
+{
+   CCrashHandler *pImpl = (CCrashHandler*)lpState;
+   CRASH_ASSERT(pImpl);
+
+   pImpl->AddRegistryHive(lpHive, lpDesc);
+}
+
+CRASHRPTAPI void RemoveRegistryHiveEx(LPVOID lpState, LPCTSTR lpFile)
+{
+   CCrashHandler *pImpl = (CCrashHandler*)lpState;
+   CRASH_ASSERT(pImpl);
+
+   pImpl->RemoveRegistryHive(lpFile);
+}
+
+
+CRASHRPTAPI void AddEventLogEx(LPVOID lpState, LPCTSTR lpHive, LPCTSTR lpDesc)
+{
+   CCrashHandler *pImpl = (CCrashHandler*)lpState;
+   CRASH_ASSERT(pImpl);
+
+   pImpl->AddEventLog(lpHive, lpDesc);
+}
+
+CRASHRPTAPI void RemoveEventLogEx(LPVOID lpState, LPCTSTR lpFile)
+{
+   CCrashHandler *pImpl = (CCrashHandler*)lpState;
+   CRASH_ASSERT(pImpl);
+
+   pImpl->RemoveEventLog(lpFile);
+}
+
+CRASHRPTAPI void GenerateErrorReportEx(LPVOID lpState, PEXCEPTION_POINTERS pExInfo, BSTR message)
 {
    CCrashHandler *pImpl = (CCrashHandler*)lpState;
    CRASH_ASSERT(pImpl);
 
-   pImpl->GenerateErrorReport(pExInfo);
-}
\ No newline at end of file
+   if (!pImpl->GenerateErrorReport(pExInfo, message)) {
+	   DebugBreak();
+   }
+}
+
+CRASHRPTAPI void StackTrace ( int numSkip, int depth, TraceCallbackFunction pFunction, CONTEXT *pContext, void *data)
+{
+	DoStackTrace(numSkip, depth > 0 ? depth : 9999, pFunction, pContext, data);
+}
+
+// DLL Entry Points usable from Visual Basic
+//  explicit export is required to export undecorated names.
+#pragma comment(linker, "/export:InstallExVB=_InstallExVB@12")
+extern "C" LPVOID  __stdcall InstallExVB(LPGETLOGFILE pfn, LPCTSTR lpcszTo, LPCTSTR lpcszSubject)
+{
+   return InstallEx(pfn, lpcszTo, lpcszSubject);
+}
+
+#pragma comment(linker, "/export:UninstallExVB=_UninstallExVB@4")
+extern "C" void __stdcall UninstallExVB(LPVOID lpState)
+{
+   UninstallEx(lpState);
+}
+
+#pragma comment(linker, "/export:AddFileExVB=_AddFileExVB@12")
+extern "C" void __stdcall AddFileExVB(LPVOID lpState, LPCTSTR lpFile, LPCTSTR lpDesc)
+{
+   AddFileEx(lpState, lpFile, lpDesc);
+}
+
+#pragma comment(linker, "/export:RemoveFileExVB=_RemoveFileExVB@8")
+extern "C" void __stdcall RemoveFileExVB(LPVOID lpState, LPCTSTR lpFile)
+{
+   RemoveFileEx(lpState, lpFile);
+}
+
+#pragma comment(linker, "/export:AddRegistryHiveExVB=_AddRegistryHiveExVB@12")
+extern "C" void __stdcall AddRegistryHiveExVB(LPVOID lpState, LPCTSTR lpRegistryHive, LPCTSTR lpDesc)
+{
+   AddRegistryHiveEx(lpState, lpRegistryHive, lpDesc);
+}
+
+#pragma comment(linker, "/export:RemoveRegistryHiveExVB=_RemoveRegistryHiveExVB@8")
+extern "C" void __stdcall RemoveRegistryHiveExVB(LPVOID lpState, LPCTSTR lpRegistryHive)
+{
+   RemoveRegistryHiveEx(lpState, lpRegistryHive);
+}
+
+#pragma comment(linker, "/export:GenerateErrorReportExVB=_GenerateErrorReportExVB@12")
+extern "C" void __stdcall GenerateErrorReportExVB(LPVOID lpState, PEXCEPTION_POINTERS pExInfo, BSTR message)
+{
+   GenerateErrorReportEx(lpState, pExInfo, message);
+}
+
+#pragma comment(linker, "/export:StackTraceVB=_StackTraceVB@20")
+extern "C" void  __stdcall StackTraceVB(int numSkip, int depth, TraceCallbackFunction pFunction, CONTEXT *pContext, void *data)
+{
+	StackTrace(numSkip, depth, pFunction, pContext, data);
+}
+
+// Compatiblity interfaces
+CRASHRPTAPI void Install(LPGETLOGFILE pfn, LPCTSTR lpcszTo, LPCTSTR lpcszSubject)
+{
+	(void) InstallEx(pfn, lpcszTo, lpcszSubject);
+}
+
+CRASHRPTAPI void Uninstall()
+{
+	UninstallEx(CCrashHandler::GetInstance());
+}
+
+CRASHRPTAPI void AddFile(LPCTSTR lpFile, LPCTSTR lpDesc)
+{
+   AddFileEx(CCrashHandler::GetInstance(), lpFile, lpDesc);
+}
+
+CRASHRPTAPI void RemoveFile(LPCTSTR lpFile)
+{
+   RemoveFileEx(CCrashHandler::GetInstance(), lpFile);
+}
+
+CRASHRPTAPI void AddRegistryHive(LPCTSTR lpRegistryHive, LPCTSTR lpDesc)
+{
+   AddRegistryHiveEx(CCrashHandler::GetInstance(), lpRegistryHive, lpDesc);
+}
+
+CRASHRPTAPI void RemoveRegistryHive(LPCTSTR lpRegistryHive)
+{
+   RemoveRegistryHiveEx(CCrashHandler::GetInstance(), lpRegistryHive);
+}
+CRASHRPTAPI void AddEventLog(LPCTSTR lpEventLog, LPCTSTR lpDesc)
+{
+   AddEventLogEx(CCrashHandler::GetInstance(), lpEventLog, lpDesc);
+}
+
+CRASHRPTAPI void RemoveEventLog(LPCTSTR lpEventLog)
+{
+   RemoveEventLogEx(CCrashHandler::GetInstance(), lpEventLog);
+}
+
+CRASHRPTAPI void GenerateErrorReport(BSTR message)
+{
+   GenerateErrorReportEx(CCrashHandler::GetInstance(), NULL, message);
+}
+
+#pragma comment(linker, "/export:InstallVB=_InstallVB@12")
+extern "C" void __stdcall InstallVB(LPGETLOGFILE pfn, LPCTSTR lpTo, LPCTSTR lpSubject)
+{
+	Install(pfn, lpTo, lpSubject);
+}
+
+#pragma comment(linker, "/export:UninstallVB=_UninstallVB@0")
+extern "C" void __stdcall UninstallVB()
+{
+	Uninstall();
+}
+
+#pragma comment(linker, "/export:AddFileVB=_AddFileVB@8")
+extern "C" void __stdcall AddFileVB(LPCTSTR lpFile, LPCTSTR lpDesc)
+{
+	AddFile(lpFile, lpDesc);
+}
+
+#pragma comment(linker, "/export:RemoveFileVB=_RemoveFileVB@4")
+extern "C" void __stdcall RemoveFileVB(LPCTSTR lpFile)
+{
+	RemoveFile(lpFile);
+}
+
+#pragma comment(linker, "/export:AddRegistryHiveVB=_AddRegistryHiveVB@8")
+extern "C" void __stdcall AddRegistryHiveVB(LPCTSTR lpRegistryHive, LPCTSTR lpDesc)
+{
+	AddRegistryHive(lpRegistryHive, lpDesc);
+}
+
+#pragma comment(linker, "/export:RemoveRegistryHiveVB=_RemoveRegistryHiveVB@4")
+extern "C" void __stdcall RemoveRegistryHiveVB(LPCTSTR lpRegistryHive)
+{
+	RemoveRegistryHive(lpRegistryHive);
+}
+
+#pragma comment(linker, "/export:AddEventLogVB=_AddEventLogVB@8")
+extern "C" void __stdcall AddEventLogVB(LPCTSTR lpEventLog, LPCTSTR lpDesc)
+{
+	AddEventLog(lpEventLog, lpDesc);
+}
+
+#pragma comment(linker, "/export:RemoveEventLogVB=_RemoveEventLogVB@4")
+extern "C" void __stdcall RemoveEventLogVB(LPCTSTR lpEventLog)
+{
+	RemoveEventLog(lpEventLog);
+}
+
+#pragma comment(linker, "/export:GenerateErrorReportVB=_GenerateErrorReportVB@4")
+extern "C" void __stdcall GenerateErrorReportVB(BSTR message)
+{
+	GenerateErrorReport(message);
+}
+
diff -urN CrashRpt-orig\crashrpt\src\CrashRpt.dsp CrashRpt\crashrpt\src\CrashRpt.dsp
--- CrashRpt-orig\crashrpt\src\CrashRpt.dsp	Thu Mar 13 14:22:30 2003
+++ CrashRpt\crashrpt\src\CrashRpt.dsp	Mon Apr 21 14:33:04 2003
@@ -43,17 +43,17 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CRASHRPT_EXPORTS" /Yu"stdafx.h" /FD /c
-# ADD CPP /nologo /MT /W4 /WX /O1 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "STRICT" /Yu"stdafx.h" /FD /c
+# ADD CPP /nologo /MT /W4 /WX /Zi /O1 /I "..\..\zlib\include" /I "C:\Program Files\Microsoft Visual Studio\VC98\wtl" /I "C:\Program Files\Debugging Tools for Windows\sdk\inc\\" /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "STRICT" /Yu"stdafx.h" /FD /c
 # ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
 # ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
 # ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /i "C:\Program Files\Microsoft Visual Studio\VC98\wtl" /d "NDEBUG"
 BSC32=bscmake.exe
 # ADD BASE BSC32 /nologo
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib comdlg32.lib advapi32.lib shell32.lib dbghelp.lib /nologo /base:"0x2000000" /dll /machine:I386 /out:"../bin/release/CrashRpt.dll" /implib:"../lib/CrashRpt.lib" /opt:ref /opt:nowin98
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib comdlg32.lib advapi32.lib shell32.lib dbghelp.lib /nologo /base:"0x2000000" /dll /debug /machine:I386 /out:"../bin/release/CrashRpt.dll" /implib:"../lib/CrashRpt.lib" /libpath:"C:\Program Files\Debugging Tools for Windows\sdk\lib\i386\\" /opt:ref /opt:nowin98
 # SUBTRACT LINK32 /pdb:none
 # Begin Special Build Tool
 SOURCE="$(InputPath)"
@@ -74,17 +74,18 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CRASHRPT_EXPORTS" /Yu"stdafx.h" /FD /GZ /c
-# ADD CPP /nologo /MTd /W4 /WX /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /FR /Yu"stdafx.h" /FD /GZ /c
+# ADD CPP /nologo /MTd /W4 /Gm /GX /ZI /Od /I "..\..\zlib\include" /I "C:\Program Files\Microsoft Visual Studio\VC98\wtl" /I "C:\Program Files\Debugging Tools for Windows\sdk\inc\\" /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /FR /Yu"stdafx.h" /FD /GZ /c
+# SUBTRACT CPP /WX
 # ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
 # ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
 # ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /i "C:\Program Files\Microsoft Visual Studio\VC98\wtl" /d "_DEBUG"
 BSC32=bscmake.exe
 # ADD BASE BSC32 /nologo
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 ole32.lib oleaut32.lib kernel32.lib user32.lib gdi32.lib comdlg32.lib advapi32.lib shell32.lib dbghelp.lib mapi32.lib /nologo /base:"0x20000000" /dll /debug /machine:I386 /out:"../bin/debug/CrashRpt.dll" /implib:"../lib/CrashRpt.lib" /pdbtype:sept /opt:nowin98
+# ADD LINK32 ole32.lib oleaut32.lib kernel32.lib user32.lib gdi32.lib comdlg32.lib advapi32.lib shell32.lib dbghelp.lib mapi32.lib /nologo /base:"0x20000000" /dll /debug /machine:I386 /out:"../bin/debug/CrashRpt.dll" /implib:"../lib/CrashRpt.lib" /pdbtype:sept /libpath:"C:\Program Files\Debugging Tools for Windows\sdk\lib\i386\\" /opt:nowin98
 # SUBTRACT LINK32 /pdb:none
 # Begin Special Build Tool
 SOURCE="$(InputPath)"
@@ -122,6 +123,11 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\StackTrace.cpp
+# SUBTRACT CPP /YX /Yc /Yu
+# End Source File
+# Begin Source File
+
 SOURCE=.\StdAfx.cpp
 # ADD CPP /Yc"stdafx.h"
 # End Source File
@@ -131,6 +137,10 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\WriteRegistry.cpp
+# End Source File
+# Begin Source File
+
 SOURCE=.\zlibcpp.cpp
 # End Source File
 # End Group
@@ -175,11 +185,23 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\StackTrace.h
+# End Source File
+# Begin Source File
+
 SOURCE=.\StdAfx.h
 # End Source File
 # Begin Source File
 
+SOURCE=.\SymbolEngine.h
+# End Source File
+# Begin Source File
+
 SOURCE=.\Utility.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\WriteRegistry.h
 # End Source File
 # Begin Source File
 
diff -urN CrashRpt-orig\crashrpt\src\CrashRpt.h CrashRpt\crashrpt\src\CrashRpt.h
--- CrashRpt-orig\crashrpt\src\CrashRpt.h	Wed Mar 12 10:06:48 2003
+++ CrashRpt\crashrpt\src\CrashRpt.h	Tue May 06 13:35:22 2003
@@ -16,6 +16,7 @@
 #endif // _MSC_VER >= 1000
 
 #include <windows.h>
+#include <wtypes.h>     // BSTR
 
 // CrashRpt.h
 #ifdef CRASHRPTAPI
@@ -32,9 +33,35 @@
 
 // Client crash callback
 typedef BOOL (CALLBACK *LPGETLOGFILE) (LPVOID lpvState);
+// Stack trace callback
+typedef void (*TraceCallbackFunction)(DWORD address, const char *ImageName,
+									  const char *FunctionName, DWORD functionDisp,
+									  const char *Filename, DWORD LineNumber, DWORD lineDisp,
+									  void *data);
+
 
 //-----------------------------------------------------------------------------
-// Install
+// GetInstance
+//    Returns the instance (state informatin) for the current process. Will create
+//    one if required; does not install.
+//
+// Parameters
+//    none
+//
+// Return Values
+//    If the function succeeds, the return value is a pointer to the underlying
+//    crash object created.  This state information is required as the first
+//    parameter to all other crash report functions.
+//
+// Remarks
+//    none
+//
+CRASHRPTAPI 
+LPVOID 
+GetInstance();
+
+//-----------------------------------------------------------------------------
+// Install, InstallEx
 //    Initializes the library and optionally set the client crash callback and
 //    sets up the email details.
 //
@@ -44,24 +71,34 @@
 //    lpSubject   Subject line to be used with email
 //
 // Return Values
+//   InstallEx:
 //    If the function succeeds, the return value is a pointer to the underlying
 //    crash object created.  This state information is required as the first
 //    parameter to all other crash report functions.
+//   Install:
+//    void
 //
 // Remarks
 //    Passing NULL for lpTo will disable the email feature and cause the crash 
 //    report to be saved to disk.
 //
+CRASHRPTAPI
+void
+Install(
+   IN LPGETLOGFILE pfn OPTIONAL,                // client crash callback
+   IN LPCTSTR lpTo OPTIONAL,                    // Email:to
+   IN LPCTSTR lpSubject OPTIONAL                // Email:subject
+   );
 CRASHRPTAPI 
 LPVOID 
-Install(
+InstallEx(
    IN LPGETLOGFILE pfn OPTIONAL,                // client crash callback
    IN LPCTSTR lpTo OPTIONAL,                    // Email:to
    IN LPCTSTR lpSubject OPTIONAL                // Email:subject
    );
 
 //-----------------------------------------------------------------------------
-// Uninstall
+// Uninstall, UninstallEx
 //    Uninstalls the unhandled exception filter set up in Install().
 //
 // Parameters
@@ -75,14 +112,15 @@
 //    deinitialize when the library is unloaded.  Call this function to
 //    unhook the exception filter manually.
 //
+CRASHRPTAPI void Uninstall();
 CRASHRPTAPI 
 void 
-Uninstall(
+UninstallEx(
    IN LPVOID lpState                            // State from Install()
    );
 
 //-----------------------------------------------------------------------------
-// AddFile
+// AddFile, AddFileEx
 //    Adds a file to the crash report.
 //
 // Parameters
@@ -95,35 +133,305 @@
 //
 // Remarks
 //    This function can be called anytime after Install() to add one or more
-//    files to the generated crash report.
+//    files to the generated crash report. If lpFile and lpDesc exactly match
+//    a previously added pair, it is not added again.
 //
+CRASHRPTAPI
+void
+AddFile(
+   IN LPCTSTR lpFile,                           // File name
+   IN LPCTSTR lpDesc                            // File desc
+   );
 CRASHRPTAPI 
 void 
-AddFile(
+AddFileEx(
    IN LPVOID lpState,                           // State from Install()
    IN LPCTSTR lpFile,                           // File name
    IN LPCTSTR lpDesc                            // File desc
    );
 
 //-----------------------------------------------------------------------------
-// GenerateErrorReport
+// RemoveFile
+//    Removes a file from the crash report.
+//
+// Parameters
+//    lpState     State information returned from Install()
+//    lpFile      Fully qualified file name
+//
+// Return Values
+//    void
+//
+// Remarks
+//    The filename must exactly match that provided to AddFile.
+//
+CRASHRPTAPI
+void
+RemoveFile(
+   IN LPCTSTR lpFile                            // File name
+   );
+CRASHRPTAPI 
+void 
+RemoveFileEx(
+   IN LPVOID lpState,                           // State from Install()
+   IN LPCTSTR lpFile                            // File name
+   );
+
+//-----------------------------------------------------------------------------
+// AddRegistryHive
+//    Adds a RegistryHive to the crash report.
+//
+// Parameters
+//    lpState     State information returned from Install()
+//    lpRegistryHive      Fully qualified RegistryHive name
+//    lpDesc      Description of RegistryHive, used by details dialog
+//
+// Return Values
+//    void
+//
+// Remarks
+//    This function can be called anytime after Install() to add one or more
+//    RegistryHives to the generated crash report. If lpRegistryHive and lpDesc exactly match
+//    a previously added pair, it is not added again.
+//
+CRASHRPTAPI
+void
+AddRegistryHive(
+   IN LPCTSTR lpRegistryHive,                   // RegistryHive name
+   IN LPCTSTR lpDesc                            // RegistryHive desc
+   );
+CRASHRPTAPI 
+void 
+AddRegistryHiveEx(
+   IN LPVOID lpState,                           // State from Install()
+   IN LPCTSTR lpRegistryHive,                   // RegistryHive name
+   IN LPCTSTR lpDesc                            // RegistryHive desc
+   );
+
+//-----------------------------------------------------------------------------
+// RemoveRegistryHive
+//    Removes a RegistryHive from the crash report.
+//
+// Parameters
+//    lpState     State information returned from Install()
+//    lpRegistryHive      Fully qualified RegistryHive name
+//
+// Return Values
+//    void
+//
+// Remarks
+//    The RegistryHive name must exactly match that provided to AddRegistryHive.
+//
+CRASHRPTAPI
+void 
+RemoveRegistryHive(
+   IN LPCTSTR lpRegistryHive                    // RegistryHive name
+   );
+CRASHRPTAPI 
+void 
+RemoveRegistryHiveEx(
+   IN LPVOID lpState,                           // State from Install()
+   IN LPCTSTR lpRegistryHive                    // RegistryHive name
+   );
+
+//-----------------------------------------------------------------------------
+// AddEventLog
+//    Adds an event log to the crash report.
+//
+// Parameters
+//    lpState     State information returned from Install()
+//    lpEventLog  Event log name ("Application", "Security", "System" or any other known to your system)
+//    lpDesc      Description of event log, used by details dialog
+//
+// Return Values
+//    void
+//
+// Remarks
+//    This function can be called anytime after Install() to add one or more
+//    event logs to the generated crash report. If lpEventLog and lpDesc exactly match
+//    a previously added pair, it is not added again.
+//
+CRASHRPTAPI
+void
+AddEventLog(
+   IN LPCTSTR lpEventLog,                       // Event Log name
+   IN LPCTSTR lpDesc                            // Event Log desc
+   );
+CRASHRPTAPI 
+void 
+AddEventLogEx(
+   IN LPVOID lpState,                           // State from Install()
+   IN LPCTSTR lpEventLog,                       // Event Log name
+   IN LPCTSTR lpDesc                            // Event Log desc
+   );
+
+//-----------------------------------------------------------------------------
+// RemoveEventLog
+//    Removes a EventLog from the crash report.
+//
+// Parameters
+//    lpState     State information returned from Install()
+//    lpEventLog      Fully qualified EventLog name
+//
+// Return Values
+//    void
+//
+// Remarks
+//    The EventLog name must exactly match that provided to AddEventLog.
+//
+CRASHRPTAPI
+void 
+RemoveEventLog(
+   IN LPCTSTR lpEventLog                    // EventLog name
+   );
+CRASHRPTAPI 
+void 
+RemoveEventLogEx(
+   IN LPVOID lpState,                           // State from Install()
+   IN LPCTSTR lpEventLog                    // EventLog name
+   );
+
+//-----------------------------------------------------------------------------
+// GenerateErrorReport, GenerateErrorReportEx
 //    Generates the crash report.
 //
 // Parameters
 //    lpState     State information returned from Install()
-//    pExInfo     Pointer to an EXCEPTION_POINTERS structure
+//    pExInfo     Optional; pointer to an EXCEPTION_POINTERS structure
+//	  message     Optional; message to include in report
 //
 // Return Values
 //    void
 //
 // Remarks
 //    Call this function to manually generate a crash report.
+//    Note that only GenerateErrorReportEx can be supplied exception information.
+//    If you are using the basic interfaces and wish to supply exception information,
+//    use the call GenerateErrorReportEx, supplying GetInstance() for the state
+//    information.
 //
+CRASHRPTAPI
+void
+GenerateErrorReport(
+   IN BSTR message OPTIONAL
+   );
 CRASHRPTAPI 
 void 
-GenerateErrorReport(
+GenerateErrorReportEx(
    IN LPVOID lpState,
-   IN PEXCEPTION_POINTERS pExInfo OPTIONAL
+   IN PEXCEPTION_POINTERS pExInfo OPTIONAL,
+   IN BSTR message OPTIONAL
    );
+
+//-----------------------------------------------------------------------------
+// StackTrace
+//    Creates a stack trace.
+//
+// Parameters
+//    numSkip     Number of initial stack frames to skip
+//    depth       Number of stack frames to process
+//	  pFunction   Optional; function to call for each frame
+//    pContext    Optional; stack context to trace
+//
+// Return Values
+//    void
+//
+// Remarks
+//    Call this function to manually generate a stack trace. If
+//    pFunction is not supplied, stack trace frames are output using
+//    OutputDebugString. Note that this function does not require the
+//    'lpState'; it can be called even if the crash handler is not
+//     installed.
+//
+CRASHRPTAPI
+void
+StackTrace(
+   IN int numSkip,
+   IN int depth OPTIONAL,
+   IN TraceCallbackFunction pFunction OPTIONAL,
+   IN CONTEXT * pContext OPTIONAL,
+   IN LPVOID data OPTIONAL
+   );
+
+
+//-----------------------------------------------------------------------------
+// The following functions are identical to the above save that they are callable from Visual Basic
+extern "C"
+LPVOID
+__stdcall
+InstallExVB(
+   IN LPGETLOGFILE pfn OPTIONAL,                // client crash callback
+   IN LPCTSTR lpTo OPTIONAL,                    // Email:to
+   IN LPCTSTR lpSubject OPTIONAL                // Email:subject
+   );
+
+
+extern "C"
+void
+__stdcall
+UninstallExVB(
+   IN LPVOID lpState                            // State from InstallVB()
+   );
+
+extern "C"
+void
+__stdcall
+AddFileExVB(
+   IN LPVOID lpState,                           // State from InstallVB()
+   IN LPCTSTR lpFile,                           // File name
+   IN LPCTSTR lpDesc                            // File desc
+   );
+
+extern "C"
+void
+__stdcall
+RemoveFileExVB(
+   IN LPVOID lpState,                           // State from InstallVB()
+   IN LPCTSTR lpFile                            // File name
+   );
+
+extern "C"
+void
+__stdcall
+AddRegistryHiveExVB(
+   IN LPVOID lpState,                           // State from InstallVB()
+   IN LPCTSTR lpRegistryHive,                   // RegistryHive name
+   IN LPCTSTR lpDesc                            // RegistryHive desc
+   );
+
+extern "C"
+void
+__stdcall
+RemoveRegistryHiveExVB(
+   IN LPVOID lpState,                           // State from InstallVB()
+   IN LPCTSTR lpRegistryHive                    // RegistryHive name
+   );
+
+extern "C"
+void
+__stdcall
+GenerateErrorReportExVB(
+   IN LPVOID lpState,
+   IN PEXCEPTION_POINTERS pExInfo OPTIONAL,
+   IN BSTR message OPTIONAL
+   );
+
+extern "C"
+void
+__stdcall
+StackTraceVB(
+   IN int numSkip,
+   IN int depth OPTIONAL,
+   IN TraceCallbackFunction pFunction OPTIONAL,
+   IN CONTEXT * pContext OPTIONAL,
+   IN LPVOID data OPTIONAL
+   );
+
+extern "C" void __stdcall InstallVB(IN LPGETLOGFILE pfn OPTIONAL, IN LPCTSTR lpTo OPTIONAL, IN LPCTSTR lpSubject OPTIONAL);
+extern "C" void __stdcall UninstallVB();
+extern "C" void __stdcall AddFileVB(LPCTSTR file, LPCTSTR desc);
+extern "C" void __stdcall RemoveFileVB(LPCTSTR file);
+extern "C" void __stdcall AddRegistryHiveVB(LPCTSTR RegistryHive, LPCTSTR desc);
+extern "C" void __stdcall RemoveRegistryHiveVB(LPCTSTR RegistryHive);
+extern "C" void __stdcall GenerateErrorReportVB(BSTR message);
 
 #endif
diff -urN CrashRpt-orig\crashrpt\src\CrashRpt.rc CrashRpt\crashrpt\src\CrashRpt.rc
--- CrashRpt-orig\crashrpt\src\CrashRpt.rc	Thu Mar 13 14:17:08 2003
+++ CrashRpt\crashrpt\src\CrashRpt.rc	Tue Apr 22 10:56:34 2003
@@ -76,7 +76,7 @@
     EDITTEXT        IDC_EMAIL,20,128,230,14,ES_AUTOHSCROLL
     EDITTEXT        IDC_DESCRIPTION,20,162,230,44,ES_MULTILINE | 
                     ES_AUTOVSCROLL | ES_WANTRETURN | WS_VSCROLL
-    PUSHBUTTON      "&Send",IDOK,152,233,50,14
+    PUSHBUTTON      "&Send",IDOK,152,233,50,14,NOT WS_VISIBLE
     PUSHBUTTON      "E&xit",IDCANCEL,205,233,50,14
     CONTROL         "",IDC_HEADING_TEXT,"RICHEDIT",ES_MULTILINE | 
                     WS_DISABLED,15,6,214,20
@@ -95,12 +95,14 @@
                     IDC_STATIC,20,150,230,8
     CONTROL         "",IDC_STATIC,"Static",SS_ETCHEDHORZ,0,226,272,1
     CONTROL         "",IDC_STATIC,"Static",SS_ETCHEDHORZ,0,32,272,1
+    PUSHBUTTON      "Sa&ve",IDC_SAVE,99,233,50,14
+    PUSHBUTTON      "&Debug",IDC_DEBUG,47,233,50,14,NOT WS_VISIBLE
 END
 
 IDD_DETAILDLG DIALOGEX 0, 0, 318, 231
 STYLE WS_POPUP | WS_CAPTION | WS_SYSMENU
 CAPTION "Crash Report"
-FONT 8, "MS Sans Serif"
+FONT 8, "MS Sans Serif", 0, 0, 0x1
 BEGIN
     CONTROL         "List4",IDC_FILE_LIST,"SysListView32",LVS_REPORT | 
                     LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS | 
@@ -190,13 +192,13 @@
 //
 
 VS_VERSION_INFO VERSIONINFO
- FILEVERSION 3,0,2,2
- PRODUCTVERSION 3,0,2,2
+ FILEVERSION 3,0,2,3
+ PRODUCTVERSION 3,0,2,3
  FILEFLAGSMASK 0x3fL
 #ifdef _DEBUG
- FILEFLAGS 0x21L
+ FILEFLAGS 0x29L
 #else
- FILEFLAGS 0x20L
+ FILEFLAGS 0x28L
 #endif
  FILEOS 0x4L
  FILETYPE 0x2L
@@ -209,14 +211,14 @@
             VALUE "Comments", "\0"
             VALUE "CompanyName", "\0"
             VALUE "FileDescription", "Crash Report Module\0"
-            VALUE "FileVersion", "3.0.2.2\0"
+            VALUE "FileVersion", "3.0.2.3\0"
             VALUE "InternalName", "CrashRpt\0"
             VALUE "LegalCopyright", "Copyright 2003\0"
             VALUE "LegalTrademarks", "\0"
             VALUE "OriginalFilename", "CrashRpt.exe\0"
-            VALUE "PrivateBuild", "\0"
+            VALUE "PrivateBuild", "Cedara\0"
             VALUE "ProductName", "Crash Report Module\0"
-            VALUE "ProductVersion", "3.0.2.2\0"
+            VALUE "ProductVersion", "3.0.2.3\0"
             VALUE "SpecialBuild", "0\0"
         END
     END
@@ -348,6 +350,11 @@
     IDS_CRASH_DUMP          "Crash Dump"
     IDS_CRASH_LOG           "Crash Log"
     IDS_SYMBOL_FILE         "Symbol File"
+END
+
+STRINGTABLE DISCARDABLE 
+BEGIN
+    IDS_USER_DATA           "Your e-mail and description"
 END
 
 #endif    // English (U.S.) resources
diff -urN CrashRpt-orig\crashrpt\src\detaildlg.h CrashRpt\crashrpt\src\detaildlg.h
--- CrashRpt-orig\crashrpt\src\detaildlg.h	Thu Mar 13 10:55:46 2003
+++ CrashRpt\crashrpt\src\detaildlg.h	Thu Apr 10 16:34:12 2003
@@ -87,7 +87,7 @@
 public:
 	enum { IDD = IDD_DETAILDLG };
 
-   TStrStrMap  *m_pUDFiles;      // File <name,desc>
+   TStrStrVector  *m_pUDFiles;      // File <name,desc>
    CImageList  m_iconList;       // Shell icon list
    
 	BEGIN_MSG_MAP(CDetailDlg)
@@ -129,7 +129,7 @@
 
       CMenu sysMenu;
       sysMenu.Attach(GetSystemMenu(FALSE));
-      if (sysMenu.IsMenu())
+//      if (sysMenu.IsMenu())
       {
 		   CString strAboutMenu;
 		   strAboutMenu.LoadString(IDS_ABOUTBOX);
@@ -183,42 +183,58 @@
       //
       // Insert items
       //
-      WIN32_FIND_DATA   findFileData   = {0};
-      HANDLE            hFind          = NULL;
+	  WIN32_FILE_ATTRIBUTE_DATA infoData;
+	  char *pfn;
       CString           sSize;
       LVITEM            lvi            = {0};
-      TStrStrMap::iterator p;
+      TStrStrVector::iterator p;
+	  int status;
+	  char path[_MAX_PATH];
       for (i = 0, p = m_pUDFiles->begin(); p != m_pUDFiles->end(); p++, i++)
       {
-         SHGetFileInfo(
-            p->first,
+		 // note that the code depends on the index (iItem) being the same as
+		 // the index into m_pUDFiles, so it is not practical to ignore missing
+		 // files
+
+		 // translate supplied path to full path (SHGetFileInfo doesn't like
+		 // some path constructions, such ones with \..\ in them).
+		 GetFullPathName(p->first, sizeof path, path, &pfn);
+         status = SHGetFileInfo(
+            path,
             0,
             &sfi,
             sizeof(sfi),
             SHGFI_DISPLAYNAME | SHGFI_ICON | SHGFI_TYPENAME | SHGFI_SMALLICON);
-
-         // Name
-         lvi.mask          = LVIF_IMAGE | LVIF_TEXT;
-         lvi.iItem         = i;
-         lvi.iSubItem      = 0;
-         lvi.iImage        = sfi.iIcon;
-         lvi.pszText       = sfi.szDisplayName;
-         list.InsertItem(&lvi);
-
+		 if (status) {
+			 // Name
+			 lvi.mask          = LVIF_IMAGE | LVIF_TEXT;
+			 lvi.iItem         = i;
+			 lvi.iSubItem      = 0;
+			 lvi.iImage        = sfi.iIcon;
+			 lvi.pszText       = sfi.szDisplayName;
+			 list.InsertItem(&lvi);
+         } else {
+			 // Name
+			 lvi.mask          = LVIF_IMAGE | LVIF_TEXT;
+			 lvi.iItem         = i;
+			 lvi.iSubItem      = 0;
+			 lvi.iImage        = sfi.iIcon; /* no icon */
+			 lvi.pszText       = const_cast<char *>(static_cast<const char *>(p->first));
+			 list.InsertItem(&lvi);
+		 }
          // Description
          list.SetItemText(i, 1, p->second);
 
          // Type
-         list.SetItemText(i, 2, sfi.szTypeName);
+		 if (status) {
+            list.SetItemText(i, 2, sfi.szTypeName);
+		 }
 
          // Size
-         hFind = FindFirstFile(p->first, &findFileData);
-         if (INVALID_HANDLE_VALUE != hFind)
-         {
-	         FindClose(hFind);
-            sSize.Format(TEXT("%d KB"), findFileData.nFileSizeLow);
+		 if (GetFileAttributesEx(path, GetFileExInfoStandard, &infoData)) {
+			sSize.Format(TEXT("%d KB"), infoData.nFileSizeLow);
             list.SetItemText(i, 3, sSize);
-         }
+		 }
       }
 
       // Select first file
@@ -316,15 +332,13 @@
       if (iItem < 0 || (int)m_pUDFiles->size() < iItem)
          return 0;
 
-      TStrStrMap::iterator p = m_pUDFiles->begin();
-      for (int i = 0; i < iItem; i++, p++);
 
       dwRet = (DWORD_PTR)::ShellExecute(
-                              0, 
-                              _T("open"), 
-                              p->first,
-                              0, 
-                              0, 
+                              m_hWnd,
+                              _T("open"),
+                              m_pUDFiles->at(iItem).first,
+                              NULL,    // parameters (if a program)
+                              NULL,    // default directory
                               SW_SHOWNORMAL
                               );
       ATLASSERT(dwRet > 32);
@@ -348,20 +362,18 @@
       if (iItem < 0 || (int)m_pUDFiles->size() < iItem)
           return;
  
-      TStrStrMap::iterator p = m_pUDFiles->begin();
-      for (int i = 0; i < iItem; i++, p++);
 
       // 
       // Update preview header info
       //
-      ::SetWindowText(GetDlgItem(IDC_NAME), p->first);
-      ::SetWindowText(GetDlgItem(IDC_DESCRIPTION), p->second);
+      ::SetWindowText(GetDlgItem(IDC_NAME), m_pUDFiles->at(iItem).first);
+      ::SetWindowText(GetDlgItem(IDC_DESCRIPTION), m_pUDFiles->at(iItem).second);
 
       //
       // Display file contents in preview window
       //
       HANDLE hFile = CreateFile(
-         p->first,
+         m_pUDFiles->at(iItem).first,
          GENERIC_READ,
          FILE_SHARE_READ | FILE_SHARE_WRITE,
          NULL,
diff -urN CrashRpt-orig\crashrpt\src\excprpt.cpp CrashRpt\crashrpt\src\excprpt.cpp
--- CrashRpt-orig\crashrpt\src\excprpt.cpp	Wed Mar 12 14:34:22 2003
+++ CrashRpt\crashrpt\src\excprpt.cpp	Fri Apr 11 11:17:56 2003
@@ -13,9 +13,8 @@
 #include "excprpt.h"
 #include "utility.h"
 
-CString CExceptionReport::m_sModule = _T("");
-CString CExceptionReport::m_sException = _T("");
-CString CExceptionReport::m_sAddress = _T("");
+#include "StackTrace.h"
+
 
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
@@ -27,9 +26,13 @@
 //
 // 
 //
-CExceptionReport::CExceptionReport(PEXCEPTION_POINTERS ExceptionInfo)
+CExceptionReport::CExceptionReport(PEXCEPTION_POINTERS ExceptionInfo, BSTR message)
 {
    m_excpInfo = ExceptionInfo;
+   m_message = message;
+   TCHAR szModName[_MAX_FNAME + 1];
+   GetModuleFileName(NULL, szModName, _MAX_FNAME);
+   m_sModule = szModName;
 }
 
 
@@ -60,32 +63,45 @@
    //
    if (hFile)
    {
+      writeDumpFile(hFile, m_excpInfo, reinterpret_cast<void *>(this));
+   }
+
+   // Close file
+   CloseHandle(hFile);
+
+   return sFile;
+}
+
+
+void CExceptionReport::writeDumpFile(HANDLE hFile, PEXCEPTION_POINTERS excpInfo, void *data)
+{
+	if (excpInfo == NULL) {
+      // Generate exception to get proper context in dump
+	   __try {
+		   RaiseException(EXCEPTION_BREAKPOINT, 0, 0, NULL);
+	   } __except(writeDumpFile(hFile, GetExceptionInformation(), data), EXCEPTION_CONTINUE_EXECUTION) {
+	   }
+	} else {
       MINIDUMP_EXCEPTION_INFORMATION eInfo;
       eInfo.ThreadId = GetCurrentThreadId();
-      eInfo.ExceptionPointers = m_excpInfo;
+      eInfo.ExceptionPointers = excpInfo;
       eInfo.ClientPointers = FALSE;
 
       MINIDUMP_CALLBACK_INFORMATION cbMiniDump;
       cbMiniDump.CallbackRoutine = CExceptionReport::miniDumpCallback;
-      cbMiniDump.CallbackParam = 0;
+      cbMiniDump.CallbackParam = data;
 
       MiniDumpWriteDump(
          GetCurrentProcess(),
          GetCurrentProcessId(),
          hFile,
-         MiniDumpNormal,
-         m_excpInfo ? &eInfo : NULL,
-         NULL,
+         MiniDumpWithIndirectlyReferencedMemory,
+         excpInfo ? &eInfo : NULL,
+		 NULL,
          &cbMiniDump);
    }
-
-   // Close file
-   CloseHandle(hFile);
-
-   return sFile;
 }
 
-
 //-----------------------------------------------------------------------------
 // CExceptionReport::getCrashLog
 //
@@ -127,6 +143,17 @@
    }
 
    //
+   // Add optional message node
+   //
+   if (m_message != NULL) {
+	   node = CreateMsgNode(pDoc, m_message);
+	   CHECKHR(root->appendChild(node, &newNode));
+	   // The XML Document should now own the node.
+	   SAFERELEASE(node);
+	   SAFERELEASE(newNode);
+   }
+
+   //
    // Add processor node
    //
    node = CreateProcessorNode(pDoc);
@@ -153,6 +180,16 @@
    SAFERELEASE(node);
    SAFERELEASE(newNode);
 
+   //
+   // Add stack walkback node
+   //
+   node = CreateWalkbackNode(pDoc, m_excpInfo != NULL ? m_excpInfo->ContextRecord : NULL);
+   CHECKHR(root->appendChild(node, &newNode));
+   // The XML Document should now own the node.
+   SAFERELEASE(node);
+   SAFERELEASE(newNode);
+
+
    // Add the root to the doc
    CHECKHR(pDoc->appendChild(root, NULL));
 
@@ -225,6 +262,69 @@
 }
 
 //-----------------------------------------------------------------------------
+// CreateExceptionSymbolAttributes
+//
+// Create attributes in the exception record with the symbolic info, if available
+//
+void  CExceptionReport::CreateExceptionSymbolAttributes(DWORD /*address*/, const char * /*ImageName*/,
+									  const char *FunctionName, DWORD functionDisp,
+									  const char *Filename, DWORD LineNumber, DWORD lineDisp,
+									  void *data)
+{
+   CString sAddr;
+   BSTR funcName					= ::SysAllocString(L"FunctionName");
+   BSTR funcDispName				= ::SysAllocString(L"FunctionDisplacement");
+   BSTR fileName					= ::SysAllocString(L"Filename");
+   BSTR lineName					= ::SysAllocString(L"LineNumber");
+   BSTR lineDispName				= ::SysAllocString(L"LineDisplacement");
+   CExceptionReport	*self = reinterpret_cast<CExceptionReport *>(data);
+
+   VARIANT v;
+
+   // don't need ImageName [module], as that is already done
+   if (FunctionName != NULL) {
+		V_VT(&v) = VT_BSTR;
+		V_BSTR(&v) = CString(FunctionName).AllocSysString();
+		self->m_exception_element->setAttribute(funcName, v);
+		// Recycle variant
+		SysFreeString(V_BSTR(&v));
+		sAddr.Format(_T("0x%x"), functionDisp);
+		V_VT(&v) = VT_BSTR;
+		V_BSTR(&v) = sAddr.AllocSysString();
+		self->m_exception_element->setAttribute(funcDispName, v);
+		// Recycle variant
+		SysFreeString(V_BSTR(&v));
+   }
+
+   if (Filename != NULL) {
+		V_VT(&v) = VT_BSTR;
+		V_BSTR(&v) = CString(Filename).AllocSysString();
+		self->m_exception_element->setAttribute(fileName, v);
+		// Recycle variant
+		SysFreeString(V_BSTR(&v));
+
+		sAddr.Format(_T("%d"), LineNumber);
+		V_VT(&v) = VT_BSTR;
+		V_BSTR(&v) = sAddr.AllocSysString();
+		self->m_exception_element->setAttribute(lineName, v);
+		// Recycle variant
+		SysFreeString(V_BSTR(&v));
+
+		sAddr.Format(_T("0x%x"), lineDisp);
+		V_VT(&v) = VT_BSTR;
+		V_BSTR(&v) = sAddr.AllocSysString();
+		self->m_exception_element->setAttribute(lineDispName, v);
+		// Recycle variant
+		SysFreeString(V_BSTR(&v));
+   }
+   ::SysFreeString(funcName);
+   ::SysFreeString(funcDispName);
+   ::SysFreeString(fileName);
+   ::SysFreeString(lineName);
+   ::SysFreeString(lineDispName);
+}
+
+//-----------------------------------------------------------------------------
 // CExceptionReport::CreateExceptionRecordNode
 //
 //
@@ -252,11 +352,8 @@
    //
    // Set module name attribute
    //
-   TCHAR szModName[_MAX_FNAME + 1];
-   GetModuleFileName(NULL, szModName, _MAX_FNAME);
-   m_sModule = szModName;
    V_VT(&v)    = VT_BSTR;
-   V_BSTR(&v)  = A2BSTR(szModName);
+   V_BSTR(&v)  = A2BSTR(m_sModule);
    pElement->setAttribute(modName, v);
    // Recycle variant
    SysFreeString(V_BSTR(&v));
@@ -363,6 +460,11 @@
    // Recycle variant
    SysFreeString(V_BSTR(&v));
 
+   // Try to include symbolic information
+   m_exception_element = pElement;
+   AddressToSymbol(reinterpret_cast<DWORD>(pExceptionRecord->ExceptionAddress)-1,
+	   CreateExceptionSymbolAttributes,
+	   reinterpret_cast<void *>(this));
 CleanUp:
    ::SysFreeString(nodeName);
    ::SysFreeString(modName);
@@ -586,11 +688,13 @@
    pNode = CreateDOMNode(pDoc, MSXML::NODE_ELEMENT, nodeName);
 
    //
-   // Add module information
+   // Add module information (freeing storage as we go)
    // 
-   node = start.next;
-   while (node)
+   MINIDUMP_MODULE_CALLBACK item;
+   std::vector<MINIDUMP_MODULE_CALLBACK>::iterator iter;
+   for (iter = m_modules.begin(); iter != m_modules.end(); iter++)
    {
+	   item = *iter;
       // Create module node
       pNode2 = CreateDOMNode(pDoc, MSXML::NODE_ELEMENT, nodeName2);
 
@@ -601,7 +705,7 @@
       // Set full path
       //
       V_VT(&v) = VT_BSTR;
-      V_BSTR(&v) = W2BSTR(node->item.FullPath);
+      V_BSTR(&v) = W2BSTR(item.FullPath);
       pElement->setAttribute(fullPath, v);
       // Recycle variant
       SysFreeString(V_BSTR(&v));
@@ -609,7 +713,7 @@
       //
       // Set base address
       //
-      sAddr.Format(_T("0x%08x"), node->item.BaseOfImage);
+      sAddr.Format(_T("0x%08x"), item.BaseOfImage);
       V_VT(&v) = VT_BSTR;
       V_BSTR(&v) = sAddr.AllocSysString();
       pElement->setAttribute(baseAddrName, v);
@@ -619,7 +723,7 @@
       //
       // Set module size
       //
-      sAddr.Format(_T("0x%08x"), node->item.SizeOfImage);
+      sAddr.Format(_T("0x%08x"), item.SizeOfImage);
       V_VT(&v) = VT_BSTR;
       V_BSTR(&v) = sAddr.AllocSysString();
       pElement->setAttribute(sizeName, v);
@@ -629,7 +733,7 @@
       //
       // Set timestamp
       //
-      FILETIME    ft = CUtility::getLastWriteFileTime(node->item.FullPath);
+      FILETIME    ft = CUtility::getLastWriteFileTime(item.FullPath);
       SYSTEMTIME  st = {0};
 
       FileTimeToSystemTime(&ft, &st);
@@ -653,10 +757,10 @@
       // Set file version
       //
       sAddr.Format("%d.%d.%d.%d", 
-                   HIWORD(node->item.VersionInfo.dwFileVersionMS),
-                   LOWORD(node->item.VersionInfo.dwFileVersionMS),
-                   HIWORD(node->item.VersionInfo.dwFileVersionLS),
-                   LOWORD(node->item.VersionInfo.dwFileVersionLS));
+                   HIWORD(item.VersionInfo.dwFileVersionMS),
+                   LOWORD(item.VersionInfo.dwFileVersionMS),
+                   HIWORD(item.VersionInfo.dwFileVersionLS),
+                   LOWORD(item.VersionInfo.dwFileVersionLS));
       V_VT(&v) = VT_BSTR;
       V_BSTR(&v) = sAddr.AllocSysString();
       pElement->setAttribute(fileVerName, v);
@@ -667,10 +771,10 @@
       // Set product version
       //
       sAddr.Format("%d.%d.%d.%d", 
-                   HIWORD(node->item.VersionInfo.dwProductVersionMS),
-                   LOWORD(node->item.VersionInfo.dwProductVersionMS),
-                   HIWORD(node->item.VersionInfo.dwProductVersionLS),
-                   LOWORD(node->item.VersionInfo.dwProductVersionLS));
+                   HIWORD(item.VersionInfo.dwProductVersionMS),
+                   LOWORD(item.VersionInfo.dwProductVersionMS),
+                   HIWORD(item.VersionInfo.dwProductVersionLS),
+                   LOWORD(item.VersionInfo.dwProductVersionLS));
       V_VT(&v) = VT_BSTR;
       V_BSTR(&v) = sAddr.AllocSysString();
       pElement->setAttribute(prodVerName, v);
@@ -686,8 +790,9 @@
       SAFERELEASE(pElement2);
       SAFERELEASE(pNewNode);
 
-      node = node->next;
+	  free(item.FullPath);
    }
+   m_modules.clear();
 
 CleanUp:
 
@@ -708,6 +813,181 @@
 }
 
 //-----------------------------------------------------------------------------
+// CreateMsgNode
+//
+// Builds the application-defined message node
+//
+MSXML::IXMLDOMNode * 
+CExceptionReport::CreateMsgNode(MSXML::IXMLDOMDocument* pDoc, BSTR message)
+{
+   MSXML::IXMLDOMNode*     pNode    = NULL;
+   MSXML::IXMLDOMElement*  pElement = NULL;
+   BSTR nodeName                    = ::SysAllocString(L"ApplicationDescription");
+
+   // Create CrashDescription record node
+   pNode = CreateDOMNode(pDoc, MSXML::NODE_ELEMENT, nodeName);
+
+   // Get element interface
+   CHECKHR(pNode->QueryInterface(MSXML::IID_IXMLDOMElement, (void**)&pElement));
+
+   pElement->put_text(message);
+
+CleanUp:
+   ::SysFreeString(nodeName);
+   SAFERELEASE(pElement);
+
+   return pNode;
+}
+
+//-----------------------------------------------------------------------------
+// CreateWalkbackEntryNode
+//
+// Create a single node in the stack walback
+//
+void
+CExceptionReport::CreateWalkbackEntryNode(DWORD address, const char *ImageName,
+									  const char *FunctionName, DWORD functionDisp,
+									  const char *Filename, DWORD LineNumber, DWORD lineDisp,
+									  void *data)
+{
+   MSXML::IXMLDOMNode*     pNode    = NULL;
+   MSXML::IXMLDOMElement*  pElement = NULL;
+   MSXML::IXMLDOMNode*     pNewNode = NULL;
+   CString sAddr;
+   BSTR nodeName                    = ::SysAllocString(L"Frame");
+   BSTR frameName					= ::SysAllocString(L"FrameNumber");
+   BSTR addrName					= ::SysAllocString(L"ReturnAddress");
+   BSTR moduleName					= ::SysAllocString(L"ModuleName");
+   BSTR funcName					= ::SysAllocString(L"FunctionName");
+   BSTR funcDispName				= ::SysAllocString(L"FunctionDisplacement");
+   BSTR fileName					= ::SysAllocString(L"Filename");
+   BSTR lineName					= ::SysAllocString(L"LineNumber");
+   BSTR lineDispName				= ::SysAllocString(L"LineDisplacement");
+   CExceptionReport	*self = reinterpret_cast<CExceptionReport *>(data);
+
+   // Create frame record node
+   pNode = self->CreateDOMNode(self->m_stack_doc, MSXML::NODE_ELEMENT, nodeName);
+
+   // Get element interface
+   CHECKHR(pNode->QueryInterface(MSXML::IID_IXMLDOMElement, (void**)&pElement));
+
+
+   VARIANT v;
+
+   self->m_frameNumber++;
+   sAddr.Format(_T("%d"), self->m_frameNumber);
+   V_VT(&v) = VT_BSTR;
+   V_BSTR(&v) = sAddr.AllocSysString();
+   pElement->setAttribute(frameName, v);
+   // Recycle variant
+   SysFreeString(V_BSTR(&v));
+
+   sAddr.Format(_T("0x%x"), address);
+   V_VT(&v) = VT_BSTR;
+   V_BSTR(&v) = sAddr.AllocSysString();
+   pElement->setAttribute(addrName, v);
+   // Recycle variant
+   SysFreeString(V_BSTR(&v));
+
+   if (ImageName != NULL) {
+		V_VT(&v) = VT_BSTR;
+		V_BSTR(&v) = CString(ImageName).AllocSysString();
+		pElement->setAttribute(moduleName, v);
+		// Recycle variant
+		SysFreeString(V_BSTR(&v));
+   }
+
+   if (FunctionName != NULL) {
+		V_VT(&v) = VT_BSTR;
+		V_BSTR(&v) = CString(FunctionName).AllocSysString();
+		pElement->setAttribute(funcName, v);
+		// Recycle variant
+		SysFreeString(V_BSTR(&v));
+		sAddr.Format(_T("0x%x"), functionDisp);
+		V_VT(&v) = VT_BSTR;
+		V_BSTR(&v) = sAddr.AllocSysString();
+		pElement->setAttribute(funcDispName, v);
+		// Recycle variant
+		SysFreeString(V_BSTR(&v));
+   }
+
+   if (Filename != NULL) {
+		V_VT(&v) = VT_BSTR;
+		V_BSTR(&v) = CString(Filename).AllocSysString();
+		pElement->setAttribute(fileName, v);
+		// Recycle variant
+		SysFreeString(V_BSTR(&v));
+
+		sAddr.Format(_T("%d"), LineNumber);
+		V_VT(&v) = VT_BSTR;
+		V_BSTR(&v) = sAddr.AllocSysString();
+		pElement->setAttribute(lineName, v);
+		// Recycle variant
+		SysFreeString(V_BSTR(&v));
+
+		sAddr.Format(_T("0x%x"), lineDisp);
+		V_VT(&v) = VT_BSTR;
+		V_BSTR(&v) = sAddr.AllocSysString();
+		pElement->setAttribute(lineDispName, v);
+		// Recycle variant
+		SysFreeString(V_BSTR(&v));
+   }
+   // add to walkback element
+
+   self->m_stack_element->appendChild(pNode, &pNewNode);
+   SAFERELEASE(pNewNode);
+   // The XML Document should now own the node.
+CleanUp:
+   SAFERELEASE(pNode);
+   SAFERELEASE(pElement);
+   ::SysFreeString(nodeName);
+   ::SysFreeString(frameName);
+   ::SysFreeString(addrName);
+   ::SysFreeString(moduleName);
+   ::SysFreeString(funcName);
+   ::SysFreeString(funcDispName);
+   ::SysFreeString(fileName);
+   ::SysFreeString(lineName);
+   ::SysFreeString(lineDispName);
+}
+
+//-----------------------------------------------------------------------------
+// CreateWalkbackNode
+//
+// Builds the stack walkback list
+//
+MSXML::IXMLDOMNode * 
+CExceptionReport::CreateWalkbackNode(MSXML::IXMLDOMDocument* pDoc, CONTEXT *pContext)
+{
+   MSXML::IXMLDOMNode*     pNode    = NULL;
+
+   MSXML::IXMLDOMElement*  pElement = NULL;
+   BSTR nodeName                    = ::SysAllocString(L"CallStack");
+
+   // Create CallStack record node
+   pNode = CreateDOMNode(pDoc, MSXML::NODE_ELEMENT, nodeName);
+
+   // Get element interface
+   CHECKHR(pNode->QueryInterface(MSXML::IID_IXMLDOMElement, (void**)&pElement));
+
+   // create the trace
+   //  set static variables for use by CreateWalkbackEntryNode
+   m_stack_element = pElement;
+   m_stack_doc = pDoc;
+   m_frameNumber = 0;
+   // If no context is supplied, skip 1 frames:
+   //  1 this function
+   //  ??
+   DoStackTrace(pContext == NULL ? 1 : 0, 9999, CreateWalkbackEntryNode, pContext, this);
+
+CleanUp:
+   ::SysFreeString(nodeName);
+   SAFERELEASE(pElement);
+
+   return pNode;
+}
+
+//-----------------------------------------------------------------------------
 // CExceptionReport::miniDumpCallback
 //
 // Mini dump module callback.  Hit once for each module processed by
@@ -715,17 +995,18 @@
 // eventually used to create the <modules> node in the XML log file.
 //
 BOOL CALLBACK 
-CExceptionReport::miniDumpCallback(PVOID,
+CExceptionReport::miniDumpCallback(PVOID data,
                                    CONST PMINIDUMP_CALLBACK_INPUT CallbackInput,
                                    PMINIDUMP_CALLBACK_OUTPUT)
 {
+   CExceptionReport *self = reinterpret_cast<CExceptionReport*>(data);
    if (ModuleCallback == CallbackInput->CallbackType)
    {
-      node->next = new _ModuleListEntry;
-      node = node->next;
-      node->item = CallbackInput->Module;
-      node->item.FullPath = _wcsdup(CallbackInput->Module.FullPath);
-      node->next = NULL;
+      MINIDUMP_MODULE_CALLBACK item;
+
+      item = CallbackInput->Module;
+      item.FullPath = _wcsdup(CallbackInput->Module.FullPath);
+	  self->m_modules.push_back(item);
    }
 
    return TRUE;
diff -urN CrashRpt-orig\crashrpt\src\excprpt.h CrashRpt\crashrpt\src\excprpt.h
--- CrashRpt-orig\crashrpt\src\excprpt.h	Wed Mar 12 14:36:10 2003
+++ CrashRpt\crashrpt\src\excprpt.h	Thu Apr 10 11:54:32 2003
@@ -17,20 +17,23 @@
 
 #include <atlmisc.h>
 #include <dbghelp.h>
+// STL generates various warnings.
+// 4100: unreferenced formal parameter
+// 4663: C++ language change: to explicitly specialize class template...
+// 4018: signed/unsigned mismatch
+// 4245: conversion from <a> to <b>: signed/unsigned mismatch
+#pragma warning(push, 3)
+#pragma warning(disable: 4100)
+#pragma warning(disable: 4663)
+#pragma warning(disable: 4018)
+#pragma warning(disable: 4245)
+#include <vector>
+#pragma warning(pop)
 
 // Import MSXML interfaces
 #import "msxml.dll" named_guids raw_interfaces_only
 
 //
-// Modules linked list
-//
-static struct _ModuleListEntry
-{
-   MINIDUMP_MODULE_CALLBACK item;
-   struct _ModuleListEntry *next;
-} start, *node = &start;
-
-//
 // COM helper macros
 //
 #define CHECKHR(x) {HRESULT hr = x; if (FAILED(hr)) goto CleanUp;}
@@ -47,7 +50,7 @@
 class CExceptionReport  
 {
 public:
-	CExceptionReport(PEXCEPTION_POINTERS ExceptionInfo);
+	CExceptionReport(PEXCEPTION_POINTERS ExceptionInfo, BSTR message);
 
    CString getSymbolFile(int index);
 	int getNumSymbolFiles();
@@ -58,25 +61,52 @@
    CString getExceptionAddr() { return m_sAddress; };
 
 private:
-   static CString m_sModule;
-   static CString m_sException;
-   static CString m_sAddress;
+   CString m_sModule;
+   CString m_sException;
+   CString m_sAddress;
 
    PEXCEPTION_POINTERS m_excpInfo;
+   BSTR           m_message;
    CSimpleArray<CString> m_symFiles;
 
-   static MSXML::IXMLDOMNode* CreateDOMNode(MSXML::IXMLDOMDocument* pDoc, 
+   // used by stack wallback
+   MSXML::IXMLDOMElement* m_stack_element;
+   MSXML::IXMLDOMDocument* m_stack_doc;
+   int m_frameNumber;
+
+   // used by exception node creation, symbol translations
+   MSXML::IXMLDOMElement*  m_exception_element;
+
+   // used by dump callback
+   std::vector<MINIDUMP_MODULE_CALLBACK>	m_modules;
+
+   static void writeDumpFile(HANDLE file, PEXCEPTION_POINTERS m_excpInfo, void *data);
+
+   MSXML::IXMLDOMNode* CreateDOMNode(MSXML::IXMLDOMDocument* pDoc, 
                                             int type, 
                                             BSTR bstrName);
 
-   static MSXML::IXMLDOMNode* CreateExceptionRecordNode(MSXML::IXMLDOMDocument* pDoc, 
+   MSXML::IXMLDOMNode* CreateExceptionRecordNode(MSXML::IXMLDOMDocument* pDoc, 
                                                         EXCEPTION_RECORD* pExceptionRecord);
+   static void CreateExceptionSymbolAttributes(DWORD address, const char *ImageName,
+									  const char *FunctionName, DWORD functionDisp,
+									  const char *Filename, DWORD LineNumber, DWORD lineDisp,
+									  void *data);
+
+   MSXML::IXMLDOMNode* CreateProcessorNode(MSXML::IXMLDOMDocument* pDoc);
+
+   MSXML::IXMLDOMNode* CreateOSNode(MSXML::IXMLDOMDocument* pDoc);
+
+   MSXML::IXMLDOMNode* CreateModulesNode(MSXML::IXMLDOMDocument* pDoc);
 
-   static MSXML::IXMLDOMNode* CreateProcessorNode(MSXML::IXMLDOMDocument* pDoc);
+   MSXML::IXMLDOMNode* CreateMsgNode(MSXML::IXMLDOMDocument* pDoc, BSTR message);
 
-   static MSXML::IXMLDOMNode* CreateOSNode(MSXML::IXMLDOMDocument* pDoc);
+   MSXML::IXMLDOMNode* CreateWalkbackNode(MSXML::IXMLDOMDocument* pDoc, CONTEXT *pContext);
 
-   static MSXML::IXMLDOMNode* CreateModulesNode(MSXML::IXMLDOMDocument* pDoc);
+   static void CreateWalkbackEntryNode(DWORD address, const char *ImageName,
+									  const char *FunctionName, DWORD functionDisp,
+									  const char *Filename, DWORD LineNumber, DWORD lineDisp,
+									  void *data);
 
    static BOOL CALLBACK miniDumpCallback(PVOID CallbackParam,
                                          CONST PMINIDUMP_CALLBACK_INPUT CallbackInput,
diff -urN CrashRpt-orig\crashrpt\src\MailMsg.cpp CrashRpt\crashrpt\src\MailMsg.cpp
--- CrashRpt-orig\crashrpt\src\MailMsg.cpp	Thu Mar 13 11:29:28 2003
+++ CrashRpt\crashrpt\src\MailMsg.cpp	Thu Apr 10 17:29:40 2003
@@ -21,6 +21,8 @@
    m_lpMapiLogon     = NULL;
    m_lpMapiSendMail  = NULL;
    m_lpMapiLogoff    = NULL;
+   m_lpMapiResolveName = NULL;
+   m_lpMapiFreeBuffer = NULL;
    m_bReady          = FALSE;
 }
 
@@ -38,7 +40,7 @@
       if (m_from.size())
          m_from.empty();
 
-      m_from[sAddress] = sName;
+	  m_from.push_back(TStrStrPair(sAddress,sName));
    }
 
    return *this;
@@ -52,7 +54,7 @@
       if (m_to.size())
          m_to.empty();
 
-      m_to[sAddress] = sName;
+	  m_to.push_back(TStrStrPair(sAddress,sName));
    }
 
    return *this;
@@ -62,7 +64,7 @@
 {
    if (m_bReady || Initialize())
    {
-      m_cc[sAddress] = sName;
+      m_cc.push_back(TStrStrPair(sAddress,sName));
    }
 
    return *this;
@@ -72,7 +74,7 @@
 {
    if (m_bReady || Initialize())
    {
-      m_bcc[sAddress] = sName;
+	   m_bcc.push_back(TStrStrPair(sAddress, sName));
    }
 
    return *this;
@@ -82,7 +84,7 @@
 {
    if (m_bReady || Initialize())
    {
-      m_attachments[sAttachment] = sTitle;
+      m_attachments.push_back(TStrStrPair(sAttachment, sTitle));
    }
 
    return *this;
@@ -91,32 +93,94 @@
 BOOL CMailMsg::Send()
 {
    // try mapi
-   if (MAPISend())
-      return TRUE;
-
+   int status = MAPISend();
+   if (status != 0)
+      return status == 1;
    // try cmc
-   if (CMCSend())
-      return TRUE;
+//   if (CMCSend())
+//      return TRUE;
 
    return FALSE;
 }
 
-BOOL CMailMsg::MAPISend()
+/*
++------------------------------------------------------------------------------
+|
+|	Function:	cResolveName()
+|
+|	Parameters:	[IN]	lpszName = Name of e-mail recipient to resolve.
+|				[OUT]	ppRecips = Pointer to a pointer to an lpMapiRecipDesc
+|
+|	Purpose:	Resolves an e-mail address and returns a pointer to a 
+|				MapiRecipDesc structure filled with the recipient information
+|				contained in the address book.
+|
+|	Note:		ppRecips is allocated off the heap using MAPIAllocateBuffer.
+|				Any user of this method must be sure to release ppRecips when 
+|				done with it using either MAPIFreeBuffer or cFreeBuffer.
++-------------------------------------------------------------------------------
+*/
+int CMailMsg::cResolveName( LHANDLE m_lhSession, const char * lpszName, lpMapiRecipDesc *ppRecip )
+{	
+	HRESULT hRes = E_FAIL;
+	FLAGS flFlags = 0L;
+	ULONG ulReserved = 0L;
+	lpMapiRecipDesc pRecips = NULL;
+	
+	// Always check to make sure there is an active session
+	if ( m_lhSession )		
+	{
+		hRes = m_lpMapiResolveName (
+								     m_lhSession,	// Session handle
+									 0L,			// Parent window.
+									 const_cast<LPSTR>(lpszName),		// Name of recipient.  Passed in by argv.
+									 flFlags,		// Flags set to 0 for MAPIResolveName.
+									 ulReserved,
+									 &pRecips
+								  );				
+
+		if ( hRes == SUCCESS_SUCCESS )
+		{  
+			// Copy the recipient descriptor returned from MAPIResolveName to 
+			// the out parameter for this function,
+			*ppRecip = pRecips;
+		}  
+	}
+	return hRes;
+}
+
+
+
+int CMailMsg::MAPISend()
 {
-   TStrStrMap::iterator p;
+
+   TStrStrVector::iterator p;
    int                  nIndex = 0;
    int                  nRecipients = 0;
    MapiRecipDesc*       pRecipients = NULL;
+   MapiRecipDesc*       pOriginator = NULL;
+   MapiRecipDesc*       pFirstRecipient = NULL;
    int                  nAttachments = 0;
    MapiFileDesc*        pAttachments = NULL;
    ULONG                status = 0;
    MapiMessage          message;
+   std::vector<MapiRecipDesc*>	buffersToFree;
+   MapiRecipDesc*       pRecip;
 
    if (m_bReady || Initialize())
    {
+	  LHANDLE hMapiSession;
+	  status = m_lpMapiLogon(NULL, NULL, NULL, MAPI_NEW_SESSION | MAPI_LOGON_UI, 0, &hMapiSession);
+	  if (SUCCESS_SUCCESS != status) {
+		  return FALSE;
+	  }
+
       nRecipients = m_to.size() + m_cc.size() + m_bcc.size() + m_from.size();
       if (nRecipients)
+	  {
          pRecipients = new MapiRecipDesc[nRecipients];
+		 memset(pRecipients, 0, nRecipients * sizeof  MapiRecipDesc);
+	  }
 
       nAttachments = m_attachments.size();
       if (nAttachments)
@@ -124,41 +188,36 @@
 
       if (pRecipients)
       {
+         pFirstRecipient = pRecipients;
          if (m_from.size())
          {
             // set from
-            pRecipients[nIndex].ulReserved                 = 0;
-            pRecipients[nIndex].ulRecipClass               = MAPI_ORIG;
-            pRecipients[nIndex].lpszAddress                = (LPTSTR)(LPCTSTR)m_from.begin()->first;
-            pRecipients[nIndex].lpszName                   = (LPTSTR)(LPCTSTR)m_from.begin()->second;
-            pRecipients[nIndex].ulEIDSize                  = 0;
-            pRecipients[nIndex].lpEntryID                  = NULL;
-            nIndex++;
+			 if (cResolveName(hMapiSession, m_from.begin()->first, &pOriginator) == SUCCESS_SUCCESS) {
+				buffersToFree.push_back(pOriginator);
+			 }
          }
-
          if (m_to.size())
          {
-            // set to
-            pRecipients[nIndex].ulReserved                 = 0;
-            pRecipients[nIndex].ulRecipClass               = MAPI_TO;
-            pRecipients[nIndex].lpszAddress                = (LPTSTR)(LPCTSTR)m_to.begin()->first;
-            pRecipients[nIndex].lpszName                   = (LPTSTR)(LPCTSTR)m_to.begin()->second;
-            pRecipients[nIndex].ulEIDSize                  = 0;
-            pRecipients[nIndex].lpEntryID                  = NULL;
-            nIndex++;
-         }
-
+			 if (cResolveName(hMapiSession, m_to.begin()->first, &pRecip) == SUCCESS_SUCCESS) {
+				if (pFirstRecipient == NULL)
+					pFirstRecipient = &pRecipients[nIndex];
+				memcpy(&pRecipients[nIndex], pRecip, sizeof pRecipients[nIndex]);
+				buffersToFree.push_back(pRecip);
+				nIndex++;
+			 }
+         }		
          if (m_cc.size())
          {
             // set cc's
             for (p = m_cc.begin(); p != m_cc.end(); p++, nIndex++)
             {
-               pRecipients[nIndex].ulReserved         = 0;
-               pRecipients[nIndex].ulRecipClass       = MAPI_CC;
-               pRecipients[nIndex].lpszAddress        = (LPTSTR)(LPCTSTR)p->first;
-               pRecipients[nIndex].lpszName           = (LPTSTR)(LPCTSTR)p->second;
-               pRecipients[nIndex].ulEIDSize          = 0;
-               pRecipients[nIndex].lpEntryID          = NULL;
+				if ( cResolveName(hMapiSession, p->first, &pRecip) == SUCCESS_SUCCESS) {
+					if (pFirstRecipient == NULL)
+						pFirstRecipient = &pRecipients[nIndex];
+					memcpy(&pRecipients[nIndex], pRecip, sizeof pRecipients[nIndex]);
+					buffersToFree.push_back(pRecip);
+					nIndex++;
+				}
             }
          }
    
@@ -167,16 +226,16 @@
             // set bcc
             for (p = m_bcc.begin(); p != m_bcc.end(); p++, nIndex++)
             {
-               pRecipients[nIndex].ulReserved         = 0;
-               pRecipients[nIndex].ulRecipClass       = MAPI_BCC;
-               pRecipients[nIndex].lpszAddress        = (LPTSTR)(LPCTSTR)p->first;
-               pRecipients[nIndex].lpszName           = (LPTSTR)(LPCTSTR)p->second;
-               pRecipients[nIndex].ulEIDSize          = 0;
-               pRecipients[nIndex].lpEntryID          = NULL;
+				if ( cResolveName(hMapiSession, p->first, &pRecip) == SUCCESS_SUCCESS) {
+					if (pFirstRecipient == NULL)
+						pFirstRecipient = &pRecipients[nIndex];
+					memcpy(&pRecipients[nIndex], pRecip, sizeof pRecipients[nIndex]);
+					buffersToFree.push_back(pRecip);
+					nIndex++;
+				}
             }
          }
       }
-
       if (pAttachments)
       {
          // add attachments
@@ -185,27 +244,89 @@
          {
             pAttachments[nIndex].ulReserved        = 0;
             pAttachments[nIndex].flFlags           = 0;
-            pAttachments[nIndex].nPosition         = 0xFFFFFFFF;
+            pAttachments[nIndex].nPosition         = 0;
             pAttachments[nIndex].lpszPathName      = (LPTSTR)(LPCTSTR)p->first;
             pAttachments[nIndex].lpszFileName      = (LPTSTR)(LPCTSTR)p->second;
             pAttachments[nIndex].lpFileType        = NULL;
          }
       }
-
+	  memset(&message, 0, sizeof message);
       message.ulReserved                        = 0;
-      message.lpszSubject                       = (LPTSTR)(LPCTSTR)m_sSubject;
-      message.lpszNoteText                      = (LPTSTR)(LPCTSTR)m_sMessage;
+	  if (!m_sSubject.IsEmpty())
+	      message.lpszSubject                       = (LPTSTR)(LPCTSTR)m_sSubject;
+	  else
+		  message.lpszSubject = "No Subject";
+	  if (!m_sMessage.IsEmpty())
+	      message.lpszNoteText                      = (LPTSTR)(LPCTSTR)m_sMessage;
+	  else
+		  message.lpszNoteText = "No Message Body";
       message.lpszMessageType                   = NULL;
       message.lpszDateReceived                  = NULL;
       message.lpszConversationID                = NULL;
       message.flFlags                           = 0;
-      message.lpOriginator                      = m_from.size() ? pRecipients : NULL;
-      message.nRecipCount                       = nRecipients - m_from.size(); // don't count originator
-      message.lpRecips                          = nRecipients - m_from.size() ? &pRecipients[m_from.size()] : NULL;
+      message.lpOriginator                      = pOriginator;
+      message.nRecipCount                       = nIndex;
+      message.lpRecips                          = pFirstRecipient;
       message.nFileCount                        = nAttachments;
-      message.lpFiles                           = nAttachments ? pAttachments : NULL;
+      message.lpFiles                           = pAttachments;
 
-      status = m_lpMapiSendMail(0, 0, &message, MAPI_DIALOG, 0);
+      status = m_lpMapiSendMail(hMapiSession, 0, &message, MAPI_DIALOG, 0);
+		  
+      m_lpMapiLogoff(hMapiSession, NULL, 0, 0);
+	  std::vector<MapiRecipDesc*>::iterator iter;
+	  for (iter = buffersToFree.begin(); iter != buffersToFree.end(); iter++) {
+		  m_lpMapiFreeBuffer(*iter);
+	  }
+if (SUCCESS_SUCCESS != status) {
+				CString txt;
+			txt.Format( "Message did not get sent due to error code %d.\r\n", status ); 
+			switch (status)
+			{  
+			case MAPI_E_AMBIGUOUS_RECIPIENT:
+				txt += "A recipient matched more than one of the recipient descriptor structures and MAPI_DIALOG was not set. No message was sent.\r\n" ;
+				break;
+			case MAPI_E_ATTACHMENT_NOT_FOUND:
+				txt += "The specified attachment was not found. No message was sent.\r\n" ;
+				break;
+			case MAPI_E_ATTACHMENT_OPEN_FAILURE:
+				txt += "The specified attachment could not be opened. No message was sent.\r\n" ;
+				break;
+			case MAPI_E_BAD_RECIPTYPE:
+				txt += "The type of a recipient was not MAPI_TO, MAPI_CC, or MAPI_BCC. No message was sent.\r\n" ;
+				break;
+			case MAPI_E_FAILURE:
+				txt += "One or more unspecified errors occurred. No message was sent.\r\n" ;
+				break;
+			case MAPI_E_INSUFFICIENT_MEMORY:
+				txt += "There was insufficient memory to proceed. No message was sent.\r\n" ;
+				break;
+			case MAPI_E_INVALID_RECIPS:
+				txt += "One or more recipients were invalid or did not resolve to any address.\r\n" ;
+				break;
+			case MAPI_E_LOGIN_FAILURE:
+				txt += "There was no default logon, and the user failed to log on successfully when the logon dialog box was displayed. No message was sent.\r\n" ;
+				break;
+			case MAPI_E_TEXT_TOO_LARGE:
+				txt += "The text in the message was too large. No message was sent.\r\n" ;
+				break;
+			case MAPI_E_TOO_MANY_FILES:
+				txt += "There were too many file attachments. No message was sent.\r\n" ;
+				break;
+			case MAPI_E_TOO_MANY_RECIPIENTS:
+				txt += "There were too many recipients. No message was sent.\r\n" ;
+				break;
+			case MAPI_E_UNKNOWN_RECIPIENT:
+				txt += "A recipient did not appear in the address list. No message was sent.\r\n" ;
+				break;
+			case MAPI_E_USER_ABORT:
+				txt += "The user canceled one of the dialog boxes. No message was sent.\r\n" ;
+				break;
+			default:
+				txt += "Unknown error code.\r\n" ;
+				break;
+			}
+			::MessageBox(0, txt, "Error", MB_OK);
+}
 
       if (pRecipients)
          delete [] pRecipients;
@@ -214,12 +335,17 @@
          delete [] pAttachments;
    }
 
-   return (SUCCESS_SUCCESS == status);
+   if (SUCCESS_SUCCESS == status)
+	   return 1;
+   if (MAPI_E_USER_ABORT == status)
+	   return -1;
+   // other failure
+   return 0;
 }
 
 BOOL CMailMsg::CMCSend()
 {
-   TStrStrMap::iterator p;
+   TStrStrVector::iterator p;
    int                  nIndex = 0;
    CMC_recipient*       pRecipients;
    CMC_attachment*      pAttachments;
@@ -286,9 +412,15 @@
 
       message.message_reference                 = NULL;
       message.message_type                      = NULL;
-      message.subject                           = (LPTSTR)(LPCTSTR)m_sSubject;
+	  if (m_sSubject.IsEmpty())
+		  message.subject = "No Subject";
+	  else
+	      message.subject                           = (LPTSTR)(LPCTSTR)m_sSubject;
       message.time_sent                         = t_now;
-      message.text_note                         = (LPTSTR)(LPCTSTR)m_sMessage;
+	  if (m_sMessage.IsEmpty())
+		  message.text_note = "No Body";
+	  else
+		  message.text_note                         = (LPTSTR)(LPCTSTR)m_sMessage;
       message.recipients                        = pRecipients;
       message.attachments                       = pAttachments;
       message.message_flags                     = 0;
@@ -345,6 +477,8 @@
    m_lpMapiLogon = (LPMAPILOGON)::GetProcAddress(m_hMapi, _T("MAPILogon"));
    m_lpMapiSendMail = (LPMAPISENDMAIL)::GetProcAddress(m_hMapi, _T("MAPISendMail"));
    m_lpMapiLogoff = (LPMAPILOGOFF)::GetProcAddress(m_hMapi, _T("MAPILogoff"));
+   m_lpMapiResolveName = (LPMAPIRESOLVENAME) GetProcAddress(m_hMapi, _T("MAPIResolveName"));
+   m_lpMapiFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress(m_hMapi, _T("MAPIFreeBuffer"));
 
    m_bReady = (m_lpCmcLogon && m_lpCmcSend && m_lpCmcLogoff) ||
               (m_lpMapiLogon && m_lpMapiSendMail && m_lpMapiLogoff);
diff -urN CrashRpt-orig\crashrpt\src\MailMsg.h CrashRpt\crashrpt\src\MailMsg.h
--- CrashRpt-orig\crashrpt\src\MailMsg.h	Thu Mar 13 14:22:32 2003
+++ CrashRpt\crashrpt\src\MailMsg.h	Thu Apr 10 17:30:00 2003
@@ -18,12 +18,24 @@
 #include <xcmc.h>          // CMC function defs
 #include <mapi.h>          // MAPI function defs
 
-#ifndef TStrStrMap
-#include <map>
+#ifndef TStrStrVector
+// STL generates various warnings.
+// 4100: unreferenced formal parameter
+// 4663: C++ language change: to explicitly specialize class template...
+// 4018: signed/unsigned mismatch
+// 4245: conversion from <a> to <b>: signed/unsigned mismatch
+#pragma warning(push, 3)
+#pragma warning(disable: 4100)
+#pragma warning(disable: 4663)
+#pragma warning(disable: 4018)
+#pragma warning(disable: 4245)
+#include <vector>
+#pragma warning(pop)
 #include <atlmisc.h>
 
-typedef std::map<CString,CString> TStrStrMap;
-#endif // !defined TStrStrMap
+typedef std::pair<CString,CString> TStrStrPair;
+typedef std::vector<TStrStrPair> TStrStrVector;
+#endif // !defined TStrStrVector
 
 //
 // Define CMC entry points
@@ -235,12 +247,12 @@
    //    none
    //
    // Return Values
-   //    TRUE if successful
+   //    -1: cancelled; 0: other failure; 1: success
    //
    // Remarks
    //    none
    //
-   BOOL MAPISend();
+   int MAPISend();
 
    //-----------------------------------------------------------------------------
    // Initialize
@@ -272,11 +284,30 @@
    //
    void Uninitialize();
 
-   TStrStrMap     m_from;                       // From <address,name>
-   TStrStrMap     m_to;                         // To <address,name>
-   TStrStrMap     m_cc;                         // Cc <address,name>
-   TStrStrMap     m_bcc;                        // Bcc <address,name>
-   TStrStrMap     m_attachments;                // Attachment <file,title>
+	/*
+	+------------------------------------------------------------------------------
+	|
+	|	Function:	cResolveName()
+	|
+	|	Parameters:	[IN]	lpszName = Name of e-mail recipient to resolve.
+	|				[OUT]	ppRecips = Pointer to a pointer to an lpMapiRecipDesc
+	|
+	|	Purpose:	Resolves an e-mail address and returns a pointer to a 
+	|				MapiRecipDesc structure filled with the recipient information
+	|				contained in the address book.
+	|
+	|	Note:		ppRecips is allocated off the heap using MAPIAllocateBuffer.
+	|				Any user of this method must be sure to release ppRecips when 
+	|				done with it using either MAPIFreeBuffer or cFreeBuffer.
+	+-------------------------------------------------------------------------------
+	*/
+   int cResolveName( LHANDLE m_lhSession, const char * lpszName, lpMapiRecipDesc *ppRecip );
+
+   TStrStrVector  m_from;                       // From <address,name>
+   TStrStrVector  m_to;                         // To <address,name>
+   TStrStrVector  m_cc;                         // Cc <address,name>
+   TStrStrVector  m_bcc;                        // Bcc <address,name>
+   TStrStrVector  m_attachments;                // Attachment <file,title>
    CString        m_sSubject;                   // EMail subject
    CString        m_sMessage;                   // EMail message
 
@@ -288,6 +319,8 @@
    LPMAPILOGON    m_lpMapiLogon;                // Mapi func pointer
    LPMAPISENDMAIL m_lpMapiSendMail;             // Mapi func pointer
    LPMAPILOGOFF   m_lpMapiLogoff;               // Mapi func pointer
+   LPMAPIRESOLVENAME m_lpMapiResolveName;       // Mapi func pointer
+   LPMAPIFREEBUFFER m_lpMapiFreeBuffer;         // Mapi func pointer
    
    BOOL           m_bReady;                     // MAPI is loaded
 };
diff -urN CrashRpt-orig\crashrpt\src\maindlg.h CrashRpt\crashrpt\src\maindlg.h
--- CrashRpt-orig\crashrpt\src\maindlg.h	Thu Mar 13 10:34:42 2003
+++ CrashRpt\crashrpt\src\maindlg.h	Tue Apr 22 11:01:48 2003
@@ -53,7 +53,8 @@
    CString     m_sEmail;         // Email: From
    CString     m_sDescription;   // Email: Body
    CDeadLink   m_link;           // Dead link
-   TStrStrMap  *m_pUDFiles;      // Files <name,desc>
+   TStrStrVector  *m_pUDFiles;      // Files <name,desc>
+   BOOL        m_sendButton;     // Display 'Send' or 'Save' button
 
 	BEGIN_MSG_MAP(CMainDlg)
 		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
@@ -61,6 +62,8 @@
       MESSAGE_HANDLER(WM_SYSCOMMAND, OnSysCommand)
 		COMMAND_ID_HANDLER(IDOK, OnSend)
 		COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
+		COMMAND_ID_HANDLER(IDC_SAVE, OnCancel)
+		COMMAND_ID_HANDLER(IDC_DEBUG, OnCancel)
 	END_MSG_MAP()
 
    
@@ -93,7 +96,7 @@
 
       CMenu sysMenu;
       sysMenu.Attach(GetSystemMenu(FALSE));
-      if (sysMenu.IsMenu())
+//      if (sysMenu.IsMenu())
       {
 		   CString strAboutMenu;
 		   strAboutMenu.LoadString(IDS_ABOUTBOX);
@@ -108,6 +111,55 @@
       //
       SetWindowText(CUtility::getAppName());
 
+	  // Hide 'Send' button if required. Position 'Send' and 'Save'.
+	  //
+	  HWND okButton = GetDlgItem(IDOK);
+      HWND saveButton = GetDlgItem(IDC_SAVE);
+	  if (m_sendButton) {
+		// Line up Save, Send [OK] and Exit [Cancel] all in a row
+		HWND cancelButton = GetDlgItem(IDCANCEL);
+		WINDOWPLACEMENT okPlace;
+		WINDOWPLACEMENT savePlace;
+		WINDOWPLACEMENT cancelPlace;
+
+		::GetWindowPlacement(okButton, &okPlace);
+		::GetWindowPlacement(saveButton, &savePlace);
+		::GetWindowPlacement(cancelButton, &cancelPlace);
+
+		savePlace.rcNormalPosition.left =
+			okPlace.rcNormalPosition.left -
+			(savePlace.rcNormalPosition.right - savePlace.rcNormalPosition.left) +
+			(okPlace.rcNormalPosition.right - cancelPlace.rcNormalPosition.left);
+		::SetWindowPlacement(saveButton, &savePlace);
+
+		DWORD style = ::GetWindowLong(okButton, GWL_STYLE);
+		::SetWindowLong(okButton, GWL_STYLE, style  | WS_VISIBLE);
+	  } else {
+		WINDOWPLACEMENT okPlace;
+
+		// Put Save on top of the invisible Send [OK]
+		::GetWindowPlacement(okButton, &okPlace);
+
+		::SetWindowPlacement(saveButton, &okPlace);
+
+		DWORD style = ::GetWindowLong(okButton, GWL_STYLE);
+		::SetWindowLong(okButton, GWL_STYLE, style  & ~ WS_VISIBLE);
+	  }
+	  // Enable Debug button if appropriate
+	  HKEY key;
+	  if (RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Carruth\\CrashRpt", 0, KEY_READ, &key) == ERROR_SUCCESS) {
+		  DWORD type;
+		  DWORD data;
+		  DWORD data_len = sizeof data;
+		  if (RegQueryValueEx(key, "EnableDebug", 0, &type, reinterpret_cast<LPBYTE>(&data), &data_len) == ERROR_SUCCESS &&
+			  type == REG_DWORD) {
+			  HWND debugButton = GetDlgItem(IDC_DEBUG);
+			  DWORD style = ::GetWindowLong(debugButton, GWL_STYLE);
+			  ::SetWindowLong(debugButton, GWL_STYLE, style | WS_VISIBLE);
+		  }
+		  RegCloseKey(key);
+	  }
+
       //
       // Use app icon
       //
@@ -131,6 +183,13 @@
       re.StreamIn(SF_RTF, es);
       re.Detach();
 
+	  static char username[_MAX_PATH];
+	  DWORD size = sizeof username;
+	  if (::GetUserName(username, &size)) {
+	      HWND     hWndEmail = GetDlgItem(IDC_EMAIL);
+		  ::SetWindowText(hWndEmail, username);
+	  }
+
       //
       // Hook dead link
       //
@@ -145,7 +204,7 @@
    //
    // Display details dialog instead of opening URL
    //
-   LRESULT OnLinkClick(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+   LRESULT OnLinkClick(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
    {
       CDetailDlg dlg;
       dlg.m_pUDFiles = m_pUDFiles;
@@ -182,8 +241,8 @@
 	{
       HWND     hWndEmail = GetDlgItem(IDC_EMAIL);
       HWND     hWndDesc = GetDlgItem(IDC_DESCRIPTION);
-	   int      nEmailLen = ::GetWindowTextLength(hWndEmail);
-      int      nDescLen = ::GetWindowTextLength(hWndDesc);
+	   int      nEmailLen = ::GetWindowTextLength(hWndEmail) + 1;
+      int      nDescLen = ::GetWindowTextLength(hWndDesc) + 1;
 
       LPTSTR lpStr = m_sEmail.GetBufferSetLength(nEmailLen);
       ::GetWindowText(hWndEmail, lpStr, nEmailLen);
diff -urN CrashRpt-orig\crashrpt\src\resource.h CrashRpt\crashrpt\src\resource.h
--- CrashRpt-orig\crashrpt\src\resource.h	Thu Mar 13 11:36:40 2003
+++ CrashRpt\crashrpt\src\resource.h	Fri Apr 11 12:46:06 2003
@@ -2,6 +2,8 @@
 // Microsoft Developer Studio generated include file.
 // Used by CrashRpt.rc
 //
+#define IDC_SAVE                        4
+#define IDC_DEBUG                       5
 #define IDM_ABOUTBOX                    0x0010
 #define IDD_ABOUTBOX                    100
 #define IDR_MAINFRAME                   128
@@ -27,9 +29,11 @@
 #define IDS_CRASH_LOG                   1005
 #define IDC_RICHEDIT1                   1005
 #define IDS_SYMBOL_FILE                 1006
-#define IDS_HTTP_FORM_DATA              1007
+#define IDS_EVENT_LOG                   1007
 #define IDC_EMAIL_LINK                  1007
 #define IDC_LICENSE_LINK                1008
+#define IDS_USER_DATA                   1008
+#define IDS_SEND                        1010
 #define IDS_CONTENT_TYPE                57346
 #define IDS_HEADER                      57610
 #define IDS_MESSAGE                     57611
diff -urN CrashRpt-orig\crashrpt\src\StackTrace.cpp CrashRpt\crashrpt\src\StackTrace.cpp
--- CrashRpt-orig\crashrpt\src\StackTrace.cpp	Wed Dec 31 19:00:00 1969
+++ CrashRpt\crashrpt\src\StackTrace.cpp	Mon Apr 21 14:30:10 2003
@@ -0,0 +1,307 @@
+/*----------------------------------------------------------------------
+   John Robbins - Microsoft Systems Journal Bugslayer Column - Feb 99
+----------------------------------------------------------------------*/
+#include <windows.h>
+#include <stdlib.h>
+#include <tchar.h>
+#include <stdio.h>
+
+// Force imagehlp in.
+#include <imagehlp.h>
+
+
+#include "StackTrace.h"
+#include "SymbolEngine.h"
+
+// 4710: inline function not inlined
+#pragma warning(disable: 4710)
+#pragma warning(disable: 4786)
+#pragma warning(push, 3)
+#include <map>
+#pragma warning(pop)
+
+/*//////////////////////////////////////////////////////////////////////
+                           File Scope Globals
+//////////////////////////////////////////////////////////////////////*/
+
+// The symbol engine. Indexed by process-id so there is no collision between processes.
+#pragma warning(push, 3)
+typedef std::map<DWORD, CSymbolEngine> TSymbolEngineMap;
+static TSymbolEngineMap g_cSymMap;
+#pragma warning(pop)
+
+static CSymbolEngine & GetSymbolEngine()
+{
+	TSymbolEngineMap::iterator	iter;
+	iter = g_cSymMap.find(GetCurrentProcessId());
+	if (iter == g_cSymMap.end()) {
+		CSymbolEngine	cSym;
+	    HANDLE hProcess = GetCurrentProcess ( ) ;
+        DWORD dwOpts = SymGetOptions ( ) ;
+
+        // Turn on load lines.
+        SymSetOptions ( dwOpts                |
+                        SYMOPT_LOAD_LINES      ) ;
+
+        if ( FALSE == g_cSymMap[GetCurrentProcessId()].SymInitialize ( hProcess ,
+                                             NULL     ,
+                                             FALSE     ) )
+            {
+            OutputDebugString ( "DiagAssert : Unable to initialize the "
+                    "symbol engine!!!\n" ) ;
+#ifdef _DEBUG
+            DebugBreak ( ) ;
+#endif
+            }
+      }
+	return g_cSymMap[GetCurrentProcessId()];
+}
+
+static DWORD __stdcall GetModBase ( HANDLE hProcess , DWORD dwAddr )
+{
+    // Check in the symbol engine first.
+    IMAGEHLP_MODULE stIHM ;
+	CSymbolEngine	& cSym = GetSymbolEngine();
+
+    // This is what the MFC stack trace routines forgot to do so their
+    //  code will not get the info out of the symbol engine.
+    stIHM.SizeOfStruct = sizeof ( IMAGEHLP_MODULE ) ;
+
+    if ( cSym.SymGetModuleInfo ( dwAddr , &stIHM ) )
+    {
+        return ( stIHM.BaseOfImage ) ;
+    }
+    else
+    {
+        // Let's go fishing.
+        MEMORY_BASIC_INFORMATION stMBI ;
+
+        if ( 0 != VirtualQueryEx ( hProcess         ,
+                                   (LPCVOID)dwAddr  ,
+                                   &stMBI           ,
+                                   sizeof ( stMBI )  ) )
+        {
+            // Try and load it.
+            DWORD dwNameLen = 0 ;
+            TCHAR szFile[ MAX_PATH ] ;
+            szFile[0] = '\0';
+            dwNameLen = GetModuleFileName ( (HINSTANCE)
+                                                stMBI.AllocationBase ,
+                                            szFile                   ,
+                                            MAX_PATH                  );
+            HANDLE hFile = NULL ;
+
+            if ( 0 != dwNameLen )
+            {
+                hFile = CreateFile ( szFile       ,
+                                     GENERIC_READ    ,
+                                     FILE_SHARE_READ ,
+                                     NULL            ,
+                                     OPEN_EXISTING   ,
+                                     0               ,
+                                     0                ) ;
+            }
+#ifdef NOTDEF_DEBUG
+            DWORD dwRet =
+#endif
+            cSym.SymLoadModule ( hFile                            ,
+                                  ( dwNameLen ? szFile : NULL )    ,
+                                   NULL                             ,
+                                   (DWORD)stMBI.AllocationBase      ,
+                                   0                                 ) ;
+			::CloseHandle(hFile);
+#ifdef NOTDEF_DEBUG
+            if ( 0 == dwRet )
+            {
+                ATLTRACE ( "SymLoadModule failed : 0x%08X\n" ,
+                        GetLastError ( )                   ) ;
+            }
+#endif  // _DEBUG
+            return ( (DWORD)stMBI.AllocationBase ) ;
+        }
+    }
+    return ( 0 ) ;
+}
+
+static void PrintAddress (DWORD address, const char *ImageName,
+									  const char *FunctionName, DWORD functionDisp,
+									  const char *Filename, DWORD LineNumber, DWORD lineDisp,
+									  void * /* data, unused */ )
+{
+    static char buffer [ MAX_PATH*2 + 512 ];
+   LPTSTR pCurrPos = buffer ;
+    // Always stick the address in first.
+    pCurrPos += _snprintf ( pCurrPos ,  sizeof buffer - (pCurrPos - buffer), ( "0x%08X " ) , address ) ;
+
+	if (ImageName != NULL) {
+		LPTSTR szName = strchr ( ImageName ,  ( '\\' ) ) ;
+		if ( NULL != szName ) {
+			szName++ ;
+		} else {
+			szName = const_cast<char *>(ImageName) ;
+		}
+		pCurrPos += _snprintf ( pCurrPos ,  sizeof buffer - (pCurrPos - buffer), ( "%s: " ) , szName ) ;
+	} else {
+        pCurrPos += _snprintf ( pCurrPos , sizeof buffer - (pCurrPos - buffer),  ( "<unknown module>: " ) );
+	}
+	if (FunctionName != NULL) {
+        if ( 0 == functionDisp ) {
+            pCurrPos += _snprintf ( pCurrPos , sizeof buffer - (pCurrPos - buffer),  ( "%s" ) , FunctionName);
+		} else {
+            pCurrPos += _snprintf ( pCurrPos               , sizeof buffer - (pCurrPos - buffer), 
+                                    ( "%s + %d bytes" ) ,
+                                   FunctionName             ,
+                                   functionDisp                  ) ;
+		}
+		if (Filename != NULL) {
+            // Put this on the next line and indented a bit.
+			pCurrPos += _snprintf( pCurrPos, sizeof buffer - (pCurrPos - buffer), "-\n");
+            OutputDebugString(buffer);
+            pCurrPos = buffer;
+            pCurrPos += _snprintf ( pCurrPos                  , sizeof buffer - (pCurrPos - buffer), 
+                                   ( "\t\t%s, Line %d" ) ,
+                                  Filename             ,
+                                  LineNumber            ) ;
+            if ( 0 != lineDisp )
+                  {
+                pCurrPos += _snprintf ( pCurrPos             , sizeof buffer - (pCurrPos - buffer), 
+                                        ( " + %d bytes" ) ,
+                                       lineDisp                ) ;
+                  }
+		}
+	} else {
+        pCurrPos += _snprintf ( pCurrPos , sizeof buffer - (pCurrPos - buffer),  ( "<unknown symbol>" ) ) ;
+	}
+    // Tack on a CRLF.
+    pCurrPos += _snprintf ( pCurrPos , sizeof buffer - (pCurrPos - buffer),  ( "\n" ) ) ;
+    OutputDebugString ( buffer );
+}
+
+
+void AddressToSymbol(DWORD dwAddr, TraceCallbackFunction pFunction, LPVOID data)
+{
+    char szTemp [ MAX_PATH + sizeof ( IMAGEHLP_SYMBOL ) ] ;
+
+    PIMAGEHLP_SYMBOL pIHS = (PIMAGEHLP_SYMBOL)&szTemp ;
+
+    IMAGEHLP_MODULE stIHM ;
+    IMAGEHLP_LINE stIHL ;
+
+ 	bool haveModule = false;
+	bool haveFunction = false;
+	bool haveLine = false;
+
+	CSymbolEngine & cSym = GetSymbolEngine();
+
+
+    ZeroMemory ( pIHS , MAX_PATH + sizeof ( IMAGEHLP_SYMBOL ) ) ;
+    ZeroMemory ( &stIHM , sizeof ( IMAGEHLP_MODULE ) ) ;
+    ZeroMemory ( &stIHL , sizeof ( IMAGEHLP_LINE ) ) ;
+
+    pIHS->SizeOfStruct = sizeof ( IMAGEHLP_SYMBOL ) ;
+    pIHS->Address = dwAddr ;
+    pIHS->MaxNameLength = MAX_PATH ;
+
+    stIHM.SizeOfStruct = sizeof ( IMAGEHLP_MODULE ) ;
+
+
+    // Get the module name.
+	haveModule = 0 != cSym.SymGetModuleInfo ( dwAddr , &stIHM );
+
+    // Get the function.
+    DWORD dwFuncDisp=0 ;
+	DWORD dwLineDisp=0;
+    if ( 0 != cSym.SymGetSymFromAddr ( dwAddr , &dwFuncDisp , pIHS ) )
+      {
+		haveFunction = true;
+
+
+        // If I got a symbol, give the source and line a whirl.
+
+
+        stIHL.SizeOfStruct = sizeof ( IMAGEHLP_LINE ) ;
+
+        haveLine = 0 != cSym.SymGetLineFromAddr ( dwAddr  ,
+                                              &dwLineDisp ,
+                                              &stIHL   );
+      }
+	if (pFunction != NULL) {
+		pFunction(dwAddr, haveModule ? stIHM.ImageName : NULL,
+			haveFunction ? pIHS->Name : NULL, dwFuncDisp,
+			haveLine ? stIHL.FileName : NULL, haveLine ? stIHL.LineNumber : 0, dwLineDisp,
+			data);
+	}
+}
+
+void DoStackTrace ( int numSkip, int depth, TraceCallbackFunction pFunction, CONTEXT *pContext, LPVOID data )
+{
+    HANDLE hProcess = GetCurrentProcess ( ) ;
+
+	if (pFunction == NULL) {
+		pFunction = PrintAddress;
+	}
+
+    // The symbol engine is initialized so do the stack walk.
+
+    // The thread information - if not supplied.
+    CONTEXT    stCtx  ;
+	if (pContext == NULL) {
+
+		stCtx.ContextFlags = CONTEXT_FULL ;
+
+		if ( GetThreadContext ( GetCurrentThread ( ) , &stCtx ) )
+		  {
+			pContext = &stCtx;
+		}
+	}
+	if (pContext != NULL) {
+        STACKFRAME stFrame ;
+        DWORD      dwMachine ;
+
+        ZeroMemory ( &stFrame , sizeof ( STACKFRAME ) ) ;
+
+        stFrame.AddrPC.Mode = AddrModeFlat ;
+
+#if defined (_M_IX86)
+        dwMachine                = IMAGE_FILE_MACHINE_I386 ;
+        stFrame.AddrPC.Offset    = pContext->Eip    ;
+        stFrame.AddrStack.Offset = pContext->Esp    ;
+        stFrame.AddrStack.Mode   = AddrModeFlat ;
+        stFrame.AddrFrame.Offset = pContext->Ebp    ;
+        stFrame.AddrFrame.Mode   = AddrModeFlat ;
+
+#elif defined (_M_ALPHA)
+        dwMachine                = IMAGE_FILE_MACHINE_ALPHA ;
+        stFrame.AddrPC.Offset    = (unsigned long)pContext->Fir ;
+#else
+#error ( "Unknown machine!" )
+#endif
+
+        // Loop for the first <depth> stack elements.
+        for ( int i = 0 ; i < depth ; i++ )
+            {
+            if ( FALSE == StackWalk ( dwMachine              ,
+                                      hProcess               ,
+                                      hProcess               ,
+                                      &stFrame               ,
+                                      pContext               ,
+                                      NULL                   ,
+                                      SymFunctionTableAccess ,
+                                      GetModBase             ,
+                                      NULL                    ) )
+                  {
+                break ;
+                  }
+            if ( i > numSkip )
+                  {
+                // Also check that the address is not zero.  Sometimes
+                //  StackWalk returns TRUE with a frame of zero.
+                if ( 0 != stFrame.AddrPC.Offset )
+                        {
+			            AddressToSymbol ( stFrame.AddrPC.Offset-1, pFunction, data ) ;
+                        }
+                  }
+            }
+
+      }
+}
diff -urN CrashRpt-orig\crashrpt\src\StackTrace.h CrashRpt\crashrpt\src\StackTrace.h
--- CrashRpt-orig\crashrpt\src\StackTrace.h	Wed Dec 31 19:00:00 1969
+++ CrashRpt\crashrpt\src\StackTrace.h	Thu Apr 10 11:54:44 2003
@@ -0,0 +1,11 @@
+#ifndef STACKTRACE_H
+#define STACKTRACE_H
+
+typedef void (*TraceCallbackFunction)(DWORD address, const char *ImageName,
+									  const char *FunctionName, DWORD functionDisp,
+									  const char *Filename, DWORD LineNumber, DWORD lineDisp, void *data);
+
+extern void DoStackTrace ( int numSkip, int depth=9999, TraceCallbackFunction pFunction=NULL, CONTEXT *pContext=NULL, void *data=NULL );
+extern void AddressToSymbol(DWORD dwAddr, TraceCallbackFunction pFunction, void *data);
+
+#endif
diff -urN CrashRpt-orig\crashrpt\src\StdAfx.h CrashRpt\crashrpt\src\StdAfx.h
--- CrashRpt-orig\crashrpt\src\StdAfx.h	Fri Mar 07 16:48:20 2003
+++ CrashRpt\crashrpt\src\StdAfx.h	Thu Apr 10 11:54:46 2003
@@ -20,7 +20,11 @@
 #include <atlwin.h>
 
 #define CRASHRPTAPI extern "C" __declspec(dllexport)
-#pragma warning(disable: 4100)
+#ifndef _DEBUG
+// 4189: unused variable
+// 4530: unwind semantics not enabled
+#pragma warning(disable: 4189 4530)
+#endif
 #define chSTR2(x) #x
 #define chSTR(x) chSTR2(x)
 #define chMSG(desc) message(__FILE__ "(" chSTR(__LINE__) "):" #desc)
diff -urN CrashRpt-orig\crashrpt\src\SymbolEngine.h CrashRpt\crashrpt\src\SymbolEngine.h
--- CrashRpt-orig\crashrpt\src\SymbolEngine.h	Wed Dec 31 19:00:00 1969
+++ CrashRpt\crashrpt\src\SymbolEngine.h	Thu Apr 10 11:54:50 2003
@@ -0,0 +1,442 @@
+/*----------------------------------------------------------------------
+"Debugging Applications" (Microsoft Press)
+Copyright (c) 1997-2000 John Robbins -- All rights reserved.
+------------------------------------------------------------------------
+This class is a paper-thin layer around the DBGHELP.DLL symbol engine.
+
+This class wraps only those functions that take the unique
+HANDLE value. Other DBGHELP.DLL symbol engine functions are global in
+scope, so I didnt wrap them with this class.
+
+------------------------------------------------------------------------
+Compilation Defines:
+
+DO_NOT_WORK_AROUND_SRCLINE_BUG - If defined, the class will NOT work
+                                 around the SymGetLineFromAddr bug where
+                                 PDB file lookups fail after the first
+                                 lookup.
+USE_BUGSLAYERUTIL - If defined, the class will have another
+                    initialization method, BSUSymInitialize, which will
+                    use BSUSymInitialize from BUGSLAYERUTIL.DLL to
+                    initialize the symbol engine and allow the invade
+                    process flag to work for all Win32 operating systems.
+                    If you use this define, you must use
+                    BUGSLAYERUTIL.H to include this file.
+----------------------------------------------------------------------*/
+
+#ifndef _SYMBOLENGINE_H
+#define _SYMBOLENGINE_H
+
+// You could include either IMAGEHLP.DLL or DBGHELP.DLL.
+#include "imagehlp.h"
+#include <tchar.h>
+
+// Include these in case the user forgets to link against them.
+#pragma comment (lib,"dbghelp.lib")
+#pragma comment (lib,"version.lib")
+
+// The great Bugslayer idea of creating wrapper classes on structures
+// that have size fields came from fellow MSJ columnist, Paul DiLascia.
+// Thanks, Paul!
+
+// I didnt wrap IMAGEHLP_SYMBOL because that is a variable-size
+// structure.
+
+// The IMAGEHLP_MODULE wrapper class
+struct CImageHlp_Module : public IMAGEHLP_MODULE
+{
+    CImageHlp_Module ( )
+    {
+        memset ( this , NULL , sizeof ( IMAGEHLP_MODULE ) ) ;
+        SizeOfStruct = sizeof ( IMAGEHLP_MODULE ) ;
+    }
+} ;
+
+// The IMAGEHLP_LINE wrapper class
+struct CImageHlp_Line : public IMAGEHLP_LINE
+{
+    CImageHlp_Line ( )
+    {
+        memset ( this , NULL , sizeof ( IMAGEHLP_LINE ) ) ;
+        SizeOfStruct = sizeof ( IMAGEHLP_LINE ) ;
+    }
+} ;
+
+// The symbol engine class
+class CSymbolEngine
+{
+/*----------------------------------------------------------------------
+                  Public Construction and Destruction
+----------------------------------------------------------------------*/
+public      :
+    // To use this class, call the SymInitialize member function to
+    // initialize the symbol engine and then use the other member
+    // functions in place of their corresponding DBGHELP.DLL functions.
+    CSymbolEngine ( void )
+    {
+    }
+
+    virtual ~CSymbolEngine ( void )
+    {
+    }
+
+/*----------------------------------------------------------------------
+                  Public Helper Information Functions
+----------------------------------------------------------------------*/
+public      :
+
+    // Returns the file version of DBGHELP.DLL being used.
+    //  To convert the return values into a readable format:
+    //  wsprintf ( szVer                  ,
+    //              ( "%d.%02d.%d.%d" ) ,
+    //             HIWORD ( dwMS )        ,
+    //             LOWORD ( dwMS )        ,
+    //             HIWORD ( dwLS )        ,
+    //             LOWORD ( dwLS )         ) ;
+    //  szVer will contain a string like: 5.00.1878.1
+    BOOL GetImageHlpVersion ( DWORD & dwMS , DWORD & dwLS )
+    {
+        return( GetInMemoryFileVersion (  ( "DBGHELP.DLL" ) ,
+                                         dwMS                 ,
+                                         dwLS                  ) ) ;
+    }
+
+    BOOL GetDbgHelpVersion ( DWORD & dwMS , DWORD & dwLS )
+    {
+        return( GetInMemoryFileVersion (  ( "DBGHELP.DLL" ) ,
+                                         dwMS                 ,
+                                         dwLS                  ) ) ;
+    }
+
+    // Returns the file version of the PDB reading DLLs
+    BOOL GetPDBReaderVersion ( DWORD & dwMS , DWORD & dwLS )
+    {
+        // First try MSDBI.DLL.
+        if ( TRUE == GetInMemoryFileVersion (  ( "MSDBI.DLL" ) ,
+                                              dwMS               ,
+                                              dwLS                ) )
+        {
+            return ( TRUE ) ;
+        }
+        else if ( TRUE == GetInMemoryFileVersion (  ( "MSPDB60.DLL" ),
+                                                   dwMS                ,
+                                                   dwLS               ))
+        {
+            return ( TRUE ) ;
+        }
+        // Just fall down to MSPDB50.DLL.
+        return ( GetInMemoryFileVersion (  ( "MSPDB50.DLL" ) ,
+                                          dwMS                 ,
+                                          dwLS                  ) ) ;
+    }
+
+    // The worker function used by the previous two functions
+    BOOL GetInMemoryFileVersion ( LPCTSTR szFile ,
+                                  DWORD & dwMS   ,
+                                  DWORD & dwLS    )
+    {
+        HMODULE hInstIH = GetModuleHandle ( szFile ) ;
+
+        // Get the full filename of the loaded version.
+        TCHAR szImageHlp[ MAX_PATH ] ;
+        GetModuleFileName ( hInstIH , szImageHlp , MAX_PATH ) ;
+
+        dwMS = 0 ;
+        dwLS = 0 ;
+
+        // Get the version information size.
+        DWORD dwVerInfoHandle ;
+        DWORD dwVerSize       ;
+
+        dwVerSize = GetFileVersionInfoSize ( szImageHlp       ,
+                                             &dwVerInfoHandle  ) ;
+        if ( 0 == dwVerSize )
+        {
+            return ( FALSE ) ;
+        }
+
+        // Got the version size, now get the version information.
+        LPVOID lpData = (LPVOID)new TCHAR [ dwVerSize ] ;
+        if ( FALSE == GetFileVersionInfo ( szImageHlp       ,
+                                           dwVerInfoHandle  ,
+                                           dwVerSize        ,
+                                           lpData            ) )
+        {
+            delete [] lpData ;
+            return ( FALSE ) ;
+        }
+
+        VS_FIXEDFILEINFO * lpVerInfo ;
+        UINT uiLen ;
+        BOOL bRet = VerQueryValue ( lpData              ,
+                                     ( "\\" )         ,
+                                    (LPVOID*)&lpVerInfo ,
+                                    &uiLen               ) ;
+        if ( TRUE == bRet )
+        {
+            dwMS = lpVerInfo->dwFileVersionMS ;
+            dwLS = lpVerInfo->dwFileVersionLS ;
+        }
+
+        delete [] lpData ;
+
+        return ( bRet ) ;
+    }
+
+/*----------------------------------------------------------------------
+                   Public Initialization and Cleanup
+----------------------------------------------------------------------*/
+public      :
+
+    BOOL SymInitialize ( IN HANDLE   hProcess       ,
+                         IN LPSTR    UserSearchPath ,
+                         IN BOOL     fInvadeProcess  )
+    {
+        m_hProcess = hProcess ;
+        return ( ::SymInitialize ( hProcess       ,
+                                   UserSearchPath ,
+                                   fInvadeProcess  ) ) ;
+    }
+
+#ifdef USE_BUGSLAYERUTIL
+    BOOL BSUSymInitialize ( DWORD  dwPID          ,
+                            HANDLE hProcess       ,
+                            PSTR   UserSearchPath ,
+                            BOOL   fInvadeProcess  )
+    {
+        m_hProcess = hProcess ;
+        return ( ::BSUSymInitialize ( dwPID          ,
+                                      hProcess       ,
+                                      UserSearchPath ,
+                                      fInvadeProcess  ) ) ;
+    }
+#endif  // USE_BUGSLAYERUTIL
+    BOOL SymCleanup ( void )
+    {
+        return ( ::SymCleanup ( m_hProcess ) ) ;
+    }
+
+/*----------------------------------------------------------------------
+                       Public Module Manipulation
+----------------------------------------------------------------------*/
+public      :
+
+    BOOL SymEnumerateModules ( IN PSYM_ENUMMODULES_CALLBACK
+                                                    EnumModulesCallback,
+                               IN PVOID             UserContext )
+    {
+        return ( ::SymEnumerateModules ( m_hProcess           ,
+                                         EnumModulesCallback  ,
+                                         UserContext           ) ) ;
+    }
+
+    BOOL SymLoadModule ( IN  HANDLE hFile       ,
+                         IN  PSTR   ImageName   ,
+                         IN  PSTR   ModuleName  ,
+                         IN  DWORD  BaseOfDll   ,
+                         IN  DWORD  SizeOfDll    )
+    {
+        return ( ::SymLoadModule ( m_hProcess   ,
+                                   hFile        ,
+                                   ImageName    ,
+                                   ModuleName   ,
+                                   BaseOfDll    ,
+                                   SizeOfDll     ) ) ;
+    }
+
+    BOOL EnumerateLoadedModules ( IN PENUMLOADED_MODULES_CALLBACK
+                                              EnumLoadedModulesCallback,
+                                  IN PVOID         UserContext       )
+    {
+        return ( ::EnumerateLoadedModules ( m_hProcess                ,
+                                            EnumLoadedModulesCallback ,
+                                            UserContext              ));
+    }
+
+    BOOL SymUnloadModule ( IN  DWORD BaseOfDll )
+    {
+        return ( ::SymUnloadModule ( m_hProcess , BaseOfDll ) ) ;
+    }
+
+    BOOL SymGetModuleInfo ( IN  DWORD            dwAddr     ,
+                            OUT PIMAGEHLP_MODULE ModuleInfo  )
+    {
+        return ( ::SymGetModuleInfo ( m_hProcess    ,
+                                      dwAddr        ,
+                                      ModuleInfo     ) ) ;
+    }
+
+    DWORD SymGetModuleBase ( IN DWORD dwAddr )
+    {
+        return ( ::SymGetModuleBase ( m_hProcess , dwAddr ) ) ;
+    }
+
+/*----------------------------------------------------------------------
+                       Public Symbol Manipulation
+----------------------------------------------------------------------*/
+public      :
+
+    BOOL SymEnumerateSymbols (IN DWORD                        BaseOfDll,
+                              IN PSYM_ENUMSYMBOLS_CALLBACK
+                                                    EnumSymbolsCallback,
+                              IN PVOID                     UserContext )
+    {
+        return ( ::SymEnumerateSymbols ( m_hProcess          ,
+                                         BaseOfDll           ,
+                                         EnumSymbolsCallback ,
+                                         UserContext          ) ) ;
+    }
+
+    BOOL SymGetSymFromAddr ( IN  DWORD               dwAddr          ,
+                             OUT PDWORD              pdwDisplacement ,
+                             OUT PIMAGEHLP_SYMBOL    Symbol           )
+    {
+        return ( ::SymGetSymFromAddr ( m_hProcess       ,
+                                       dwAddr           ,
+                                       pdwDisplacement  ,
+                                       Symbol            ) ) ;
+    }
+
+    BOOL SymGetSymFromName ( IN  LPSTR            Name   ,
+                             OUT PIMAGEHLP_SYMBOL Symbol  )
+    {
+        return ( ::SymGetSymFromName ( m_hProcess ,
+                                       Name       ,
+                                       Symbol      ) ) ;
+    }
+
+    BOOL SymGetSymNext ( IN OUT PIMAGEHLP_SYMBOL Symbol )
+    {
+        return ( ::SymGetSymNext ( m_hProcess , Symbol ) ) ;
+    }
+
+    BOOL SymGetSymPrev ( IN OUT PIMAGEHLP_SYMBOL Symbol )
+    {
+        return ( ::SymGetSymPrev ( m_hProcess , Symbol ) ) ;
+    }
+
+/*----------------------------------------------------------------------
+                    Public Source Line Manipulation
+----------------------------------------------------------------------*/
+public      :
+
+    BOOL SymGetLineFromAddr ( IN  DWORD          dwAddr          ,
+                              OUT PDWORD         pdwDisplacement ,
+                              OUT PIMAGEHLP_LINE Line             )
+    {
+
+#ifdef DO_NOT_WORK_AROUND_SRCLINE_BUG
+        // Just pass along the values returned by the main function.
+        return ( ::SymGetLineFromAddr ( m_hProcess      ,
+                                        dwAddr          ,
+                                        pdwDisplacement ,
+                                        Line             ) ) ;
+
+#else
+        // The problem is that the symbol engine finds only those source
+        // line addresses (after the first lookup) that fall exactly on
+        // a zero displacement. Ill walk backward 100 bytes to
+        // find the line and return the proper displacement.
+        DWORD dwTempDis = 0 ;
+        while ( FALSE == ::SymGetLineFromAddr ( m_hProcess          ,
+                                                dwAddr - dwTempDis  ,
+                                                pdwDisplacement     ,
+                                                Line                 ) )
+        {
+            dwTempDis += 1 ;
+            if ( 100 == dwTempDis )
+            {
+                return ( FALSE ) ;
+            }
+        }
+        // I found it and the source line information is correct, so
+        // change the displacement if I had to search backward to find
+        // the source line.
+        if ( 0 != dwTempDis )
+        {
+            *pdwDisplacement = dwTempDis ;
+        }
+        return ( TRUE ) ;
+#endif // DO_NOT_WORK_AROUND_SRCLINE_BUG
+    }
+
+    BOOL SymGetLineFromName ( IN     LPSTR          ModuleName      ,
+                              IN     LPSTR          FileName        ,
+                              IN     DWORD          dwLineNumber    ,
+                              OUT    PLONG          plDisplacement  ,
+                              IN OUT PIMAGEHLP_LINE Line             )
+    {
+        return ( ::SymGetLineFromName ( m_hProcess       ,
+                                        ModuleName       ,
+                                        FileName         ,
+                                        dwLineNumber     ,
+                                        plDisplacement   ,
+                                        Line              ) ) ;
+    }
+
+    BOOL SymGetLineNext ( IN OUT PIMAGEHLP_LINE Line )
+    {
+        return ( ::SymGetLineNext ( m_hProcess , Line ) ) ;
+    }
+
+    BOOL SymGetLinePrev ( IN OUT PIMAGEHLP_LINE Line )
+    {
+        return ( ::SymGetLinePrev ( m_hProcess , Line ) ) ;
+    }
+
+    BOOL SymMatchFileName ( IN  LPSTR   FileName        ,
+                            IN  LPSTR   Match           ,
+                            OUT LPSTR * FileNameStop    ,
+                            OUT LPSTR * MatchStop        )
+    {
+        return ( ::SymMatchFileName ( FileName       ,
+                                      Match          ,
+                                      FileNameStop   ,
+                                      MatchStop       ) ) ;
+    }
+
+/*----------------------------------------------------------------------
+                          Public Miscellaneous Members
+----------------------------------------------------------------------*/
+public      :
+
+    LPVOID SymFunctionTableAccess ( DWORD AddrBase )
+    {
+        return ( ::SymFunctionTableAccess ( m_hProcess , AddrBase ) ) ;
+    }
+
+    BOOL SymGetSearchPath ( OUT LPSTR SearchPath        ,
+                            IN  DWORD SearchPathLength   )
+    {
+        return ( ::SymGetSearchPath ( m_hProcess       ,
+                                      SearchPath       ,
+                                      SearchPathLength  ) ) ;
+    }
+
+    BOOL SymSetSearchPath ( IN LPSTR SearchPath )
+    {
+        return ( ::SymSetSearchPath ( m_hProcess , SearchPath ) ) ;
+    }
+
+    BOOL SymRegisterCallback ( IN PSYMBOL_REGISTERED_CALLBACK
+                                                       CallbackFunction,
+                               IN PVOID                UserContext    )
+    {
+        return ( ::SymRegisterCallback ( m_hProcess         ,
+                                         CallbackFunction   ,
+                                         UserContext         ) ) ;
+    }
+
+
+/*----------------------------------------------------------------------
+                         Protected Data Members
+----------------------------------------------------------------------*/
+protected   :
+    // The unique value that will be used for this instance of the
+    // symbol engine. This value doesnt have to be an actual
+    // process value, just a unique value.
+    HANDLE      m_hProcess      ;
+
+} ;
+
+#endif      // _SYMBOLENGINE_H
diff -urN CrashRpt-orig\crashrpt\src\Utility.cpp CrashRpt\crashrpt\src\Utility.cpp
--- CrashRpt-orig\crashrpt\src\Utility.cpp	Wed Mar 12 14:28:16 2003
+++ CrashRpt\crashrpt\src\Utility.cpp	Thu Apr 10 11:54:08 2003
@@ -13,6 +13,7 @@
 #include "atldlgs.h"
 #include "resource.h"
 
+namespace CUtility {
 
 FILETIME CUtility::getLastWriteFileTime(CString sFile)
 {
@@ -45,11 +46,12 @@
 
 CString CUtility::getTempFileName()
 {
+   static int counter = 0;
    TCHAR szTempDir[MAX_PATH - 14]   = _T("");
    TCHAR szTempFile[MAX_PATH]       = _T("");
 
    if (GetTempPath(MAX_PATH - 14, szTempDir))
-      GetTempFileName(szTempDir, getAppName(), 0, szTempFile);
+      GetTempFileName(szTempDir, getAppName(), ++counter, szTempFile);
 
    return szTempFile;
 }
@@ -74,3 +76,5 @@
 
    return _T("");
 }
+
+};
diff -urN CrashRpt-orig\crashrpt\src\Utility.h CrashRpt\crashrpt\src\Utility.h
--- CrashRpt-orig\crashrpt\src\Utility.h	Wed Mar 12 14:30:52 2003
+++ CrashRpt\crashrpt\src\Utility.h	Thu Apr 10 11:54:52 2003
@@ -26,9 +26,8 @@
 // 
 // See the module comment at top of file.
 //
-class CUtility  
+namespace CUtility 
 {
-public:
 
    //-----------------------------------------------------------------------------
    // getLastWriteFileTime
@@ -42,7 +41,6 @@
    //
    // Remarks
    //
-   static 
    FILETIME 
    getLastWriteFileTime(
       CString sFile
@@ -61,7 +59,6 @@
    // Remarks
    //    none
    //
-   static 
    CString 
    getAppName();
 
@@ -78,7 +75,6 @@
    // Remarks
    //    none
    //
-   static 
    CString 
    getSaveFileName();
 	
@@ -94,7 +90,6 @@
    //
    // Remarks
    //
-   static 
    CString 
    getTempFileName();
 };
diff -urN CrashRpt-orig\crashrpt\src\WriteRegistry.cpp CrashRpt\crashrpt\src\WriteRegistry.cpp
--- CrashRpt-orig\crashrpt\src\WriteRegistry.cpp	Wed Dec 31 19:00:00 1969
+++ CrashRpt\crashrpt\src\WriteRegistry.cpp	Thu Apr 10 11:54:12 2003
@@ -0,0 +1,247 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Module: WriteRegistry.cpp
+//
+//    Desc: Functions to write a registry hive to a file.
+//
+// Copyright (c) 2003 Grant McDorman
+// This file is licensed using a BSD-type license:
+//  This software is provided 'as-is', without any express or implied
+//  warranty.  In no event will the authors be held liable for any damages
+//  arising from the use of this software.
+//
+//  Permission is granted to anyone to use this software for any purpose,
+//  including commercial applications, and to alter it and redistribute it
+//  freely, subject to the following restrictions:
+//
+//  1. The origin of this software must not be misrepresented; you must not
+//     claim that you wrote the original software. If you use this software
+//     in a product, an acknowledgment in the product documentation would be
+//     appreciated but is not required.
+//  2. Altered source versions must be plainly marked as such, and must not be
+//     misrepresented as being the original software.
+//  3. This notice may not be removed or altered from any source distribution.
+//
+///////////////////////////////////////////////////////////////////////////////
+#include <StdAfx.h>
+
+#include <windows.h>    // CreateFile, WriteFile, CloseHandle, DeleteFile, Reg* functions
+#include <stdio.h>	    // _snprintf
+
+#include "WriteRegistry.h"
+
+static bool WriteRegValue(HANDLE hFile, const char *key_path, const char *name, int name_len, DWORD type, const unsigned char *data, DWORD data_len);
+static bool WriteValuesAndSubkeys(const char *key_path, HKEY parent_key, const char *subkey, HANDLE hFile);
+static void WriteFileString(HANDLE hFile, const char *string);
+
+bool WriteRegistryTreeToFile(const char *key, const char *filename)
+{
+	char *cp = strchr(key, '\\');
+	if (cp == NULL) {
+		return false;
+	}
+	int len = cp - key;
+	HKEY hKey = 0;
+
+#define IS_PATH(id, short_id) if (strncmp(key, #id, len) == 0 || strncmp(key, #short_id, len) == 0) hKey = id
+    IS_PATH(HKEY_CLASSES_ROOT, HKCR);
+    else IS_PATH(HKEY_CURRENT_USER, HKCU);
+    else IS_PATH(HKEY_LOCAL_MACHINE, HKLM);
+    else IS_PATH(HKEY_CURRENT_CONFIG, HKCC);
+    else IS_PATH(HKEY_USERS, HKU);
+    else IS_PATH(HKEY_PERFORMANCE_DATA, HKPD);
+    else IS_PATH(HKEY_DYN_DATA, HKDD);
+	else {
+		return false;
+	}
+	return WriteRegistryTreeToFile(hKey, cp + 1, filename);
+}
+
+bool WriteRegistryTreeToFile(HKEY section, const char *subkey, const char *filename)
+{
+    bool status = false;
+    HANDLE hFile = ::CreateFile(
+                                filename,
+                                GENERIC_READ | GENERIC_WRITE,
+                                FILE_SHARE_READ | FILE_SHARE_WRITE,
+                                NULL,
+                                CREATE_ALWAYS,
+                                FILE_ATTRIBUTE_NORMAL,
+                                0);
+    if (INVALID_HANDLE_VALUE != hFile) {
+		char * key_path = "UNKNOWN";
+#define SET_PATH(id) if (id == section) key_path = #id
+        SET_PATH(HKEY_CLASSES_ROOT);
+        else SET_PATH(HKEY_CURRENT_USER);
+        else SET_PATH(HKEY_LOCAL_MACHINE);
+        else SET_PATH(HKEY_CURRENT_CONFIG);
+        else SET_PATH(HKEY_USERS);
+        else SET_PATH(HKEY_PERFORMANCE_DATA);
+        else SET_PATH(HKEY_DYN_DATA);
+		WriteFileString(hFile, "REGEDIT4\r\n");
+#undef SET_PATH
+        try {
+            status = WriteValuesAndSubkeys(key_path, section, subkey, hFile);
+        } catch (...) {
+            status = false;
+        }
+        CloseHandle(hFile);
+        if (!status) {
+            DeleteFile(filename);
+        }
+	}
+    return status;
+}
+
+static bool WriteValuesAndSubkeys(const char *key_path, HKEY parent_key, const char *subkey, HANDLE hFile)
+{
+    HKEY key;
+
+    if (RegOpenKeyEx(parent_key, subkey, 0, KEY_READ, &key) != ERROR_SUCCESS) {
+		OutputDebugString("RegOpenKeyEx failed, key:\n");
+		OutputDebugString(subkey);
+        return false;
+    }
+    DWORD num_subkeys;
+    DWORD max_subkey_len;
+    DWORD num_values;
+    DWORD max_name_len;
+    DWORD max_value_len;
+    DWORD max_id_len;
+
+    if (RegQueryInfoKey(key,
+						NULL, // class
+						NULL, // num_class
+						NULL, // reserved
+                        &num_subkeys, &max_subkey_len,
+						NULL, // MaxClassLen
+						&num_values, &max_name_len, &max_value_len, NULL, NULL) != ERROR_SUCCESS) {
+		OutputDebugString("RegQueryInfoKey failed, key:\n");
+		OutputDebugString(subkey);
+        return false;
+    }
+
+    max_id_len = (max_name_len > max_subkey_len) ? max_name_len : max_subkey_len;
+    char *this_path = reinterpret_cast<char *>(alloca(strlen(key_path) + strlen(subkey) + 2));
+    // strcpy/strcat safe because of above alloca
+    strcpy(this_path, key_path);
+	strcat(this_path, "\\");
+    strcat(this_path, subkey);
+
+    WriteFileString(hFile, "\r\n[");
+    WriteFileString(hFile, this_path);
+    WriteFileString(hFile, "]\r\n");
+
+    // enumerate values
+    char *name = reinterpret_cast<char *>(alloca(max_id_len*2 + 2));
+    unsigned char *data = reinterpret_cast<unsigned char *>(alloca(max_value_len*2 + 2));
+    DWORD index;
+    bool status = true;
+
+    for (index = 0; index < num_values && status; index++) {
+        DWORD name_len = max_id_len + 1;
+        DWORD value_len = max_value_len + 1;
+	    DWORD type;
+        if (RegEnumValue(key, index, name, &name_len, NULL, &type, data, &value_len) == ERROR_SUCCESS) {
+            status = WriteRegValue(hFile, this_path, name, name_len, type, data, value_len);
+        }
+    }
+
+    // enumerate subkeys
+    for (index = 0; index < num_subkeys && status; index++) {
+        DWORD name_len = max_id_len + 1;
+        if (RegEnumKeyEx(key, index, name, &name_len, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
+            status = WriteValuesAndSubkeys(this_path, key, name, hFile);
+        }
+    }
+
+    RegCloseKey(key);
+
+    return status;
+}
+
+static bool WriteRegValue(HANDLE hFile, const char * /*key_path*/, const char *name, int /* name_len */, DWORD type, const unsigned char *data, DWORD data_len)
+{
+	WriteFileString(hFile, "\"");
+    WriteFileString(hFile, name);
+
+    char string_type[64];
+
+    switch(type) {
+     case REG_DWORD:  // A 32-bit number.
+        strncpy(string_type, "\"=dword:", sizeof string_type);
+        break;
+
+     case REG_SZ: // A null terminated string.
+        strncpy(string_type, "\"=\"", sizeof string_type);
+        break;
+
+     case REG_BINARY: // Binary data in any form.
+        strncpy(string_type, "\"=hex:", sizeof string_type);
+        break;
+
+     case REG_EXPAND_SZ: // A null-terminated string that contains unexpanded references to environment variables (for example, "%PATH%"). It will be a Unicode or ANSI string depending on whether you use the Unicode or ANSI functions. To expand the environment variable references, use the ExpandEnvironmentStrings function.
+     case REG_LINK: // A Unicode symbolic link. Used internally; applications should not use this type.
+     case REG_MULTI_SZ: // An array of null-terminated strings, terminated by two null characters. 
+     case REG_NONE: // No defined value type.
+     case REG_DWORD_BIG_ENDIAN: // A 64-bit number in big-endian format.
+     case REG_RESOURCE_LIST: // A device-driver resource list.
+     default:
+        _snprintf(string_type, sizeof string_type, "\"=hex(%x):", type);
+        break;
+    }
+
+    WriteFileString(hFile, string_type);
+
+    if (type == REG_SZ || type == REG_EXPAND_SZ) {
+        // escape special characters; length includes trailing NUL
+        int i;
+		// don't crash'n'burn if data_len is 0
+        for (i = 0; i < static_cast<int>(data_len) - 1; i++) {
+            if (data[i] == '\\' || data[i] == '"') {
+                WriteFileString(hFile, "\\");
+            }
+            if (isprint(data[i])) {
+				DWORD written;
+                if (!WriteFile(hFile, &data[i], 1, &written, NULL) || written != 1) {
+                    return false;
+                }
+            } else {
+                _snprintf(string_type, sizeof string_type, "\\%02x", data[i]);
+                WriteFileString(hFile, string_type);
+            }
+        }
+		WriteFileString(hFile, "\"");
+    } else if (type == REG_DWORD) {
+        // write as hex, MSB first
+        int i;
+        for (i = static_cast<int>(data_len) - 1; i >= 0; i--) {
+            _snprintf(string_type, sizeof string_type, "%02x", data[i]);
+            WriteFileString(hFile, string_type);
+        }
+    } else {
+        // write as comma-separated hex values
+        DWORD i;
+        for (i = 0; i < data_len; i++) {
+            _snprintf(string_type, sizeof string_type, "%s%02x", i > 0 ? "," : "", data[i]);
+            WriteFileString(hFile, string_type);
+            if (i > 0 && i % 16 == 0) {
+                WriteFileString(hFile, "\r\n");
+            }
+        }
+    }
+    WriteFileString(hFile, "\r\n");
+
+	return true;
+}
+
+                  
+                
+static void WriteFileString(HANDLE hFile, const char *string)
+{
+    DWORD written;
+    if (!WriteFile(hFile, string, strlen(string), &written, NULL) || written != strlen(string)) {
+		OutputDebugString("WriteFile failed\n");
+        throw false;
+    }
+}
diff -urN CrashRpt-orig\crashrpt\src\WriteRegistry.h CrashRpt\crashrpt\src\WriteRegistry.h
--- CrashRpt-orig\crashrpt\src\WriteRegistry.h	Wed Dec 31 19:00:00 1969
+++ CrashRpt\crashrpt\src\WriteRegistry.h	Thu Apr 10 11:54:56 2003
@@ -0,0 +1,86 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Module: WriteRegistry.h
+//
+//    Desc: Defines the interface for the WriteRegistry functions.
+//
+// Copyright (c) 2003 Grant McDorman
+// This file is licensed using a BSD-type license:
+//  This software is provided 'as-is', without any express or implied
+//  warranty.  In no event will the authors be held liable for any damages
+//  arising from the use of this software.
+//
+//  Permission is granted to anyone to use this software for any purpose,
+//  including commercial applications, and to alter it and redistribute it
+//  freely, subject to the following restrictions:
+//
+//  1. The origin of this software must not be misrepresented; you must not
+//     claim that you wrote the original software. If you use this software
+//     in a product, an acknowledgment in the product documentation would be
+//     appreciated but is not required.
+//  2. Altered source versions must be plainly marked as such, and must not be
+//     misrepresented as being the original software.
+//  3. This notice may not be removed or altered from any source distribution.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WRITEREGISTRY_H_
+#define _WRITEREGISTRY_H_
+
+#if _MSC_VER >= 1000
+#pragma once
+#endif // _MSC_VER >= 1000
+
+
+//-----------------------------------------------------------------------------
+// WriteRegistryTreeToFile
+//    Writes a registry tree to a file. Registry tree is fully specified by
+//    the string.
+//
+// Parameters
+//    key     registry key name; must start with on of:
+//                HKEY_CLASSES_ROOT or HKCR
+//                HKEY_CURRENT_USER or HKCU
+//                HKEY_LOCAL_MACHINE or HKLM
+//                HKEY_CURRENT_CONFIG or HKCC
+//                HKEY_USERS or HKU
+//                HKEY_PERFORMANCE_DATA or HKPD
+//                HKEY_DYN_DATA or HKDD
+//   filename file to write to
+//
+// Return Values
+//    Returns true if successful.
+//
+// Remarks
+//    Translates call into WriteRegistryTreeToFile(section, subkey, filename).
+//
+bool WriteRegistryTreeToFile(const char *key, const char *filename);
+
+
+//-----------------------------------------------------------------------------
+// WriteRegistryTreeToFile
+//    Writes a registry tree to a file. Registry tree is relative to given key,
+//    which must be one of the root keys.
+//
+// Parameters
+//    section registry section; must be one of
+//                HKEY_CLASSES_ROOT
+//                HKEY_CURRENT_USER
+//                HKEY_LOCAL_MACHINE
+//                HKEY_CURRENT_CONFIG
+//                HKEY_USERS
+//                HKEY_PERFORMANCE_DATA
+//                HKEY_DYN_DATA
+//   subkey   subkey relative to section
+//   filename file to write to
+//
+// Return Values
+//    Returns true if successful.
+//
+// Remarks
+//    none
+//
+bool WriteRegistryTreeToFile(HKEY section, const char *subkey, const char *filename);
+  
+
+#endif
diff -urN CrashRpt-orig\crashrpt\src\zconf.h CrashRpt\crashrpt\src\zconf.h
--- CrashRpt-orig\crashrpt\src\zconf.h	Tue Mar 04 08:37:42 2003
+++ CrashRpt\crashrpt\src\zconf.h	Wed Dec 31 19:00:00 1969
@@ -1,279 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-1998 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-/* @(#) $Id: unix-unified-diff.txt,v 1.1 2005-03-02 17:56:35 andcycle Exp $ */
-
-#ifndef _ZCONF_H
-#define _ZCONF_H
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- */
-#ifdef Z_PREFIX
-#  define deflateInit_	z_deflateInit_
-#  define deflate	z_deflate
-#  define deflateEnd	z_deflateEnd
-#  define inflateInit_ 	z_inflateInit_
-#  define inflate	z_inflate
-#  define inflateEnd	z_inflateEnd
-#  define deflateInit2_	z_deflateInit2_
-#  define deflateSetDictionary z_deflateSetDictionary
-#  define deflateCopy	z_deflateCopy
-#  define deflateReset	z_deflateReset
-#  define deflateParams	z_deflateParams
-#  define inflateInit2_	z_inflateInit2_
-#  define inflateSetDictionary z_inflateSetDictionary
-#  define inflateSync	z_inflateSync
-#  define inflateSyncPoint z_inflateSyncPoint
-#  define inflateReset	z_inflateReset
-#  define compress	z_compress
-#  define compress2	z_compress2
-#  define uncompress	z_uncompress
-#  define adler32	z_adler32
-#  define crc32		z_crc32
-#  define get_crc_table z_get_crc_table
-
-#  define Byte		z_Byte
-#  define uInt		z_uInt
-#  define uLong		z_uLong
-#  define Bytef	        z_Bytef
-#  define charf		z_charf
-#  define intf		z_intf
-#  define uIntf		z_uIntf
-#  define uLongf	z_uLongf
-#  define voidpf	z_voidpf
-#  define voidp		z_voidp
-#endif
-
-#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
-#  define WIN32
-#endif
-#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
-#  ifndef __32BIT__
-#    define __32BIT__
-#  endif
-#endif
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#if defined(MSDOS) && !defined(__32BIT__)
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
-#  define STDC
-#endif
-#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
-#  ifndef STDC
-#    define STDC
-#  endif
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const
-#  endif
-#endif
-
-/* Some Mac compilers merge all .h files incorrectly: */
-#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
-#  define NO_DUMMY_DECL
-#endif
-
-/* Old Borland C incorrectly complains about missing returns: */
-#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
-#  define NEED_DUMMY_RETURN
-#endif
-
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus a few kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
-   /* MSC small or medium model */
-#  define SMALL_MEDIUM
-#  ifdef _MSC_VER
-#    define FAR _far
-#  else
-#    define FAR far
-#  endif
-#endif
-#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
-#  ifndef __32BIT__
-#    define SMALL_MEDIUM
-#    define FAR _far
-#  endif
-#endif
-
-/* Compile with -DZLIB_DLL for Windows DLL support */
-#if defined(ZLIB_DLL)
-#  if defined(_WINDOWS) || defined(WINDOWS)
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-#    define ZEXPORT  WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA  WINAPIV
-#    else
-#      define ZEXPORTVA  FAR _cdecl _export
-#    endif
-#  endif
-#  if defined (__BORLANDC__)
-#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
-#      include <windows.h>
-#      define ZEXPORT __declspec(dllexport) WINAPI
-#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
-#    else
-#      if defined (_Windows) && defined (__DLL__)
-#        define ZEXPORT _export
-#        define ZEXPORTVA _export
-#      endif
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  if defined (ZLIB_DLL)
-#    define ZEXTERN extern __declspec(dllexport)
-#  else
-#    define ZEXTERN extern __declspec(dllimport)
-#  endif
-#endif
-
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-
-#ifndef FAR
-#   define FAR
-#endif
-
-#if !defined(MACOS) && !defined(TARGET_OS_MAC)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void FAR *voidpf;
-   typedef void     *voidp;
-#else
-   typedef Byte FAR *voidpf;
-   typedef Byte     *voidp;
-#endif
-
-#ifdef HAVE_UNISTD_H
-#  include <sys/types.h> /* for off_t */
-#  include <unistd.h>    /* for SEEK_* and off_t */
-#  define z_off_t  off_t
-#endif
-#ifndef SEEK_SET
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-#ifndef z_off_t
-#  define  z_off_t long
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-#   pragma map(deflateInit_,"DEIN")
-#   pragma map(deflateInit2_,"DEIN2")
-#   pragma map(deflateEnd,"DEEND")
-#   pragma map(inflateInit_,"ININ")
-#   pragma map(inflateInit2_,"ININ2")
-#   pragma map(inflateEnd,"INEND")
-#   pragma map(inflateSync,"INSY")
-#   pragma map(inflateSetDictionary,"INSEDI")
-#   pragma map(inflate_blocks,"INBL")
-#   pragma map(inflate_blocks_new,"INBLNE")
-#   pragma map(inflate_blocks_free,"INBLFR")
-#   pragma map(inflate_blocks_reset,"INBLRE")
-#   pragma map(inflate_codes_free,"INCOFR")
-#   pragma map(inflate_codes,"INCO")
-#   pragma map(inflate_fast,"INFA")
-#   pragma map(inflate_flush,"INFLU")
-#   pragma map(inflate_mask,"INMA")
-#   pragma map(inflate_set_dictionary,"INSEDI2")
-#   pragma map(inflate_copyright,"INCOPY")
-#   pragma map(inflate_trees_bits,"INTRBI")
-#   pragma map(inflate_trees_dynamic,"INTRDY")
-#   pragma map(inflate_trees_fixed,"INTRFI")
-#   pragma map(inflate_trees_free,"INTRFR")
-#endif
-
-#endif /* _ZCONF_H */
diff -urN CrashRpt-orig\crashrpt\src\zip.h CrashRpt\crashrpt\src\zip.h
--- CrashRpt-orig\crashrpt\src\zip.h	Thu Mar 19 01:15:00 1998
+++ CrashRpt\crashrpt\src\zip.h	Wed Dec 31 19:00:00 1969
@@ -1,150 +0,0 @@
-/* zip.h -- IO for compress .zip files using zlib 
-   Version 0.15 alpha, Mar 19th, 1998,
-
-   Copyright (C) 1998 Gilles Vollant
-
-   This unzip package allow creates .ZIP file, compatible with PKZip 2.04g
-     WinZip, InfoZip tools and compatible.
-   Encryption and multi volume ZipFile (span) are not supported.
-   Old compressions used by old PKZip 1.x are not supported
-
-  For uncompress .zip file, look at unzip.h
-
-   THIS IS AN ALPHA VERSION. AT THIS STAGE OF DEVELOPPEMENT, SOMES API OR STRUCTURE
-   CAN CHANGE IN FUTURE VERSION !!
-   I WAIT FEEDBACK at mail info@winimage.com
-   Visit also http://www.winimage.com/zLibDll/zip.htm for evolution
-
-   Condition of use and distribution are the same than zlib :
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-
-*/
-
-/* for more info about .ZIP format, see 
-      ftp://ftp.cdrom.com/pub/infozip/doc/appnote-970311-iz.zip
-   PkWare has also a specification at :
-      ftp://ftp.pkware.com/probdesc.zip
-*/
-
-#ifndef _zip_H
-#define _zip_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#if defined(STRICTZIP) || defined(STRICTZIPUNZIP)
-/* like the STRICT of WIN32, we define a pointer that cannot be converted
-    from (void*) without cast */
-typedef struct TagzipFile__ { int unused; } zipFile__; 
-typedef zipFile__ *zipFile;
-#else
-typedef voidp zipFile;
-#endif
-
-#define ZIP_OK                                  (0)
-#define ZIP_ERRNO               (Z_ERRNO)
-#define ZIP_PARAMERROR                  (-102)
-#define ZIP_INTERNALERROR               (-104)
-
-/* tm_zip contain date/time info */
-typedef struct tm_zip_s 
-{
-	uInt tm_sec;            /* seconds after the minute - [0,59] */
-	uInt tm_min;            /* minutes after the hour - [0,59] */
-	uInt tm_hour;           /* hours since midnight - [0,23] */
-	uInt tm_mday;           /* day of the month - [1,31] */
-	uInt tm_mon;            /* months since January - [0,11] */
-	uInt tm_year;           /* years - [1980..2044] */
-} tm_zip;
-
-typedef struct
-{
-	tm_zip      tmz_date;       /* date in understandable format           */
-    uLong       dosDate;       /* if dos_date == 0, tmu_date is used      */
-/*    uLong       flag;        */   /* general purpose bit flag        2 bytes */
-
-    uLong       internal_fa;    /* internal file attributes        2 bytes */
-    uLong       external_fa;    /* external file attributes        4 bytes */
-} zip_fileinfo;
-
-extern zipFile ZEXPORT zipOpen OF((const char *pathname, int append));
-/*
-  Create a zipfile.
-	 pathname contain on Windows NT a filename like "c:\\zlib\\zlib111.zip" or on
-	   an Unix computer "zlib/zlib111.zip".
-	 if the file pathname exist and append=1, the zip will be created at the end
-	   of the file. (useful if the file contain a self extractor code)
-	 If the zipfile cannot be opened, the return value is NULL.
-     Else, the return value is a zipFile Handle, usable with other function
-	   of this zip package.
-
-
-*/
-
-extern int ZEXPORT zipOpenNewFileInZip OF((zipFile file,
-					   const char* filename,
-					   const zip_fileinfo* zipfi,
-					   const void* extrafield_local,
-					   uInt size_extrafield_local,
-					   const void* extrafield_global,
-					   uInt size_extrafield_global,
-					   const char* comment,
-					   int method,
-					   int level));
-/*
-  Open a file in the ZIP for writing.
-  filename : the filename in zip (if NULL, '-' without quote will be used
-  *zipfi contain supplemental information
-  if extrafield_local!=NULL and size_extrafield_local>0, extrafield_local
-    contains the extrafield data the the local header
-  if extrafield_global!=NULL and size_extrafield_global>0, extrafield_global
-    contains the extrafield data the the local header
-  if comment != NULL, comment contain the comment string
-  method contain the compression method (0 for store, Z_DEFLATED for deflate)
-  level contain the level of compression (can be Z_DEFAULT_COMPRESSION)
-*/
-
-extern int ZEXPORT zipWriteInFileInZip OF((zipFile file,
-					   const voidp buf,
-					   unsigned len));
-/*
-  Write data in the zipfile
-*/
-
-extern int ZEXPORT zipCloseFileInZip OF((zipFile file));
-/*
-  Close the current file in the zipfile
-*/
-
-extern int ZEXPORT zipClose OF((zipFile file,
-				const char* global_comment));
-/*
-  Close the zipfile
-*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _zip_H */
diff -urN CrashRpt-orig\crashrpt\src\zlib.h CrashRpt\crashrpt\src\zlib.h
--- CrashRpt-orig\crashrpt\src\zlib.h	Thu Jul 09 18:06:56 1998
+++ CrashRpt\crashrpt\src\zlib.h	Wed Dec 31 19:00:00 1969
@@ -1,893 +0,0 @@
-/* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.1.3, July 9th, 1998
-
-  Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-
-  The data format used by the zlib library is described by RFCs (Request for
-  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
-  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
-*/
-
-#ifndef _ZLIB_H
-#define _ZLIB_H
-
-#include "zconf.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define ZLIB_VERSION "1.1.3"
-
-/* 
-     The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed
-  data.  This version of the library supports only one compression method
-  (deflation) but other algorithms will be added later and will have the same
-  stream interface.
-
-     Compression can be done in a single step if the buffers are large
-  enough (for example if an input file is mmap'ed), or can be done by
-  repeated calls of the compression function.  In the latter case, the
-  application must provide more input and/or consume the output
-  (providing more output space) before each call.
-
-     The library also supports reading and writing files in gzip (.gz) format
-  with an interface similar to that of stdio.
-
-     The library does not install any signal handler. The decoder checks
-  the consistency of the compressed data, so the library should never
-  crash even in case of corrupted input.
-*/
-
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
-
-struct internal_state;
-
-typedef struct z_stream_s {
-    Bytef    *next_in;  /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total nb of input bytes read so far */
-
-    Bytef    *next_out; /* next output byte should be put there */
-    uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total nb of bytes output so far */
-
-    char     *msg;      /* last error message, NULL if no error */
-    struct internal_state FAR *state; /* not visible by applications */
-
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    voidpf     opaque;  /* private data object passed to zalloc and zfree */
-
-    int     data_type;  /* best guess about the data type: ascii or binary */
-    uLong   adler;      /* adler32 value of the uncompressed data */
-    uLong   reserved;   /* reserved for future use */
-} z_stream;
-
-typedef z_stream FAR *z_streamp;
-
-/*
-   The application must update next_in and avail_in when avail_in has
-   dropped to zero. It must update next_out and avail_out when avail_out
-   has dropped to zero. The application must initialize zalloc, zfree and
-   opaque before calling the init function. All other fields are set by the
-   compression library and must not be updated by the application.
-
-   The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree. This can be useful for custom
-   memory management. The compression library attaches no meaning to the
-   opaque value.
-
-   zalloc must return Z_NULL if there is not enough memory for the object.
-   If zlib is used in a multi-threaded application, zalloc and zfree must be
-   thread safe.
-
-   On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this
-   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
-   pointers returned by zalloc for objects of exactly 65536 bytes *must*
-   have their offset normalized to zero. The default allocation function
-   provided by this library ensures this (see zutil.c). To reduce memory
-   requirements and avoid any allocation of 64K objects, at the expense of
-   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
-
-   The fields total_in and total_out can be used for statistics or
-   progress reports. After compression, total_in holds the total size of
-   the uncompressed data and may be saved for use in the decompressor
-   (particularly if the decompressor wants to decompress everything in
-   a single step).
-*/
-
-                        /* constants */
-
-#define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
-#define Z_SYNC_FLUSH    2
-#define Z_FULL_FLUSH    3
-#define Z_FINISH        4
-/* Allowed flush values; see deflate() below for details */
-
-#define Z_OK            0
-#define Z_STREAM_END    1
-#define Z_NEED_DICT     2
-#define Z_ERRNO        (-1)
-#define Z_STREAM_ERROR (-2)
-#define Z_DATA_ERROR   (-3)
-#define Z_MEM_ERROR    (-4)
-#define Z_BUF_ERROR    (-5)
-#define Z_VERSION_ERROR (-6)
-/* Return codes for the compression/decompression functions. Negative
- * values are errors, positive values are used for special but normal events.
- */
-
-#define Z_NO_COMPRESSION         0
-#define Z_BEST_SPEED             1
-#define Z_BEST_COMPRESSION       9
-#define Z_DEFAULT_COMPRESSION  (-1)
-/* compression levels */
-
-#define Z_FILTERED            1
-#define Z_HUFFMAN_ONLY        2
-#define Z_DEFAULT_STRATEGY    0
-/* compression strategy; see deflateInit2() below for details */
-
-#define Z_BINARY   0
-#define Z_ASCII    1
-#define Z_UNKNOWN  2
-/* Possible values of the data_type field */
-
-#define Z_DEFLATED   8
-/* The deflate compression method (the only one supported in this version) */
-
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-
-#define zlib_version zlibVersion()
-/* for compatibility with versions < 1.0.2 */
-
-                        /* basic functions */
-
-ZEXTERN const char * ZEXPORT zlibVersion OF((void));
-/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is
-   not compatible with the zlib.h header file used by the application.
-   This check is automatically made by deflateInit and inflateInit.
- */
-
-/* 
-ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
-
-     Initializes the internal stream state for compression. The fields
-   zalloc, zfree and opaque must be initialized before by the caller.
-   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
-   use default allocation functions.
-
-     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
-   1 gives best speed, 9 gives best compression, 0 gives no compression at
-   all (the input data is simply copied a block at a time).
-   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
-   compression (currently equivalent to level 6).
-
-     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
-   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
-   with the version assumed by the caller (ZLIB_VERSION).
-   msg is set to null if there is no error message.  deflateInit does not
-   perform any compression: this will be done by deflate().
-*/
-
-
-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
-/*
-    deflate compresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full. It may introduce some
-  output latency (reading input without producing any output) except when
-  forced to flush.
-
-    The detailed semantics are as follows. deflate performs one or both of the
-  following actions:
-
-  - Compress more input starting at next_in and update next_in and avail_in
-    accordingly. If not all input can be processed (because there is not
-    enough room in the output buffer), next_in and avail_in are updated and
-    processing will resume at this point for the next call of deflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly. This action is forced if the parameter flush is non zero.
-    Forcing flush frequently degrades the compression ratio, so this parameter
-    should be set only when necessary (in interactive applications).
-    Some output may be provided even if flush is not set.
-
-  Before the call of deflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming
-  more output, and updating avail_in or avail_out accordingly; avail_out
-  should never be zero before the call. The application can consume the
-  compressed output when it wants, for example when the output buffer is full
-  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
-  and with zero avail_out, it must be called again after making room in the
-  output buffer because there might be more output pending.
-
-    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
-  flushed to the output buffer and the output is aligned on a byte boundary, so
-  that the decompressor can get all input data available so far. (In particular
-  avail_in is zero after the call if enough output space has been provided
-  before the call.)  Flushing may degrade compression for some compression
-  algorithms and so it should be used only when necessary.
-
-    If flush is set to Z_FULL_FLUSH, all output is flushed as with
-  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
-  restart from this point if previous compressed data has been damaged or if
-  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
-  the compression.
-
-    If deflate returns with avail_out == 0, this function must be called again
-  with the same value of the flush parameter and more output space (updated
-  avail_out), until the flush is complete (deflate returns with non-zero
-  avail_out).
-
-    If the parameter flush is set to Z_FINISH, pending input is processed,
-  pending output is flushed and deflate returns with Z_STREAM_END if there
-  was enough output space; if deflate returns with Z_OK, this function must be
-  called again with Z_FINISH and more output space (updated avail_out) but no
-  more input data, until it returns with Z_STREAM_END or an error. After
-  deflate has returned Z_STREAM_END, the only possible operations on the
-  stream are deflateReset or deflateEnd.
-  
-    Z_FINISH can be used immediately after deflateInit if all the compression
-  is to be done in a single step. In this case, avail_out must be at least
-  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
-  Z_STREAM_END, then it must be called again as described above.
-
-    deflate() sets strm->adler to the adler32 checksum of all input read
-  so far (that is, total_in bytes).
-
-    deflate() may update data_type if it can make a good guess about
-  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
-  binary. This field is only for information purposes and does not affect
-  the compression algorithm in any manner.
-
-    deflate() returns Z_OK if some progress has been made (more input
-  processed or more output produced), Z_STREAM_END if all input has been
-  consumed and all output has been produced (only when flush is set to
-  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
-  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
-  (for example avail_in or avail_out was zero).
-*/
-
-
-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any
-   pending output.
-
-     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
-   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
-   prematurely (some input or output was discarded). In the error case,
-   msg may be set but then points to a static string (which must not be
-   deallocated).
-*/
-
-
-/* 
-ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
-
-     Initializes the internal stream state for decompression. The fields
-   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
-   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
-   value depends on the compression method), inflateInit determines the
-   compression method from the zlib header and allocates all data structures
-   accordingly; otherwise the allocation will be deferred to the first call of
-   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
-   use default allocation functions.
-
-     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller.  msg is set to null if there is no error
-   message. inflateInit does not perform any decompression apart from reading
-   the zlib header if present: this will be done by inflate().  (So next_in and
-   avail_in may be modified, but next_out and avail_out are unchanged.)
-*/
-
-
-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
-/*
-    inflate decompresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full. It may some
-  introduce some output latency (reading input without producing any output)
-  except when forced to flush.
-
-  The detailed semantics are as follows. inflate performs one or both of the
-  following actions:
-
-  - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly. If not all input can be processed (because there is not
-    enough room in the output buffer), next_in is updated and processing
-    will resume at this point for the next call of inflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() provides as much output as possible, until there
-    is no more input data or no more space in the output buffer (see below
-    about the flush parameter).
-
-  Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming
-  more output, and updating the next_* and avail_* values accordingly.
-  The application can consume the uncompressed output when it wants, for
-  example when the output buffer is full (avail_out == 0), or after each
-  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
-  must be called again after making room in the output buffer because there
-  might be more output pending.
-
-    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
-  output as possible to the output buffer. The flushing behavior of inflate is
-  not specified for values of the flush parameter other than Z_SYNC_FLUSH
-  and Z_FINISH, but the current implementation actually flushes as much output
-  as possible anyway.
-
-    inflate() should normally be called until it returns Z_STREAM_END or an
-  error. However if all decompression is to be performed in a single step
-  (a single call of inflate), the parameter flush should be set to
-  Z_FINISH. In this case all pending input is processed and all pending
-  output is flushed; avail_out must be large enough to hold all the
-  uncompressed data. (The size of the uncompressed data may have been saved
-  by the compressor for this purpose.) The next operation on this stream must
-  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
-  is never required, but can be used to inform inflate that a faster routine
-  may be used for the single inflate() call.
-
-     If a preset dictionary is needed at this point (see inflateSetDictionary
-  below), inflate sets strm-adler to the adler32 checksum of the
-  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
-  it sets strm->adler to the adler32 checksum of all output produced
-  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
-  an error code as described below. At the end of the stream, inflate()
-  checks that its computed adler32 checksum is equal to that saved by the
-  compressor and returns Z_STREAM_END only if the checksum is correct.
-
-    inflate() returns Z_OK if some progress has been made (more input processed
-  or more output produced), Z_STREAM_END if the end of the compressed data has
-  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
-  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
-  corrupted (input stream not conforming to the zlib format or incorrect
-  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
-  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
-  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
-  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
-  case, the application may then call inflateSync to look for a good
-  compression block.
-*/
-
-
-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any
-   pending output.
-
-     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
-   was inconsistent. In the error case, msg may be set but then points to a
-   static string (which must not be deallocated).
-*/
-
-                        /* Advanced functions */
-
-/*
-    The following functions are needed only in some special applications.
-*/
-
-/*   
-ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
-                                     int  level,
-                                     int  method,
-                                     int  windowBits,
-                                     int  memLevel,
-                                     int  strategy));
-
-     This is another version of deflateInit with more compression options. The
-   fields next_in, zalloc, zfree and opaque must be initialized before by
-   the caller.
-
-     The method parameter is the compression method. It must be Z_DEFLATED in
-   this version of the library.
-
-     The windowBits parameter is the base two logarithm of the window size
-   (the size of the history buffer).  It should be in the range 8..15 for this
-   version of the library. Larger values of this parameter result in better
-   compression at the expense of memory usage. The default value is 15 if
-   deflateInit is used instead.
-
-     The memLevel parameter specifies how much memory should be allocated
-   for the internal compression state. memLevel=1 uses minimum memory but
-   is slow and reduces compression ratio; memLevel=9 uses maximum memory
-   for optimal speed. The default value is 8. See zconf.h for total memory
-   usage as a function of windowBits and memLevel.
-
-     The strategy parameter is used to tune the compression algorithm. Use the
-   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
-   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
-   string match).  Filtered data consists mostly of small values with a
-   somewhat random distribution. In this case, the compression algorithm is
-   tuned to compress them better. The effect of Z_FILTERED is to force more
-   Huffman coding and less string matching; it is somewhat intermediate
-   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
-   the compression ratio but not the correctness of the compressed output even
-   if it is not set appropriately.
-
-      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
-   method). msg is set to null if there is no error message.  deflateInit2 does
-   not perform any compression: this will be done by deflate().
-*/
-                            
-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the compression dictionary from the given byte sequence
-   without producing any compressed output. This function must be called
-   immediately after deflateInit, deflateInit2 or deflateReset, before any
-   call of deflate. The compressor and decompressor must use exactly the same
-   dictionary (see inflateSetDictionary).
-
-     The dictionary should consist of strings (byte sequences) that are likely
-   to be encountered later in the data to be compressed, with the most commonly
-   used strings preferably put towards the end of the dictionary. Using a
-   dictionary is most useful when the data to be compressed is short and can be
-   predicted with good accuracy; the data can then be compressed better than
-   with the default empty dictionary.
-
-     Depending on the size of the compression data structures selected by
-   deflateInit or deflateInit2, a part of the dictionary may in effect be
-   discarded, for example if the dictionary is larger than the window size in
-   deflate or deflate2. Thus the strings most likely to be useful should be
-   put at the end of the dictionary, not at the front.
-
-     Upon return of this function, strm->adler is set to the Adler32 value
-   of the dictionary; the decompressor may later use this value to determine
-   which dictionary has been used by the compressor. (The Adler32 value
-   applies to the whole dictionary even if only a subset of the dictionary is
-   actually used by the compressor.)
-
-     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
-   parameter is invalid (such as NULL dictionary) or the stream state is
-   inconsistent (for example if deflate has already been called for this stream
-   or if the compression method is bsort). deflateSetDictionary does not
-   perform any compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when several compression strategies will be
-   tried, for example when there are several ways of pre-processing the input
-   data with a filter. The streams that will be discarded should then be freed
-   by calling deflateEnd.  Note that deflateCopy duplicates the internal
-   compression state which can be quite large, so this strategy is slow and
-   can consume lots of memory.
-
-     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being NULL). msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to deflateEnd followed by deflateInit,
-   but does not free and reallocate all the internal compression state.
-   The stream will keep the same compression level and any other attributes
-   that may have been set by deflateInit2.
-
-      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being NULL).
-*/
-
-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
-				      int level,
-				      int strategy));
-/*
-     Dynamically update the compression level and compression strategy.  The
-   interpretation of level and strategy is as in deflateInit2.  This can be
-   used to switch between compression and straight copy of the input data, or
-   to switch to a different kind of input data requiring a different
-   strategy. If the compression level is changed, the input available so far
-   is compressed with the old level (and may be flushed); the new level will
-   take effect only at the next call of deflate().
-
-     Before the call of deflateParams, the stream state must be set as for
-   a call of deflate(), since the currently available input may have to
-   be compressed and flushed. In particular, strm->avail_out must be non-zero.
-
-     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
-   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
-   if strm->avail_out was zero.
-*/
-
-/*   
-ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
-                                     int  windowBits));
-
-     This is another version of inflateInit with an extra parameter. The
-   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
-   before by the caller.
-
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library. The default value is 15 if inflateInit is used
-   instead. If a compressed stream with a larger window size is given as
-   input, inflate() will return with the error code Z_DATA_ERROR instead of
-   trying to allocate a larger window.
-
-      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
-   memLevel). msg is set to null if there is no error message.  inflateInit2
-   does not perform any decompression apart from reading the zlib header if
-   present: this will be done by inflate(). (So next_in and avail_in may be
-   modified, but next_out and avail_out are unchanged.)
-*/
-
-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the decompression dictionary from the given uncompressed byte
-   sequence. This function must be called immediately after a call of inflate
-   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
-   can be determined from the Adler32 value returned by this call of
-   inflate. The compressor and decompressor must use exactly the same
-   dictionary (see deflateSetDictionary).
-
-     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
-   parameter is invalid (such as NULL dictionary) or the stream state is
-   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
-   expected one (incorrect Adler32 value). inflateSetDictionary does not
-   perform any decompression: this will be done by subsequent calls of
-   inflate().
-*/
-
-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
-/* 
-    Skips invalid compressed data until a full flush point (see above the
-  description of deflate with Z_FULL_FLUSH) can be found, or until all
-  available input is skipped. No output is provided.
-
-    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
-  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
-  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
-  case, the application may save the current current value of total_in which
-  indicates where valid compressed data was found. In the error case, the
-  application may repeatedly call inflateSync, providing more input each time,
-  until success or end of the input data.
-*/
-
-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate all the internal decompression state.
-   The stream will keep attributes that may have been set by inflateInit2.
-
-      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being NULL).
-*/
-
-
-                        /* utility functions */
-
-/*
-     The following utility functions are implemented on top of the
-   basic stream-oriented functions. To simplify the interface, some
-   default options are assumed (compression level and memory usage,
-   standard memory allocation functions). The source code of these
-   utility functions can easily be modified if you need special options.
-*/
-
-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
-                                 const Bytef *source, uLong sourceLen));
-/*
-     Compresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be at least 0.1% larger than
-   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
-   compressed buffer.
-     This function can be used to compress a whole file at once if the
-   input file is mmap'ed.
-     compress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer.
-*/
-
-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
-                                  const Bytef *source, uLong sourceLen,
-                                  int level));
-/*
-     Compresses the source buffer into the destination buffer. The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer. Upon entry, destLen is the total size of the
-   destination buffer, which must be at least 0.1% larger than sourceLen plus
-   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-
-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
-                                   const Bytef *source, uLong sourceLen));
-/*
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be large enough to hold the
-   entire uncompressed data. (The size of the uncompressed data must have
-   been saved previously by the compressor and transmitted to the decompressor
-   by some mechanism outside the scope of this compression library.)
-   Upon exit, destLen is the actual size of the compressed buffer.
-     This function can be used to decompress a whole file at once if the
-   input file is mmap'ed.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted.
-*/
-
-
-typedef voidp gzFile;
-
-ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
-/*
-     Opens a gzip (.gz) file for reading or writing. The mode parameter
-   is as in fopen ("rb" or "wb") but can also include a compression level
-   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
-   Huffman only compression as in "wb1h". (See the description
-   of deflateInit2 for more information about the strategy parameter.)
-
-     gzopen can be used to read a file which is not in gzip format; in this
-   case gzread will directly read from the file without decompression.
-
-     gzopen returns NULL if the file could not be opened or if there was
-   insufficient memory to allocate the (de)compression state; errno
-   can be checked to distinguish the two cases (if errno is zero, the
-   zlib error is Z_MEM_ERROR).  */
-
-ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
-/*
-     gzdopen() associates a gzFile with the file descriptor fd.  File
-   descriptors are obtained from calls like open, dup, creat, pipe or
-   fileno (in the file has been previously opened with fopen).
-   The mode parameter is as in gzopen.
-     The next call of gzclose on the returned gzFile will also close the
-   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
-   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
-     gzdopen returns NULL if there was insufficient memory to allocate
-   the (de)compression state.
-*/
-
-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
-/*
-     Dynamically update the compression level or strategy. See the description
-   of deflateInit2 for the meaning of these parameters.
-     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
-   opened for writing.
-*/
-
-ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
-/*
-     Reads the given number of uncompressed bytes from the compressed file.
-   If the input file was not in gzip format, gzread copies the given number
-   of bytes into the buffer.
-     gzread returns the number of uncompressed bytes actually read (0 for
-   end of file, -1 for error). */
-
-ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
-				   const voidp buf, unsigned len));
-/*
-     Writes the given number of uncompressed bytes into the compressed file.
-   gzwrite returns the number of uncompressed bytes actually written
-   (0 in case of error).
-*/
-
-ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
-/*
-     Converts, formats, and writes the args to the compressed file under
-   control of the format string, as in fprintf. gzprintf returns the number of
-   uncompressed bytes actually written (0 in case of error).
-*/
-
-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
-/*
-      Writes the given null-terminated string to the compressed file, excluding
-   the terminating null character.
-      gzputs returns the number of characters written, or -1 in case of error.
-*/
-
-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
-/*
-      Reads bytes from the compressed file until len-1 characters are read, or
-   a newline character is read and transferred to buf, or an end-of-file
-   condition is encountered.  The string is then terminated with a null
-   character.
-      gzgets returns buf, or Z_NULL in case of error.
-*/
-
-ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
-/*
-      Writes c, converted to an unsigned char, into the compressed file.
-   gzputc returns the value that was written, or -1 in case of error.
-*/
-
-ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
-/*
-      Reads one byte from the compressed file. gzgetc returns this byte
-   or -1 in case of end of file or error.
-*/
-
-ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
-/*
-     Flushes all pending output into the compressed file. The parameter
-   flush is as in the deflate() function. The return value is the zlib
-   error number (see function gzerror below). gzflush returns Z_OK if
-   the flush parameter is Z_FINISH and all output could be flushed.
-     gzflush should be called only when strictly necessary because it can
-   degrade compression.
-*/
-
-ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
-				      z_off_t offset, int whence));
-/* 
-      Sets the starting position for the next gzread or gzwrite on the
-   given compressed file. The offset represents a number of bytes in the
-   uncompressed data stream. The whence parameter is defined as in lseek(2);
-   the value SEEK_END is not supported.
-     If the file is opened for reading, this function is emulated but can be
-   extremely slow. If the file is opened for writing, only forward seeks are
-   supported; gzseek then compresses a sequence of zeroes up to the new
-   starting position.
-
-      gzseek returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error, in
-   particular if the file is opened for writing and the new starting position
-   would be before the current position.
-*/
-
-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
-/*
-     Rewinds the given file. This function is supported only for reading.
-
-   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
-*/
-
-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
-/*
-     Returns the starting position for the next gzread or gzwrite on the
-   given compressed file. This position represents a number of bytes in the
-   uncompressed data stream.
-
-   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
-*/
-
-ZEXTERN int ZEXPORT gzeof OF((gzFile file));
-/*
-     Returns 1 when EOF has previously been detected reading the given
-   input stream, otherwise zero.
-*/
-
-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
-/*
-     Flushes all pending output if necessary, closes the compressed file
-   and deallocates all the (de)compression state. The return value is the zlib
-   error number (see function gzerror below).
-*/
-
-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
-/*
-     Returns the error message for the last error which occurred on the
-   given compressed file. errnum is set to zlib error number. If an
-   error occurred in the file system and not in the compression library,
-   errnum is set to Z_ERRNO and the application may consult errno
-   to get the exact error code.
-*/
-
-                        /* checksum functions */
-
-/*
-     These functions are not related to compression but are exported
-   anyway because they might be useful in applications using the
-   compression library.
-*/
-
-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
-
-/*
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum. If buf is NULL, this function returns
-   the required initial value for the checksum.
-   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
-   much faster. Usage example:
-
-     uLong adler = adler32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       adler = adler32(adler, buffer, length);
-     }
-     if (adler != original_adler) error();
-*/
-
-ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
-/*
-     Update a running crc with the bytes buf[0..len-1] and return the updated
-   crc. If buf is NULL, this function returns the required initial value
-   for the crc. Pre- and post-conditioning (one's complement) is performed
-   within this function so it shouldn't be done by the application.
-   Usage example:
-
-     uLong crc = crc32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       crc = crc32(crc, buffer, length);
-     }
-     if (crc != original_crc) error();
-*/
-
-
-                        /* various hacks, don't look :) */
-
-/* deflateInit and inflateInit are macros to allow checking the zlib version
- * and the compiler's view of z_stream:
- */
-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
-                                      int windowBits, int memLevel,
-                                      int strategy, const char *version,
-                                      int stream_size));
-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
-                                      const char *version, int stream_size));
-#define deflateInit(strm, level) \
-        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
-#define inflateInit(strm) \
-        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
-#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
-#define inflateInit2(strm, windowBits) \
-        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
-
-
-#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
-    struct internal_state {int dummy;}; /* hack for buggy compilers */
-#endif
-
-ZEXTERN const char   * ZEXPORT zError           OF((int err));
-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
-ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _ZLIB_H */
diff -urN CrashRpt-orig\crashrpttest\src\CrashRptTest.cpp CrashRpt\crashrpttest\src\CrashRptTest.cpp
--- CrashRpt-orig\crashrpttest\src\CrashRptTest.cpp	Wed Mar 12 20:07:10 2003
+++ CrashRpt\crashrpttest\src\CrashRptTest.cpp	Thu Apr 10 11:58:28 2003
@@ -48,8 +48,8 @@
 
 BOOL WINAPI CrashCallback(LPVOID lpvState)
 {
-   AddFile(lpvState, "dummy.log", "Dummy Log File");
-   AddFile(lpvState, "dummy.ini", "Dummy INI File");
+   AddFileEx(lpvState, "dummy.log", "Dummy Log File");
+   AddFileEx(lpvState, "dummy.ini", "Dummy INI File");
 
    return TRUE;
 }
@@ -69,7 +69,7 @@
 	Enable3dControlsStatic();	// Call this when linking to MFC statically
 #endif
 
-   m_lpvState = Install(CrashCallback, _T("mcarruth@email.com"), _T("Say what I want"));
+   m_lpvState = InstallEx(CrashCallback, NULL, NULL);
 
    CCrashRptTestDlg dlg;
    dlg.DoModal();
@@ -79,7 +79,7 @@
 
 void CCrashRptTestApp::generateErrorReport()
 {
-   GenerateErrorReport(m_lpvState, NULL);
+    GenerateErrorReportEx(m_lpvState, NULL, NULL);
 //   __try {
 //      RaiseException(EXCEPTION_BREAKPOINT, 0, 0, NULL);
 //   } __except(GenerateErrorReport(m_lpvState, GetExceptionInformation())){}
diff -urN CrashRpt-orig\crashrpttest\src\msxml.tlh CrashRpt\crashrpttest\src\msxml.tlh
--- CrashRpt-orig\crashrpttest\src\msxml.tlh	Sat Aug 18 09:00:00 2001
+++ CrashRpt\crashrpttest\src\msxml.tlh	Wed Dec 31 19:00:00 1969
@@ -1,1008 +0,0 @@
-// Created by Microsoft (R) C/C++ Compiler Version 12.00.8447.0 (544d87df).
-//
-// msxml.tlh
-//
-// C++ source equivalent of Win32 type library msxml.dll
-// compiler-generated file created 02/06/03 at 09:52:56 - DO NOT EDIT!
-
-#pragma once
-#pragma pack(push, 8)
-
-#include <comdef.h>
-
-namespace MSXML {
-
-//
-// Forward references and typedefs
-//
-
-struct __declspec(uuid("2933bf8f-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMImplementation;
-struct __declspec(uuid("2933bf80-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMNode;
-typedef enum tagDOMNodeType DOMNodeType;
-struct __declspec(uuid("2933bf82-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMNodeList;
-struct __declspec(uuid("2933bf83-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMNamedNodeMap;
-struct __declspec(uuid("2933bf81-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMDocument;
-struct __declspec(uuid("2933bf8b-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMDocumentType;
-struct __declspec(uuid("2933bf86-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMElement;
-struct __declspec(uuid("2933bf85-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMAttribute;
-struct __declspec(uuid("3efaa413-272f-11d2-836f-0000f87a7782"))
-/* dual interface */ IXMLDOMDocumentFragment;
-struct __declspec(uuid("2933bf87-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMText;
-struct __declspec(uuid("2933bf84-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMCharacterData;
-struct __declspec(uuid("2933bf88-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMComment;
-struct __declspec(uuid("2933bf8a-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMCDATASection;
-struct __declspec(uuid("2933bf89-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMProcessingInstruction;
-struct __declspec(uuid("2933bf8e-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMEntityReference;
-struct __declspec(uuid("3efaa426-272f-11d2-836f-0000f87a7782"))
-/* dual interface */ IXMLDOMParseError;
-struct __declspec(uuid("2933bf8c-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMNotation;
-struct __declspec(uuid("2933bf8d-7b36-11d2-b20e-00c04f983e60"))
-/* dual interface */ IXMLDOMEntity;
-struct __declspec(uuid("3efaa425-272f-11d2-836f-0000f87a7782"))
-/* dual interface */ IXTLRuntime;
-struct __declspec(uuid("3efaa427-272f-11d2-836f-0000f87a7782"))
-/* dispinterface */ XMLDOMDocumentEvents;
-struct /* coclass */ DOMDocument;
-struct /* coclass */ DOMFreeThreadedDocument;
-struct __declspec(uuid("ed8c108d-4349-11d2-91a4-00c04f7969e8"))
-/* dual interface */ IXMLHttpRequest;
-struct /* coclass */ XMLHTTPRequest;
-struct __declspec(uuid("310afa62-0575-11d2-9ca9-0060b0ec3d39"))
-/* dual interface */ IXMLDSOControl;
-struct /* coclass */ XMLDSOControl;
-struct __declspec(uuid("65725580-9b5d-11d0-9bfe-00c04fc99c8e"))
-/* dual interface */ IXMLElementCollection;
-struct __declspec(uuid("f52e2b61-18a1-11d1-b105-00805f49916b"))
-/* dual interface */ IXMLDocument;
-struct __declspec(uuid("3f7f31ac-e15f-11d0-9c25-00c04fc99c8e"))
-/* dual interface */ IXMLElement;
-struct __declspec(uuid("2b8de2fe-8d2d-11d1-b2fc-00c04fd915a9"))
-/* interface */ IXMLDocument2;
-struct __declspec(uuid("2b8de2ff-8d2d-11d1-b2fc-00c04fd915a9"))
-/* dual interface */ IXMLElement2;
-struct __declspec(uuid("d4d4a0fc-3b73-11d1-b2b4-00c04fb92596"))
-/* dual interface */ IXMLAttribute;
-struct __declspec(uuid("948c5ad3-c58d-11d0-9c0b-00c04fc99c8e"))
-/* interface */ IXMLError;
-struct _xml_error;
-typedef enum tagXMLEMEM_TYPE XMLELEM_TYPE;
-struct /* coclass */ XMLDocument;
-
-//
-// Smart pointer typedef declarations
-//
-
-_COM_SMARTPTR_TYPEDEF(IXMLDOMImplementation, __uuidof(IXMLDOMImplementation));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMNode, __uuidof(IXMLDOMNode));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMNodeList, __uuidof(IXMLDOMNodeList));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMNamedNodeMap, __uuidof(IXMLDOMNamedNodeMap));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMDocument, __uuidof(IXMLDOMDocument));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMDocumentType, __uuidof(IXMLDOMDocumentType));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMElement, __uuidof(IXMLDOMElement));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMAttribute, __uuidof(IXMLDOMAttribute));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMDocumentFragment, __uuidof(IXMLDOMDocumentFragment));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMCharacterData, __uuidof(IXMLDOMCharacterData));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMText, __uuidof(IXMLDOMText));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMComment, __uuidof(IXMLDOMComment));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMCDATASection, __uuidof(IXMLDOMCDATASection));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMProcessingInstruction, __uuidof(IXMLDOMProcessingInstruction));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMEntityReference, __uuidof(IXMLDOMEntityReference));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMParseError, __uuidof(IXMLDOMParseError));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMNotation, __uuidof(IXMLDOMNotation));
-_COM_SMARTPTR_TYPEDEF(IXMLDOMEntity, __uuidof(IXMLDOMEntity));
-_COM_SMARTPTR_TYPEDEF(IXTLRuntime, __uuidof(IXTLRuntime));
-_COM_SMARTPTR_TYPEDEF(XMLDOMDocumentEvents, __uuidof(IDispatch));
-_COM_SMARTPTR_TYPEDEF(IXMLHttpRequest, __uuidof(IXMLHttpRequest));
-_COM_SMARTPTR_TYPEDEF(IXMLDSOControl, __uuidof(IXMLDSOControl));
-_COM_SMARTPTR_TYPEDEF(IXMLElementCollection, __uuidof(IXMLElementCollection));
-_COM_SMARTPTR_TYPEDEF(IXMLDocument, __uuidof(IXMLDocument));
-_COM_SMARTPTR_TYPEDEF(IXMLElement, __uuidof(IXMLElement));
-_COM_SMARTPTR_TYPEDEF(IXMLDocument2, __uuidof(IXMLDocument2));
-_COM_SMARTPTR_TYPEDEF(IXMLElement2, __uuidof(IXMLElement2));
-_COM_SMARTPTR_TYPEDEF(IXMLAttribute, __uuidof(IXMLAttribute));
-_COM_SMARTPTR_TYPEDEF(IXMLError, __uuidof(IXMLError));
-
-//
-// Type library items
-//
-
-struct __declspec(uuid("2933bf8f-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMImplementation : IDispatch
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall hasFeature (
-        BSTR feature,
-        BSTR version,
-        VARIANT_BOOL * hasFeature ) = 0;
-};
-
-struct __declspec(uuid("2933bf80-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMNode : IDispatch
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_nodeName (
-        BSTR * name ) = 0;
-    virtual HRESULT __stdcall get_nodeValue (
-        VARIANT * value ) = 0;
-    virtual HRESULT __stdcall put_nodeValue (
-        VARIANT value ) = 0;
-    virtual HRESULT __stdcall get_nodeType (
-        DOMNodeType * type ) = 0;
-    virtual HRESULT __stdcall get_parentNode (
-        struct IXMLDOMNode * * parent ) = 0;
-    virtual HRESULT __stdcall get_childNodes (
-        struct IXMLDOMNodeList * * childList ) = 0;
-    virtual HRESULT __stdcall get_firstChild (
-        struct IXMLDOMNode * * firstChild ) = 0;
-    virtual HRESULT __stdcall get_lastChild (
-        struct IXMLDOMNode * * lastChild ) = 0;
-    virtual HRESULT __stdcall get_previousSibling (
-        struct IXMLDOMNode * * previousSibling ) = 0;
-    virtual HRESULT __stdcall get_nextSibling (
-        struct IXMLDOMNode * * nextSibling ) = 0;
-    virtual HRESULT __stdcall get_attributes (
-        struct IXMLDOMNamedNodeMap * * attributeMap ) = 0;
-    virtual HRESULT __stdcall insertBefore (
-        struct IXMLDOMNode * newChild,
-        VARIANT refChild,
-        struct IXMLDOMNode * * outNewChild ) = 0;
-    virtual HRESULT __stdcall replaceChild (
-        struct IXMLDOMNode * newChild,
-        struct IXMLDOMNode * oldChild,
-        struct IXMLDOMNode * * outOldChild ) = 0;
-    virtual HRESULT __stdcall removeChild (
-        struct IXMLDOMNode * childNode,
-        struct IXMLDOMNode * * oldChild ) = 0;
-    virtual HRESULT __stdcall appendChild (
-        struct IXMLDOMNode * newChild,
-        struct IXMLDOMNode * * outNewChild ) = 0;
-    virtual HRESULT __stdcall hasChildNodes (
-        VARIANT_BOOL * hasChild ) = 0;
-    virtual HRESULT __stdcall get_ownerDocument (
-        struct IXMLDOMDocument * * DOMDocument ) = 0;
-    virtual HRESULT __stdcall cloneNode (
-        VARIANT_BOOL deep,
-        struct IXMLDOMNode * * cloneRoot ) = 0;
-    virtual HRESULT __stdcall get_nodeTypeString (
-        BSTR * nodeType ) = 0;
-    virtual HRESULT __stdcall get_text (
-        BSTR * text ) = 0;
-    virtual HRESULT __stdcall put_text (
-        BSTR text ) = 0;
-    virtual HRESULT __stdcall get_specified (
-        VARIANT_BOOL * isSpecified ) = 0;
-    virtual HRESULT __stdcall get_definition (
-        struct IXMLDOMNode * * definitionNode ) = 0;
-    virtual HRESULT __stdcall get_nodeTypedValue (
-        VARIANT * typedValue ) = 0;
-    virtual HRESULT __stdcall put_nodeTypedValue (
-        VARIANT typedValue ) = 0;
-    virtual HRESULT __stdcall get_dataType (
-        VARIANT * dataTypeName ) = 0;
-    virtual HRESULT __stdcall put_dataType (
-        BSTR dataTypeName ) = 0;
-    virtual HRESULT __stdcall get_xml (
-        BSTR * xmlString ) = 0;
-    virtual HRESULT __stdcall transformNode (
-        struct IXMLDOMNode * stylesheet,
-        BSTR * xmlString ) = 0;
-    virtual HRESULT __stdcall selectNodes (
-        BSTR queryString,
-        struct IXMLDOMNodeList * * resultList ) = 0;
-    virtual HRESULT __stdcall selectSingleNode (
-        BSTR queryString,
-        struct IXMLDOMNode * * resultNode ) = 0;
-    virtual HRESULT __stdcall get_parsed (
-        VARIANT_BOOL * isParsed ) = 0;
-    virtual HRESULT __stdcall get_namespaceURI (
-        BSTR * namespaceURI ) = 0;
-    virtual HRESULT __stdcall get_prefix (
-        BSTR * prefixString ) = 0;
-    virtual HRESULT __stdcall get_baseName (
-        BSTR * nameString ) = 0;
-    virtual HRESULT __stdcall transformNodeToObject (
-        struct IXMLDOMNode * stylesheet,
-        VARIANT outputObject ) = 0;
-};
-
-enum tagDOMNodeType
-{
-    NODE_INVALID = 0,
-    NODE_ELEMENT = 1,
-    NODE_ATTRIBUTE = 2,
-    NODE_TEXT = 3,
-    NODE_CDATA_SECTION = 4,
-    NODE_ENTITY_REFERENCE = 5,
-    NODE_ENTITY = 6,
-    NODE_PROCESSING_INSTRUCTION = 7,
-    NODE_COMMENT = 8,
-    NODE_DOCUMENT = 9,
-    NODE_DOCUMENT_TYPE = 10,
-    NODE_DOCUMENT_FRAGMENT = 11,
-    NODE_NOTATION = 12
-};
-
-struct __declspec(uuid("2933bf82-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMNodeList : IDispatch
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_item (
-        long index,
-        struct IXMLDOMNode * * listItem ) = 0;
-    virtual HRESULT __stdcall get_length (
-        long * listLength ) = 0;
-    virtual HRESULT __stdcall nextNode (
-        struct IXMLDOMNode * * nextItem ) = 0;
-    virtual HRESULT __stdcall reset ( ) = 0;
-    virtual HRESULT __stdcall get__newEnum (
-        IUnknown * * ppUnk ) = 0;
-};
-
-struct __declspec(uuid("2933bf83-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMNamedNodeMap : IDispatch
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall getNamedItem (
-        BSTR name,
-        struct IXMLDOMNode * * namedItem ) = 0;
-    virtual HRESULT __stdcall setNamedItem (
-        struct IXMLDOMNode * newItem,
-        struct IXMLDOMNode * * nameItem ) = 0;
-    virtual HRESULT __stdcall removeNamedItem (
-        BSTR name,
-        struct IXMLDOMNode * * namedItem ) = 0;
-    virtual HRESULT __stdcall get_item (
-        long index,
-        struct IXMLDOMNode * * listItem ) = 0;
-    virtual HRESULT __stdcall get_length (
-        long * listLength ) = 0;
-    virtual HRESULT __stdcall getQualifiedItem (
-        BSTR baseName,
-        BSTR namespaceURI,
-        struct IXMLDOMNode * * qualifiedItem ) = 0;
-    virtual HRESULT __stdcall removeQualifiedItem (
-        BSTR baseName,
-        BSTR namespaceURI,
-        struct IXMLDOMNode * * qualifiedItem ) = 0;
-    virtual HRESULT __stdcall nextNode (
-        struct IXMLDOMNode * * nextItem ) = 0;
-    virtual HRESULT __stdcall reset ( ) = 0;
-    virtual HRESULT __stdcall get__newEnum (
-        IUnknown * * ppUnk ) = 0;
-};
-
-struct __declspec(uuid("2933bf81-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMDocument : IXMLDOMNode
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_doctype (
-        struct IXMLDOMDocumentType * * documentType ) = 0;
-    virtual HRESULT __stdcall get_implementation (
-        struct IXMLDOMImplementation * * impl ) = 0;
-    virtual HRESULT __stdcall get_documentElement (
-        struct IXMLDOMElement * * DOMElement ) = 0;
-    virtual HRESULT __stdcall putref_documentElement (
-        struct IXMLDOMElement * DOMElement ) = 0;
-    virtual HRESULT __stdcall createElement (
-        BSTR tagName,
-        struct IXMLDOMElement * * element ) = 0;
-    virtual HRESULT __stdcall createDocumentFragment (
-        struct IXMLDOMDocumentFragment * * docFrag ) = 0;
-    virtual HRESULT __stdcall createTextNode (
-        BSTR data,
-        struct IXMLDOMText * * text ) = 0;
-    virtual HRESULT __stdcall createComment (
-        BSTR data,
-        struct IXMLDOMComment * * comment ) = 0;
-    virtual HRESULT __stdcall createCDATASection (
-        BSTR data,
-        struct IXMLDOMCDATASection * * cdata ) = 0;
-    virtual HRESULT __stdcall createProcessingInstruction (
-        BSTR target,
-        BSTR data,
-        struct IXMLDOMProcessingInstruction * * pi ) = 0;
-    virtual HRESULT __stdcall createAttribute (
-        BSTR name,
-        struct IXMLDOMAttribute * * attribute ) = 0;
-    virtual HRESULT __stdcall createEntityReference (
-        BSTR name,
-        struct IXMLDOMEntityReference * * entityRef ) = 0;
-    virtual HRESULT __stdcall getElementsByTagName (
-        BSTR tagName,
-        struct IXMLDOMNodeList * * resultList ) = 0;
-    virtual HRESULT __stdcall createNode (
-        VARIANT type,
-        BSTR name,
-        BSTR namespaceURI,
-        struct IXMLDOMNode * * node ) = 0;
-    virtual HRESULT __stdcall nodeFromID (
-        BSTR idString,
-        struct IXMLDOMNode * * node ) = 0;
-    virtual HRESULT __stdcall load (
-        VARIANT xmlSource,
-        VARIANT_BOOL * isSuccessful ) = 0;
-    virtual HRESULT __stdcall get_readyState (
-        long * value ) = 0;
-    virtual HRESULT __stdcall get_parseError (
-        struct IXMLDOMParseError * * errorObj ) = 0;
-    virtual HRESULT __stdcall get_url (
-        BSTR * urlString ) = 0;
-    virtual HRESULT __stdcall get_async (
-        VARIANT_BOOL * isAsync ) = 0;
-    virtual HRESULT __stdcall put_async (
-        VARIANT_BOOL isAsync ) = 0;
-    virtual HRESULT __stdcall abort ( ) = 0;
-    virtual HRESULT __stdcall loadXML (
-        BSTR bstrXML,
-        VARIANT_BOOL * isSuccessful ) = 0;
-    virtual HRESULT __stdcall save (
-        VARIANT destination ) = 0;
-    virtual HRESULT __stdcall get_validateOnParse (
-        VARIANT_BOOL * isValidating ) = 0;
-    virtual HRESULT __stdcall put_validateOnParse (
-        VARIANT_BOOL isValidating ) = 0;
-    virtual HRESULT __stdcall get_resolveExternals (
-        VARIANT_BOOL * isResolving ) = 0;
-    virtual HRESULT __stdcall put_resolveExternals (
-        VARIANT_BOOL isResolving ) = 0;
-    virtual HRESULT __stdcall get_preserveWhiteSpace (
-        VARIANT_BOOL * isPreserving ) = 0;
-    virtual HRESULT __stdcall put_preserveWhiteSpace (
-        VARIANT_BOOL isPreserving ) = 0;
-    virtual HRESULT __stdcall put_onreadystatechange (
-        VARIANT _arg1 ) = 0;
-    virtual HRESULT __stdcall put_ondataavailable (
-        VARIANT _arg1 ) = 0;
-    virtual HRESULT __stdcall put_ontransformnode (
-        VARIANT _arg1 ) = 0;
-};
-
-struct __declspec(uuid("2933bf8b-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMDocumentType : IXMLDOMNode
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_name (
-        BSTR * rootName ) = 0;
-    virtual HRESULT __stdcall get_entities (
-        struct IXMLDOMNamedNodeMap * * entityMap ) = 0;
-    virtual HRESULT __stdcall get_notations (
-        struct IXMLDOMNamedNodeMap * * notationMap ) = 0;
-};
-
-struct __declspec(uuid("2933bf86-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMElement : IXMLDOMNode
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_tagName (
-        BSTR * tagName ) = 0;
-    virtual HRESULT __stdcall getAttribute (
-        BSTR name,
-        VARIANT * value ) = 0;
-    virtual HRESULT __stdcall setAttribute (
-        BSTR name,
-        VARIANT value ) = 0;
-    virtual HRESULT __stdcall removeAttribute (
-        BSTR name ) = 0;
-    virtual HRESULT __stdcall getAttributeNode (
-        BSTR name,
-        struct IXMLDOMAttribute * * attributeNode ) = 0;
-    virtual HRESULT __stdcall setAttributeNode (
-        struct IXMLDOMAttribute * DOMAttribute,
-        struct IXMLDOMAttribute * * attributeNode ) = 0;
-    virtual HRESULT __stdcall removeAttributeNode (
-        struct IXMLDOMAttribute * DOMAttribute,
-        struct IXMLDOMAttribute * * attributeNode ) = 0;
-    virtual HRESULT __stdcall getElementsByTagName (
-        BSTR tagName,
-        struct IXMLDOMNodeList * * resultList ) = 0;
-    virtual HRESULT __stdcall normalize ( ) = 0;
-};
-
-struct __declspec(uuid("2933bf85-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMAttribute : IXMLDOMNode
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_name (
-        BSTR * attributeName ) = 0;
-    virtual HRESULT __stdcall get_value (
-        VARIANT * attributeValue ) = 0;
-    virtual HRESULT __stdcall put_value (
-        VARIANT attributeValue ) = 0;
-};
-
-struct __declspec(uuid("3efaa413-272f-11d2-836f-0000f87a7782"))
-IXMLDOMDocumentFragment : IXMLDOMNode
-{};
-
-struct __declspec(uuid("2933bf84-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMCharacterData : IXMLDOMNode
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_data (
-        BSTR * data ) = 0;
-    virtual HRESULT __stdcall put_data (
-        BSTR data ) = 0;
-    virtual HRESULT __stdcall get_length (
-        long * dataLength ) = 0;
-    virtual HRESULT __stdcall substringData (
-        long offset,
-        long count,
-        BSTR * data ) = 0;
-    virtual HRESULT __stdcall appendData (
-        BSTR data ) = 0;
-    virtual HRESULT __stdcall insertData (
-        long offset,
-        BSTR data ) = 0;
-    virtual HRESULT __stdcall deleteData (
-        long offset,
-        long count ) = 0;
-    virtual HRESULT __stdcall replaceData (
-        long offset,
-        long count,
-        BSTR data ) = 0;
-};
-
-struct __declspec(uuid("2933bf87-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMText : IXMLDOMCharacterData
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall splitText (
-        long offset,
-        struct IXMLDOMText * * rightHandTextNode ) = 0;
-};
-
-struct __declspec(uuid("2933bf88-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMComment : IXMLDOMCharacterData
-{};
-
-struct __declspec(uuid("2933bf8a-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMCDATASection : IXMLDOMText
-{};
-
-struct __declspec(uuid("2933bf89-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMProcessingInstruction : IXMLDOMNode
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_target (
-        BSTR * name ) = 0;
-    virtual HRESULT __stdcall get_data (
-        BSTR * value ) = 0;
-    virtual HRESULT __stdcall put_data (
-        BSTR value ) = 0;
-};
-
-struct __declspec(uuid("2933bf8e-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMEntityReference : IXMLDOMNode
-{};
-
-struct __declspec(uuid("3efaa426-272f-11d2-836f-0000f87a7782"))
-IXMLDOMParseError : IDispatch
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_errorCode (
-        long * errorCode ) = 0;
-    virtual HRESULT __stdcall get_url (
-        BSTR * urlString ) = 0;
-    virtual HRESULT __stdcall get_reason (
-        BSTR * reasonString ) = 0;
-    virtual HRESULT __stdcall get_srcText (
-        BSTR * sourceString ) = 0;
-    virtual HRESULT __stdcall get_line (
-        long * lineNumber ) = 0;
-    virtual HRESULT __stdcall get_linepos (
-        long * linePosition ) = 0;
-    virtual HRESULT __stdcall get_filepos (
-        long * filePosition ) = 0;
-};
-
-struct __declspec(uuid("2933bf8c-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMNotation : IXMLDOMNode
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_publicId (
-        VARIANT * publicId ) = 0;
-    virtual HRESULT __stdcall get_systemId (
-        VARIANT * systemId ) = 0;
-};
-
-struct __declspec(uuid("2933bf8d-7b36-11d2-b20e-00c04f983e60"))
-IXMLDOMEntity : IXMLDOMNode
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_publicId (
-        VARIANT * publicId ) = 0;
-    virtual HRESULT __stdcall get_systemId (
-        VARIANT * systemId ) = 0;
-    virtual HRESULT __stdcall get_notationName (
-        BSTR * name ) = 0;
-};
-
-struct __declspec(uuid("3efaa425-272f-11d2-836f-0000f87a7782"))
-IXTLRuntime : IXMLDOMNode
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall uniqueID (
-        struct IXMLDOMNode * pNode,
-        long * pID ) = 0;
-    virtual HRESULT __stdcall depth (
-        struct IXMLDOMNode * pNode,
-        long * pDepth ) = 0;
-    virtual HRESULT __stdcall childNumber (
-        struct IXMLDOMNode * pNode,
-        long * pNumber ) = 0;
-    virtual HRESULT __stdcall ancestorChildNumber (
-        BSTR bstrNodeName,
-        struct IXMLDOMNode * pNode,
-        long * pNumber ) = 0;
-    virtual HRESULT __stdcall absoluteChildNumber (
-        struct IXMLDOMNode * pNode,
-        long * pNumber ) = 0;
-    virtual HRESULT __stdcall formatIndex (
-        long lIndex,
-        BSTR bstrFormat,
-        BSTR * pbstrFormattedString ) = 0;
-    virtual HRESULT __stdcall formatNumber (
-        double dblNumber,
-        BSTR bstrFormat,
-        BSTR * pbstrFormattedString ) = 0;
-    virtual HRESULT __stdcall formatDate (
-        VARIANT varDate,
-        BSTR bstrFormat,
-        VARIANT varDestLocale,
-        BSTR * pbstrFormattedString ) = 0;
-    virtual HRESULT __stdcall formatTime (
-        VARIANT varTime,
-        BSTR bstrFormat,
-        VARIANT varDestLocale,
-        BSTR * pbstrFormattedString ) = 0;
-};
-
-struct __declspec(uuid("3efaa427-272f-11d2-836f-0000f87a7782"))
-XMLDOMDocumentEvents : IDispatch
-{};
-
-struct __declspec(uuid("2933bf90-7b36-11d2-b20e-00c04f983e60"))
-DOMDocument;
-    // [ default ] interface IXMLDOMDocument
-    // [ default, source ] dispinterface XMLDOMDocumentEvents
-
-struct __declspec(uuid("2933bf91-7b36-11d2-b20e-00c04f983e60"))
-DOMFreeThreadedDocument;
-    // [ default ] interface IXMLDOMDocument
-    // [ default, source ] dispinterface XMLDOMDocumentEvents
-
-struct __declspec(uuid("ed8c108d-4349-11d2-91a4-00c04f7969e8"))
-IXMLHttpRequest : IDispatch
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall open (
-        BSTR bstrMethod,
-        BSTR bstrUrl,
-        VARIANT varAsync = vtMissing,
-        VARIANT bstrUser = vtMissing,
-        VARIANT bstrPassword = vtMissing ) = 0;
-    virtual HRESULT __stdcall setRequestHeader (
-        BSTR bstrHeader,
-        BSTR bstrValue ) = 0;
-    virtual HRESULT __stdcall getResponseHeader (
-        BSTR bstrHeader,
-        BSTR * pbstrValue ) = 0;
-    virtual HRESULT __stdcall getAllResponseHeaders (
-        BSTR * pbstrHeaders ) = 0;
-    virtual HRESULT __stdcall send (
-        VARIANT varBody = vtMissing ) = 0;
-    virtual HRESULT __stdcall abort ( ) = 0;
-    virtual HRESULT __stdcall get_status (
-        long * plStatus ) = 0;
-    virtual HRESULT __stdcall get_statusText (
-        BSTR * pbstrStatus ) = 0;
-    virtual HRESULT __stdcall get_responseXML (
-        IDispatch * * ppBody ) = 0;
-    virtual HRESULT __stdcall get_responseText (
-        BSTR * pbstrBody ) = 0;
-    virtual HRESULT __stdcall get_responseBody (
-        VARIANT * pvarBody ) = 0;
-    virtual HRESULT __stdcall get_responseStream (
-        VARIANT * pvarBody ) = 0;
-    virtual HRESULT __stdcall get_readyState (
-        long * plState ) = 0;
-    virtual HRESULT __stdcall put_onreadystatechange (
-        IDispatch * _arg1 ) = 0;
-};
-
-struct __declspec(uuid("ed8c108e-4349-11d2-91a4-00c04f7969e8"))
-XMLHTTPRequest;
-    // [ default ] interface IXMLHttpRequest
-
-struct __declspec(uuid("310afa62-0575-11d2-9ca9-0060b0ec3d39"))
-IXMLDSOControl : IDispatch
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_XMLDocument (
-        struct IXMLDOMDocument * * ppDoc ) = 0;
-    virtual HRESULT __stdcall put_XMLDocument (
-        struct IXMLDOMDocument * ppDoc ) = 0;
-    virtual HRESULT __stdcall get_JavaDSOCompatible (
-        long * fJavaDSOCompatible ) = 0;
-    virtual HRESULT __stdcall put_JavaDSOCompatible (
-        long fJavaDSOCompatible ) = 0;
-    virtual HRESULT __stdcall get_readyState (
-        long * state ) = 0;
-};
-
-struct __declspec(uuid("550dda30-0541-11d2-9ca9-0060b0ec3d39"))
-XMLDSOControl;
-    // [ default ] interface IXMLDSOControl
-
-struct __declspec(uuid("65725580-9b5d-11d0-9bfe-00c04fc99c8e"))
-IXMLElementCollection : IDispatch
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall put_length (
-        long p ) = 0;
-    virtual HRESULT __stdcall get_length (
-        long * p ) = 0;
-    virtual HRESULT __stdcall get__newEnum (
-        IUnknown * * ppUnk ) = 0;
-    virtual HRESULT __stdcall item (
-        VARIANT var1,
-        VARIANT var2,
-        IDispatch * * ppDisp ) = 0;
-};
-
-struct __declspec(uuid("f52e2b61-18a1-11d1-b105-00805f49916b"))
-IXMLDocument : IDispatch
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_root (
-        struct IXMLElement * * p ) = 0;
-    virtual HRESULT __stdcall get_fileSize (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall get_fileModifiedDate (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall get_fileUpdatedDate (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall get_url (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall put_url (
-        BSTR p ) = 0;
-    virtual HRESULT __stdcall get_mimeType (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall get_readyState (
-        long * pl ) = 0;
-    virtual HRESULT __stdcall get_charset (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall put_charset (
-        BSTR p ) = 0;
-    virtual HRESULT __stdcall get_version (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall get_doctype (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall get_dtdURL (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall createElement (
-        VARIANT vType,
-        VARIANT var1,
-        struct IXMLElement * * ppElem ) = 0;
-};
-
-struct __declspec(uuid("3f7f31ac-e15f-11d0-9c25-00c04fc99c8e"))
-IXMLElement : IDispatch
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_tagName (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall put_tagName (
-        BSTR p ) = 0;
-    virtual HRESULT __stdcall get_parent (
-        struct IXMLElement * * ppParent ) = 0;
-    virtual HRESULT __stdcall setAttribute (
-        BSTR strPropertyName,
-        VARIANT PropertyValue ) = 0;
-    virtual HRESULT __stdcall getAttribute (
-        BSTR strPropertyName,
-        VARIANT * PropertyValue ) = 0;
-    virtual HRESULT __stdcall removeAttribute (
-        BSTR strPropertyName ) = 0;
-    virtual HRESULT __stdcall get_children (
-        struct IXMLElementCollection * * pp ) = 0;
-    virtual HRESULT __stdcall get_type (
-        long * plType ) = 0;
-    virtual HRESULT __stdcall get_text (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall put_text (
-        BSTR p ) = 0;
-    virtual HRESULT __stdcall addChild (
-        struct IXMLElement * pChildElem,
-        long lIndex,
-        long lReserved ) = 0;
-    virtual HRESULT __stdcall removeChild (
-        struct IXMLElement * pChildElem ) = 0;
-};
-
-struct __declspec(uuid("2b8de2fe-8d2d-11d1-b2fc-00c04fd915a9"))
-IXMLDocument2 : IDispatch
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_root (
-        struct IXMLElement2 * * p ) = 0;
-    virtual HRESULT __stdcall get_fileSize (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall get_fileModifiedDate (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall get_fileUpdatedDate (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall get_url (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall put_url (
-        BSTR p ) = 0;
-    virtual HRESULT __stdcall get_mimeType (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall get_readyState (
-        long * pl ) = 0;
-    virtual HRESULT __stdcall get_charset (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall put_charset (
-        BSTR p ) = 0;
-    virtual HRESULT __stdcall get_version (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall get_doctype (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall get_dtdURL (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall createElement (
-        VARIANT vType,
-        VARIANT var1,
-        struct IXMLElement2 * * ppElem ) = 0;
-    virtual HRESULT __stdcall get_async (
-        VARIANT_BOOL * pf ) = 0;
-    virtual HRESULT __stdcall put_async (
-        VARIANT_BOOL pf ) = 0;
-};
-
-struct __declspec(uuid("2b8de2ff-8d2d-11d1-b2fc-00c04fd915a9"))
-IXMLElement2 : IDispatch
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_tagName (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall put_tagName (
-        BSTR p ) = 0;
-    virtual HRESULT __stdcall get_parent (
-        struct IXMLElement2 * * ppParent ) = 0;
-    virtual HRESULT __stdcall setAttribute (
-        BSTR strPropertyName,
-        VARIANT PropertyValue ) = 0;
-    virtual HRESULT __stdcall getAttribute (
-        BSTR strPropertyName,
-        VARIANT * PropertyValue ) = 0;
-    virtual HRESULT __stdcall removeAttribute (
-        BSTR strPropertyName ) = 0;
-    virtual HRESULT __stdcall get_children (
-        struct IXMLElementCollection * * pp ) = 0;
-    virtual HRESULT __stdcall get_type (
-        long * plType ) = 0;
-    virtual HRESULT __stdcall get_text (
-        BSTR * p ) = 0;
-    virtual HRESULT __stdcall put_text (
-        BSTR p ) = 0;
-    virtual HRESULT __stdcall addChild (
-        struct IXMLElement2 * pChildElem,
-        long lIndex,
-        long lReserved ) = 0;
-    virtual HRESULT __stdcall removeChild (
-        struct IXMLElement2 * pChildElem ) = 0;
-    virtual HRESULT __stdcall get_attributes (
-        struct IXMLElementCollection * * pp ) = 0;
-};
-
-struct __declspec(uuid("d4d4a0fc-3b73-11d1-b2b4-00c04fb92596"))
-IXMLAttribute : IDispatch
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall get_name (
-        BSTR * n ) = 0;
-    virtual HRESULT __stdcall get_value (
-        BSTR * v ) = 0;
-};
-
-struct __declspec(uuid("948c5ad3-c58d-11d0-9c0b-00c04fc99c8e"))
-IXMLError : IUnknown
-{
-    //
-    // Raw methods provided by interface
-    //
-
-    virtual HRESULT __stdcall GetErrorInfo (
-        struct _xml_error * pErrorReturn ) = 0;
-};
-
-struct _xml_error
-{
-    unsigned int _nLine;
-    BSTR _pchBuf;
-    unsigned int _cchBuf;
-    unsigned int _ich;
-    BSTR _pszFound;
-    BSTR _pszExpected;
-    unsigned long _reserved1;
-    unsigned long _reserved2;
-};
-
-enum tagXMLEMEM_TYPE
-{
-    XMLELEMTYPE_ELEMENT = 0,
-    XMLELEMTYPE_TEXT = 1,
-    XMLELEMTYPE_COMMENT = 2,
-    XMLELEMTYPE_DOCUMENT = 3,
-    XMLELEMTYPE_DTD = 4,
-    XMLELEMTYPE_PI = 5,
-    XMLELEMTYPE_OTHER = 6
-};
-
-struct __declspec(uuid("cfc399af-d876-11d0-9c10-00c04fc99c8e"))
-XMLDocument;
-    // [ default ] interface IXMLDocument2
-
-//
-// Named GUID constants initializations
-//
-
-extern "C" const GUID __declspec(selectany) LIBID_MSXML =
-    {0xd63e0ce2,0xa0a2,0x11d0,{0x9c,0x02,0x00,0xc0,0x4f,0xc9,0x9c,0x8e}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMImplementation =
-    {0x2933bf8f,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMNode =
-    {0x2933bf80,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMNodeList =
-    {0x2933bf82,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMNamedNodeMap =
-    {0x2933bf83,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMDocument =
-    {0x2933bf81,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMDocumentType =
-    {0x2933bf8b,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMElement =
-    {0x2933bf86,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMAttribute =
-    {0x2933bf85,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMDocumentFragment =
-    {0x3efaa413,0x272f,0x11d2,{0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMCharacterData =
-    {0x2933bf84,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMText =
-    {0x2933bf87,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMComment =
-    {0x2933bf88,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMCDATASection =
-    {0x2933bf8a,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMProcessingInstruction =
-    {0x2933bf89,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMEntityReference =
-    {0x2933bf8e,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMParseError =
-    {0x3efaa426,0x272f,0x11d2,{0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMNotation =
-    {0x2933bf8c,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDOMEntity =
-    {0x2933bf8d,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXTLRuntime =
-    {0x3efaa425,0x272f,0x11d2,{0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82}};
-extern "C" const GUID __declspec(selectany) DIID_XMLDOMDocumentEvents =
-    {0x3efaa427,0x272f,0x11d2,{0x83,0x6f,0x00,0x00,0xf8,0x7a,0x77,0x82}};
-extern "C" const GUID __declspec(selectany) CLSID_DOMDocument =
-    {0x2933bf90,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) CLSID_DOMFreeThreadedDocument =
-    {0x2933bf91,0x7b36,0x11d2,{0xb2,0x0e,0x00,0xc0,0x4f,0x98,0x3e,0x60}};
-extern "C" const GUID __declspec(selectany) IID_IXMLHttpRequest =
-    {0xed8c108d,0x4349,0x11d2,{0x91,0xa4,0x00,0xc0,0x4f,0x79,0x69,0xe8}};
-extern "C" const GUID __declspec(selectany) CLSID_XMLHTTPRequest =
-    {0xed8c108e,0x4349,0x11d2,{0x91,0xa4,0x00,0xc0,0x4f,0x79,0x69,0xe8}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDSOControl =
-    {0x310afa62,0x0575,0x11d2,{0x9c,0xa9,0x00,0x60,0xb0,0xec,0x3d,0x39}};
-extern "C" const GUID __declspec(selectany) CLSID_XMLDSOControl =
-    {0x550dda30,0x0541,0x11d2,{0x9c,0xa9,0x00,0x60,0xb0,0xec,0x3d,0x39}};
-extern "C" const GUID __declspec(selectany) IID_IXMLElementCollection =
-    {0x65725580,0x9b5d,0x11d0,{0x9b,0xfe,0x00,0xc0,0x4f,0xc9,0x9c,0x8e}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDocument =
-    {0xf52e2b61,0x18a1,0x11d1,{0xb1,0x05,0x00,0x80,0x5f,0x49,0x91,0x6b}};
-extern "C" const GUID __declspec(selectany) IID_IXMLElement =
-    {0x3f7f31ac,0xe15f,0x11d0,{0x9c,0x25,0x00,0xc0,0x4f,0xc9,0x9c,0x8e}};
-extern "C" const GUID __declspec(selectany) IID_IXMLDocument2 =
-    {0x2b8de2fe,0x8d2d,0x11d1,{0xb2,0xfc,0x00,0xc0,0x4f,0xd9,0x15,0xa9}};
-extern "C" const GUID __declspec(selectany) IID_IXMLElement2 =
-    {0x2b8de2ff,0x8d2d,0x11d1,{0xb2,0xfc,0x00,0xc0,0x4f,0xd9,0x15,0xa9}};
-extern "C" const GUID __declspec(selectany) IID_IXMLAttribute =
-    {0xd4d4a0fc,0x3b73,0x11d1,{0xb2,0xb4,0x00,0xc0,0x4f,0xb9,0x25,0x96}};
-extern "C" const GUID __declspec(selectany) IID_IXMLError =
-    {0x948c5ad3,0xc58d,0x11d0,{0x9c,0x0b,0x00,0xc0,0x4f,0xc9,0x9c,0x8e}};
-extern "C" const GUID __declspec(selectany) CLSID_XMLDocument =
-    {0xcfc399af,0xd876,0x11d0,{0x9c,0x10,0x00,0xc0,0x4f,0xc9,0x9c,0x8e}};
-
-} // namespace MSXML
-
-#pragma pack(pop)
Binary files CrashRpt-orig\crashrpttest\src\res\Thumbs.db and CrashRpt\crashrpttest\src\res\Thumbs.db differ
Binary files CrashRpt-orig\dbghelp\bin\dbghelp.dll and CrashRpt\dbghelp\bin\dbghelp.dll differ
diff -urN CrashRpt-orig\dbghelp\Readme.txt CrashRpt\dbghelp\Readme.txt
--- CrashRpt-orig\dbghelp\Readme.txt	Wed Dec 31 19:00:00 1969
+++ CrashRpt\dbghelp\Readme.txt	Mon Apr 14 11:09:04 2003
@@ -0,0 +1,3 @@
+To get the complete Debugging Tools For Windows, go to http://www.microsoft.com/ddk/debugging/default.asp . You will need to install this to compile CrashRpt.
+
+The version of dbghelp.dll include here is 6.1.17.2, February 5, 2003. Check the above link for the most recent version.
\ No newline at end of file
diff -urN CrashRpt-orig\Readme.txt CrashRpt\Readme.txt
--- CrashRpt-orig\Readme.txt	Wed Dec 31 19:00:00 1969
+++ CrashRpt\Readme.txt	Fri May 09 14:50:45 2003
@@ -0,0 +1,28 @@
+This is the CrashRpt Library, which provides detailed crash reporting
+for your applications. Crash reports include at a minimum a memory dump, a
+description of the program state at the time of the crash (in an XML file).
+Arbitrary files, registry hives, and event logs can also be included in the
+report.
+
+The report can be saved for later analysis or e-mailed.
+
+See http://www.codeproject.com/debug/crash_report.asp for a full description
+of the library.
+
+Author: Mike Carruth.
+
+ This software is provided 'as-is', without any express or implied
+ warranty.  In no event will the authors be held liable for any damages
+ arising from the use of this software.
+
+ Permission is granted to anyone to use this software for any purpose,
+ including commercial applications, and to alter it and redistribute it
+ freely, subject to the following restrictions:
+
+ 1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+ 2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+ 3. This notice may not be removed or altered from any source distribution.
Binary files CrashRpt-orig\zlib\bin\zlib.dll and CrashRpt\zlib\bin\zlib.dll differ
diff -urN CrashRpt-orig\zlib\include\ioapi.h CrashRpt\zlib\include\ioapi.h
--- CrashRpt-orig\zlib\include\ioapi.h	Wed Dec 31 19:00:00 1969
+++ CrashRpt\zlib\include\ioapi.h	Wed Mar 13 16:39:24 2002
@@ -0,0 +1,64 @@
+/* ioapi.h -- IO base function header for compress/uncompress .zip 
+   files using zlib + zip or unzip API
+
+   Version 0.18 beta, Feb 26th, 2002
+
+   Copyright (C) 1998-2002 Gilles Vollant
+*/
+
+#ifndef _ZLIBIOAPI_H
+#define _ZLIBIOAPI_H
+
+
+#define ZLIB_FILEFUNC_SEEK_CUR (1)
+#define ZLIB_FILEFUNC_SEEK_END (2)
+#define ZLIB_FILEFUNC_SEEK_SET (0)
+
+#define ZLIB_FILEFUNC_MODE_READ      (1)
+#define ZLIB_FILEFUNC_MODE_WRITE     (2)
+#define ZLIB_FILEFUNC_MODE_READWRITEFILTER (3)
+
+#define ZLIB_FILEFUNC_MODE_EXISTING (4)
+#define ZLIB_FILEFUNC_MODE_CREATE   (8)
+
+
+#ifndef ZCALLBACK
+
+#if (defined(WIN32) || defined (WINDOWS) || defined (_WINDOWS)) && defined(CALLBACK)
+#define ZCALLBACK CALLBACK
+#else
+#define ZCALLBACK
+#endif
+#endif
+
+typedef voidpf (ZCALLBACK *open_file_func) OF((voidpf opaque, const char* filename, int mode));
+typedef uLong  (ZCALLBACK *read_file_func) OF((voidpf opaque, voidpf stream, void* buf, uLong size));
+typedef uLong  (ZCALLBACK *write_file_func) OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
+typedef long   (ZCALLBACK *tell_file_func) OF((voidpf opaque, voidpf stream));
+typedef long   (ZCALLBACK *seek_file_func) OF((voidpf opaque, voidpf stream, uLong offset, int origin));
+typedef long   (ZCALLBACK *close_file_func) OF((voidpf opaque, voidpf stream));
+typedef int    (ZCALLBACK *testerror_file_func) OF((voidpf opaque, voidpf stream));
+
+typedef struct zlib_filefunc_def_s
+{
+    open_file_func      zopen_file;
+    read_file_func      zread_file;
+    write_file_func     zwrite_file;
+    tell_file_func      ztell_file;
+    seek_file_func      zseek_file;
+    close_file_func     zclose_file;
+    testerror_file_func zerror_file;
+    voidpf              opaque;
+} zlib_filefunc_def;
+
+
+
+void fill_fopen_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
+
+#define ZREAD(filefunc,filestream,buf,size) ((*((filefunc).zread_file))((filefunc).opaque,filestream,buf,size))
+#define ZWRITE(filefunc,filestream,buf,size) ((*((filefunc).zwrite_file))((filefunc).opaque,filestream,buf,size))
+#define ZTELL(filefunc,filestream) ((*((filefunc).ztell_file))((filefunc).opaque,filestream))
+#define ZSEEK(filefunc,filestream,pos,mode) ((*((filefunc).zseek_file))((filefunc).opaque,filestream,pos,mode))
+#define ZCLOSE(filefunc,filestream) ((*((filefunc).zclose_file))((filefunc).opaque,filestream))
+#define ZERROR(filefunc,filestream) ((*((filefunc).zerror_file))((filefunc).opaque,filestream))
+#endif
diff -urN CrashRpt-orig\zlib\include\unzip.h CrashRpt\zlib\include\unzip.h
--- CrashRpt-orig\zlib\include\unzip.h	Wed Dec 31 19:00:00 1969
+++ CrashRpt\zlib\include\unzip.h	Tue Feb 26 23:34:02 2002
@@ -0,0 +1,300 @@
+/* unzip.h -- IO for uncompress .zip files using zlib 
+   Version 0.18 beta, Feb 26th, 2002
+
+   Copyright (C) 1998-2002 Gilles Vollant
+
+   This unzip package allow extract file from .ZIP file, compatible with PKZip 2.04g
+     WinZip, InfoZip tools and compatible.
+   Encryption and multi volume ZipFile (span) are not supported.
+   Old compressions used by old PKZip 1.x are not supported
+
+   THIS IS AN ALPHA VERSION. AT THIS STAGE OF DEVELOPPEMENT, SOMES API OR STRUCTURE
+   CAN CHANGE IN FUTURE VERSION !!
+   I WAIT FEEDBACK at mail info@winimage.com
+   Visit also http://www.winimage.com/zLibDll/unzip.htm for evolution
+
+   Condition of use and distribution are the same than zlib :
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+
+*/
+
+/* for more info about .ZIP format, see 
+      http://www.info-zip.org/pub/infozip/doc/appnote-981119-iz.zip
+      http://www.info-zip.org/pub/infozip/doc/
+   PkWare has also a specification at :
+      ftp://ftp.pkware.com/probdesc.zip
+*/
+
+#ifndef _unz_H
+#define _unz_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef _ZLIB_H
+#include "zlib.h"
+#endif
+
+#ifndef _ZLIBIOAPI_H
+#include "ioapi.h"
+#endif
+
+#if defined(STRICTUNZIP) || defined(STRICTZIPUNZIP)
+/* like the STRICT of WIN32, we define a pointer that cannot be converted
+    from (void*) without cast */
+typedef struct TagunzFile__ { int unused; } unzFile__; 
+typedef unzFile__ *unzFile;
+#else
+typedef voidp unzFile;
+#endif
+
+
+#define UNZ_OK                                  (0)
+#define UNZ_END_OF_LIST_OF_FILE (-100)
+#define UNZ_ERRNO               (Z_ERRNO)
+#define UNZ_EOF                 (0)
+#define UNZ_PARAMERROR                  (-102)
+#define UNZ_BADZIPFILE                  (-103)
+#define UNZ_INTERNALERROR               (-104)
+#define UNZ_CRCERROR                    (-105)
+
+/* tm_unz contain date/time info */
+typedef struct tm_unz_s 
+{
+	uInt tm_sec;            /* seconds after the minute - [0,59] */
+	uInt tm_min;            /* minutes after the hour - [0,59] */
+	uInt tm_hour;           /* hours since midnight - [0,23] */
+	uInt tm_mday;           /* day of the month - [1,31] */
+	uInt tm_mon;            /* months since January - [0,11] */
+	uInt tm_year;           /* years - [1980..2044] */
+} tm_unz;
+
+/* unz_global_info structure contain global data about the ZIPfile
+   These data comes from the end of central dir */
+typedef struct unz_global_info_s
+{
+	uLong number_entry;         /* total number of entries in
+				       the central dir on this disk */
+	uLong size_comment;         /* size of the global comment of the zipfile */
+} unz_global_info;
+
+
+/* unz_file_info contain information about a file in the zipfile */
+typedef struct unz_file_info_s
+{
+    uLong version;              /* version made by                 2 bytes */
+    uLong version_needed;       /* version needed to extract       2 bytes */
+    uLong flag;                 /* general purpose bit flag        2 bytes */
+    uLong compression_method;   /* compression method              2 bytes */
+    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
+    uLong crc;                  /* crc-32                          4 bytes */
+    uLong compressed_size;      /* compressed size                 4 bytes */ 
+    uLong uncompressed_size;    /* uncompressed size               4 bytes */ 
+    uLong size_filename;        /* filename length                 2 bytes */
+    uLong size_file_extra;      /* extra field length              2 bytes */
+    uLong size_file_comment;    /* file comment length             2 bytes */
+
+    uLong disk_num_start;       /* disk number start               2 bytes */
+    uLong internal_fa;          /* internal file attributes        2 bytes */
+    uLong external_fa;          /* external file attributes        4 bytes */
+
+    tm_unz tmu_date;
+} unz_file_info;
+
+extern int ZEXPORT unzStringFileNameCompare OF ((const char* fileName1,
+												 const char* fileName2,
+												 int iCaseSensitivity));
+/*
+   Compare two filename (fileName1,fileName2).
+   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
+   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
+								or strcasecmp)
+   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
+	(like 1 on Unix, 2 on Windows)
+*/
+
+
+extern unzFile ZEXPORT unzOpen OF((const char *path));
+/*
+  Open a Zip file. path contain the full pathname (by example,
+     on a Windows XP computer "c:\\zlib\\zlib113.zip" or on an Unix computer
+	 "zlib/zlib113.zip".
+	 If the zipfile cannot be opened (file don't exist or in not valid), the
+	   return value is NULL.
+     Else, the return value is a unzFile Handle, usable with other function
+	   of this unzip package.
+*/
+
+extern unzFile ZEXPORT unzOpen2 OF((const char *path,
+                                    zlib_filefunc_def* pzlib_filefunc_def));
+/*
+   Open a Zip file, like unzOpen, but provide a set of file low level API 
+      for read/write the zip file (see ioapi.h)
+*/
+
+extern int ZEXPORT unzClose OF((unzFile file));
+/*
+  Close a ZipFile opened with unzipOpen.
+  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
+    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
+  return UNZ_OK if there is no problem. */
+
+extern int ZEXPORT unzGetGlobalInfo OF((unzFile file,
+					unz_global_info *pglobal_info));
+/*
+  Write info about the ZipFile in the *pglobal_info structure.
+  No preparation of the structure is needed
+  return UNZ_OK if there is no problem. */
+
+
+extern int ZEXPORT unzGetGlobalComment OF((unzFile file,
+										   char *szComment,
+					   uLong uSizeBuf));
+/*
+  Get the global comment string of the ZipFile, in the szComment buffer.
+  uSizeBuf is the size of the szComment buffer.
+  return the number of byte copied or an error code <0
+*/
+
+
+/***************************************************************************/
+/* Unzip package allow you browse the directory of the zipfile */
+
+extern int ZEXPORT unzGoToFirstFile OF((unzFile file));
+/*
+  Set the current file of the zipfile to the first file.
+  return UNZ_OK if there is no problem
+*/
+
+extern int ZEXPORT unzGoToNextFile OF((unzFile file));
+/*
+  Set the current file of the zipfile to the next file.
+  return UNZ_OK if there is no problem
+  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
+*/
+
+extern int ZEXPORT unzLocateFile OF((unzFile file, 
+				     const char *szFileName,
+				     int iCaseSensitivity));
+/*
+  Try locate the file szFileName in the zipfile.
+  For the iCaseSensitivity signification, see unzStringFileNameCompare
+
+  return value :
+  UNZ_OK if the file is found. It becomes the current file.
+  UNZ_END_OF_LIST_OF_FILE if the file is not found
+*/
+
+
+extern int ZEXPORT unzGetCurrentFileInfo OF((unzFile file,
+					     unz_file_info *pfile_info,
+					     char *szFileName,
+					     uLong fileNameBufferSize,
+					     void *extraField,
+					     uLong extraFieldBufferSize,
+					     char *szComment,
+					     uLong commentBufferSize));
+/*
+  Get Info about the current file
+  if pfile_info!=NULL, the *pfile_info structure will contain somes info about
+	    the current file
+  if szFileName!=NULL, the filemane string will be copied in szFileName
+			(fileNameBufferSize is the size of the buffer)
+  if extraField!=NULL, the extra field information will be copied in extraField
+			(extraFieldBufferSize is the size of the buffer).
+			This is the Central-header version of the extra field
+  if szComment!=NULL, the comment string of the file will be copied in szComment
+			(commentBufferSize is the size of the buffer)
+*/
+
+/***************************************************************************/
+/* for reading the content of the current zipfile, you can open it, read data
+   from it, and close it (you can close it before reading all the file)
+   */
+
+extern int ZEXPORT unzOpenCurrentFile OF((unzFile file));
+/*
+  Open for reading data the current file in the zipfile.
+  If there is no error, the return value is UNZ_OK.
+*/
+
+extern int ZEXPORT unzOpenCurrentFile2 OF((unzFile file,
+                                           int* method,
+                                           int* level,
+                                           int raw));
+/*
+  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
+  *method will receive method of compression, *level will receive level of 
+     compression
+  note : you can set level parameter as NULL (if you did not want known level,
+         but you CANNOT set method parameter as NULL
+*/
+
+extern int ZEXPORT unzCloseCurrentFile OF((unzFile file));
+/*
+  Close the file in zip opened with unzOpenCurrentFile
+  Return UNZ_CRCERROR if all the file was read but the CRC is not good
+*/
+										
+extern int ZEXPORT unzReadCurrentFile OF((unzFile file, 
+					  voidp buf,
+					  unsigned len));
+/*
+  Read bytes from the current file (opened by unzOpenCurrentFile)
+  buf contain buffer where data must be copied
+  len the size of buf.
+
+  return the number of byte copied if somes bytes are copied
+  return 0 if the end of file was reached
+  return <0 with error code if there is an error
+    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
+*/
+
+extern z_off_t ZEXPORT unztell OF((unzFile file));
+/*
+  Give the current position in uncompressed data
+*/
+
+extern int ZEXPORT unzeof OF((unzFile file));
+/*
+  return 1 if the end of file was reached, 0 elsewhere 
+*/
+
+extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,
+											 voidp buf,
+											 unsigned len));
+/*
+  Read extra field from the current file (opened by unzOpenCurrentFile)
+  This is the local-header version of the extra field (sometimes, there is
+    more info in the local-header version than in the central-header)
+
+  if buf==NULL, it return the size of the local extra field
+
+  if buf!=NULL, len is the size of the buffer, the extra header is copied in
+	buf.
+  the return value is the number of bytes copied in buf, or (if <0) 
+	the error code
+*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _unz_H */
diff -urN CrashRpt-orig\zlib\include\zconf.h CrashRpt\zlib\include\zconf.h
--- CrashRpt-orig\zlib\include\zconf.h	Tue Mar 04 08:37:48 2003
+++ CrashRpt\zlib\include\zconf.h	Fri Jan 18 03:21:30 2002
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h 
  */
 
-/* @(#) $Id: unix-unified-diff.txt,v 1.1 2005-03-02 17:56:35 andcycle Exp $ */
+/* @(#) $Id: unix-unified-diff.txt,v 1.1 2005-03-02 17:56:35 andcycle Exp $ */
 
 #ifndef _ZCONF_H
 #define _ZCONF_H
@@ -92,7 +92,10 @@
 #endif
 
 /* Old Borland C incorrectly complains about missing returns: */
-#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
+#if defined(__BORLANDC__) && (__BORLANDC__ < 0x460)
+#  define NEED_DUMMY_RETURN
+#endif
+#if defined(__TURBOC__) && !defined(__BORLANDC__)
 #  define NEED_DUMMY_RETURN
 #endif
 
@@ -160,17 +163,24 @@
 #  endif
 #endif
 
+#if defined(WIN32) && (!defined(ZLIB_WIN32_NODLL)) && (!defined(ZLIB_DLL))
+#  define ZLIB_DLL
+#endif
+
 /* Compile with -DZLIB_DLL for Windows DLL support */
 #if defined(ZLIB_DLL)
-#  if defined(_WINDOWS) || defined(WINDOWS)
-#    ifdef FAR
-#      undef FAR
+#  if defined(_WINDOWS) || defined(WINDOWS) || defined(WIN32)
+#    ifndef WINAPI
+#      ifdef FAR
+#        undef FAR
+#      endif
+#      include <windows.h>
 #    endif
-#    include <windows.h>
-#    define ZEXPORT  WINAPI
 #    ifdef WIN32
+#      define ZEXPORT  WINAPI
 #      define ZEXPORTVA  WINAPIV
 #    else
+#      define ZEXPORT  WINAPI _export
 #      define ZEXPORTVA  FAR _cdecl _export
 #    endif
 #  endif
@@ -178,7 +188,7 @@
 #    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
 #      include <windows.h>
 #      define ZEXPORT __declspec(dllexport) WINAPI
-#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
+#      define ZEXPORTVA __declspec(dllexport) WINAPIV
 #    else
 #      if defined (_Windows) && defined (__DLL__)
 #        define ZEXPORT _export
@@ -238,6 +248,9 @@
 #ifdef HAVE_UNISTD_H
 #  include <sys/types.h> /* for off_t */
 #  include <unistd.h>    /* for SEEK_* and off_t */
+#  ifdef VMS
+#    include <unixio.h>   /* for off_t */
+#  endif
 #  define z_off_t  off_t
 #endif
 #ifndef SEEK_SET
diff -urN CrashRpt-orig\zlib\include\zip.h CrashRpt\zlib\include\zip.h
--- CrashRpt-orig\zlib\include\zip.h	Thu Mar 19 01:15:00 1998
+++ CrashRpt\zlib\include\zip.h	Tue Feb 26 23:34:02 2002
@@ -1,7 +1,7 @@
 /* zip.h -- IO for compress .zip files using zlib 
-   Version 0.15 alpha, Mar 19th, 1998,
+   Version 0.18 beta, Feb 26th, 2002
 
-   Copyright (C) 1998 Gilles Vollant
+   Copyright (C) 1998-2002 Gilles Vollant
 
    This unzip package allow creates .ZIP file, compatible with PKZip 2.04g
      WinZip, InfoZip tools and compatible.
@@ -13,7 +13,7 @@
    THIS IS AN ALPHA VERSION. AT THIS STAGE OF DEVELOPPEMENT, SOMES API OR STRUCTURE
    CAN CHANGE IN FUTURE VERSION !!
    I WAIT FEEDBACK at mail info@winimage.com
-   Visit also http://www.winimage.com/zLibDll/zip.htm for evolution
+   Visit also http://www.winimage.com/zLibDll/unzip.html for evolution
 
    Condition of use and distribution are the same than zlib :
 
@@ -37,7 +37,8 @@
 */
 
 /* for more info about .ZIP format, see 
-      ftp://ftp.cdrom.com/pub/infozip/doc/appnote-970311-iz.zip
+      http://www.info-zip.org/pub/infozip/doc/appnote-981119-iz.zip
+      http://www.info-zip.org/pub/infozip/doc/
    PkWare has also a specification at :
       ftp://ftp.pkware.com/probdesc.zip
 */
@@ -53,6 +54,10 @@
 #include "zlib.h"
 #endif
 
+#ifndef _ZLIBIOAPI_H
+#include "ioapi.h"
+#endif
+
 #if defined(STRICTZIP) || defined(STRICTZIPUNZIP)
 /* like the STRICT of WIN32, we define a pointer that cannot be converted
     from (void*) without cast */
@@ -88,20 +93,26 @@
     uLong       external_fa;    /* external file attributes        4 bytes */
 } zip_fileinfo;
 
+typedef const char* zipcharpc;
+
+
 extern zipFile ZEXPORT zipOpen OF((const char *pathname, int append));
 /*
   Create a zipfile.
-	 pathname contain on Windows NT a filename like "c:\\zlib\\zlib111.zip" or on
-	   an Unix computer "zlib/zlib111.zip".
+	 pathname contain on Windows XP a filename like "c:\\zlib\\zlib113.zip" or on
+	   an Unix computer "zlib/zlib113.zip".
 	 if the file pathname exist and append=1, the zip will be created at the end
 	   of the file. (useful if the file contain a self extractor code)
 	 If the zipfile cannot be opened, the return value is NULL.
      Else, the return value is a zipFile Handle, usable with other function
 	   of this zip package.
-
-
 */
 
+extern zipFile ZEXPORT zipOpen2 OF((const char *pathname, 
+                                   int append,
+                                   zipcharpc* globalcomment,
+                                   zlib_filefunc_def* pzlib_filefunc_def));
+
 extern int ZEXPORT zipOpenNewFileInZip OF((zipFile file,
 					   const char* filename,
 					   const zip_fileinfo* zipfi,
@@ -125,6 +136,23 @@
   level contain the level of compression (can be Z_DEFAULT_COMPRESSION)
 */
 
+
+extern int ZEXPORT zipOpenNewFileInZip2 OF((zipFile file,
+					   const char* filename,
+					   const zip_fileinfo* zipfi,
+					   const void* extrafield_local,
+					   uInt size_extrafield_local,
+					   const void* extrafield_global,
+					   uInt size_extrafield_global,
+					   const char* comment,
+					   int method,
+					   int level,
+                       int raw));
+
+/*
+  Same than zipOpenNewFileInZip, except if raw=1, we write raw file
+ */
+
 extern int ZEXPORT zipWriteInFileInZip OF((zipFile file,
 					   const voidp buf,
 					   unsigned len));
@@ -135,6 +163,16 @@
 extern int ZEXPORT zipCloseFileInZip OF((zipFile file));
 /*
   Close the current file in the zipfile
+*/
+
+
+extern int ZEXPORT zipCloseFileInZipRaw OF((zipFile file,
+                                            uLong uncompressed_size,
+                                            uLong crc32));
+/*
+  Close the current file in the zipfile, for fiel opened with 
+    parameter raw=1 in zipOpenNewFileInZip2
+  uncompressed_size and crc32 are value for the uncompressed size
 */
 
 extern int ZEXPORT zipClose OF((zipFile file,
diff -urN CrashRpt-orig\zlib\include\zlib.h CrashRpt\zlib\include\zlib.h
--- CrashRpt-orig\zlib\include\zlib.h	Thu Jul 09 18:06:56 1998
+++ CrashRpt\zlib\include\zlib.h	Mon Mar 11 14:56:38 2002
@@ -1,7 +1,7 @@
 /* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.1.3, July 9th, 1998
+  version 1.1.4, March 11th, 2002
 
-  Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler
+  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -37,7 +37,7 @@
 extern "C" {
 #endif
 
-#define ZLIB_VERSION "1.1.3"
+#define ZLIB_VERSION "1.1.4"
 
 /* 
      The 'zlib' compression library provides in-memory compression and
Binary files CrashRpt-orig\zlib\lib\zlib.lib and CrashRpt\zlib\lib\zlib.lib differ
diff -urN CrashRpt-orig\zlib\Readme.txt CrashRpt\zlib\Readme.txt
--- CrashRpt-orig\zlib\Readme.txt	Wed Dec 31 19:00:00 1969
+++ CrashRpt\zlib\Readme.txt	Mon Apr 14 11:06:10 2003
@@ -0,0 +1,3 @@
+The Zlib DLL included here is version 1.1.4, from www.winimage.com/zLibDll .
+
+The Zlib (source) home page is http://www.gzip.org/zlib/ .
\ No newline at end of file
